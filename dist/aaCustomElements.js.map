{"version":3,"sources":["webpack://executableHTML/webpack/universalModuleDefinition","webpack://executableHTML/webpack/bootstrap","webpack://executableHTML/(webpack)/buildin/amd-options.js","webpack://executableHTML/(webpack)/buildin/global.js","webpack://executableHTML/(webpack)/buildin/harmony-module.js","webpack://executableHTML/./src/customElements/aa-affect-grid/aa-affect-grid.js","webpack://executableHTML/./src/customElements/aa-baseElement/baseElement.js","webpack://executableHTML/./src/customElements/aa-checkboxes/aa-checkboxes.js","webpack://executableHTML/./src/customElements/aa-choice-item/aa-choice-item.js","webpack://executableHTML/./src/customElements/aa-choose/aa-choose.js","webpack://executableHTML/./src/customElements/aa-choose/aa-otherwise/aa-otherwise.js","webpack://executableHTML/./src/customElements/aa-choose/aa-when/aa-when.js","webpack://executableHTML/./src/customElements/aa-function/aa-function-random.js","webpack://executableHTML/./src/customElements/aa-geolocation/aa-geolocation.js","webpack://executableHTML/./src/customElements/aa-label/aa-label.js","webpack://executableHTML/./src/customElements/aa-likert-scale/aa-likert-scale.js","webpack://executableHTML/./src/customElements/aa-memory/aa-memory.js","webpack://executableHTML/./src/customElements/aa-multiple-choice/aa-multiple-choice.js","webpack://executableHTML/./src/customElements/aa-screen/aa-screen.js","webpack://executableHTML/./src/customElements/aa-sequence/aa-jump/aa-jump.js","webpack://executableHTML/./src/customElements/aa-sequence/aa-sequence.js","webpack://executableHTML/./src/customElements/aa-session/aa-session.js","webpack://executableHTML/./src/customElements/aa-slider/aa-slider.js","webpack://executableHTML/./src/customElements/aa-text-answer/aa-text-answer.js","webpack://executableHTML/./src/customElements/aa-variable/aa-variable.js","webpack://executableHTML/./src/index.js","webpack://executableHTML/./src/lib/html2jsl/html2jsl.js","webpack://executableHTML/./src/lib/jsep/jsep.js","webpack://executableHTML/./src/lib/mySVG/mySVG.js","webpack://executableHTML/./src/lib/svg/svg.js","webpack://executableHTML/./src/lib/yaml/js-yaml.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;;;;;;;;;;;;;ACDA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAA2D;AAC5C,2BAA2B,sEAAW;;;;AAIrD;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;;;;AAItD;;;;AAIA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4EAA4E,aAAa;AACzF;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA;;;AAGA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;;;;;AAMA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,aAAa,IAAI,iBAAiB;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA,oBAAoB,aAAa;AACjC,wBAAwB,gBAAgB;AACxC,+CAA+C,cAAc,GAAG,2BAA2B,IAAI,eAAe,IAAI,6BAA6B,YAAY,mCAAmC,YAAY,gCAAgC;AAC1O;AACA;AACA;;AAEA;AACA,kEAAkE,cAAc,uBAAuB;;AAEvG,6DAA6D;AAC7D;AACA,2CAA2C,cAAc,oBAAoB;AAC7E,0EAA0E,kBAAkB;AAC5F,kEAAkE,sBAAsB,cAAc;AACtG,2EAA2E,mBAAmB;AAC9F;AACA;AACA;;;AAGA,gEAAgE;AAChE,iEAAiE,uBAAuB;AACxF,4DAA4D,KAAK;AACjE,kEAAkE;AAClE;;;AAGA,gEAAgE,oBAAoB;AACpF;AACA,uCAAuC,cAAc,oBAAoB;AACzE,yEAAyE,qBAAqB;AAC9F,oEAAoE,iBAAiB;AACrF,0EAA0E,sBAAsB;;AAEhG;AACA;;AAEA;;AAEA,iEAAiE,aAAa,UAAU,eAAe,oBAAoB,+BAA+B,0BAA0B,2BAA2B;AAC/M,4CAA4C,iBAAiB,KAAK,qBAAqB;AACvF,4CAA4C,mBAAmB,gBAAgB,eAAe;AAC9F,4CAA4C,oBAAoB,kBAAkB;AAClF;;AAEA,kEAAkE,aAAa,YAAY,cAAc,oBAAoB,+BAA+B,yBAAyB,+BAA+B;AACpN,4CAA4C,oBAAoB,mBAAmB;AACnF,4CAA4C,mBAAmB,gBAAgB,gBAAgB;AAC/F,4CAA4C,qBAAqB,sBAAsB;AACvF;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA,sEAAW,mD;;;;;;;;;;;;ACxbX;AAAA;AAAA;AAAA;AAAA;AAAmC;AACwB;AACV;;AAEjD;;AAEA;AACA,mBAAmB,gBAAgB;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;;AAEe;;;;AAIf;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA,SAAS;AACT,2BAA2B,4BAA4B;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,0CAA0C;AACrE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;;;AAGb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;;;AAGA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,gDAAgD,aAAa;AAC7D,sDAAsD,cAAc;AACpE,8BAA8B,eAAe;AAC7C,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;;AAEA,yBAAyB;AACzB;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,eAAe,mEAAkB;AACjC;;;;AAIA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA,0BAA0B,yDAAK;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;;AAET;;;;;;AAMA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,qCAAqC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA,8DAA8D,wBAAwB;AACtF;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;AAChF,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;AC5cA;AAAA;AAAA;AAAA;AAA2D;AACd;;AAE9B,2BAA2B,sEAAW;;;;AAIrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;;;;AAKb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;;AAGA,aAAa,sEAAW;AACxB,kCAAkC,sEAAW;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;;AAEA;AACA,sB;AACA;;AAEA;;;AAGA,sEAAW,kD;;;;;;;;;;;;AC3JX;AAAA;AAAA;AAA2D;AAC5C,2BAA2B,sEAAW;;;AAGrD;AACA;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sEAAW,mD;;;;;;;;;;;;ACxCX;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6D;AAC/B;AACU;AACE;;AAE3B,uBAAuB,sEAAW;;;AAGjD;AACA;;AAEA,eAAe,sEAAW;;AAE1B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,gBAAgB,sEAAW;AAC3B;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mCAAmC,kBAAkB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,0BAA0B;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,wCAAwC;AAC/D;AACA;AACA;AACA;AACA,uCAAuC,sEAAW;AAClD;AACA,aAAa;AACb,mCAAmC,sEAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,4BAA4B,iEAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB,EAAE,mBAAmB,EAAE,sBAAsB;AAClG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D,4CAA4C,qBAAqB;AACjE,6CAA6C,sBAAsB;AACnE,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sEAAW;;;;;;;;;;;;;;ACvMX;AAAA;AAAA;AAA8D;;AAE/C,0BAA0B,sEAAW;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,sEAAW;;;;;;;;;;;;;AClBX;AAAA;AAAA;AAAgE;;AAEjD,qBAAqB,sEAAW;;;AAG/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sEAAW;;;;;;;;;;;;;;AC9CX;AAAA;AAAA;AAA2D;;AAE5C,+BAA+B,sEAAW;;;AAGzD;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;;AAGb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,gCAAgC,qBAAqB;AACrD,0BAA0B,eAAe;AACzC;;;AAGA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAW;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,sEAAW;;;;;;;;;;;;;;AC/EX;AAAA;AAAA;AAA4D;AAC7C,4BAA4B,sEAAW;;AAEtD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,eAAe;AACtD;;AAEA;;;AAGA;AACA;AACA,mCAAmC,kBAAkB;AACrD,4BAA4B;;AAE5B;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,8BAA8B;;AAE9B,uEAAuE,sBAAsB,kBAAkB;AAC/G;;;;AAIA,8EAA8E,sBAAsB,kBAAkB;AACtH;AACA,wCAAwC,iBAAiB;AACzD,aAAa;AACb;AACA;;;AAGA;;AAEA,sEAAW;;;;;;;;;;;;;;ACzFX;AAAA;AAAA;AAA2D;AAC5C,sBAAsB,sEAAW;;AAEhD;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sEAAW,wC;;;;;;;;;;;;AClCX;AAAA;AAAA;AAAA;AAA2D;AACN;;AAEtC,4BAA4B,sEAAW;;;AAGtD;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;;AAEA,uCAAuC,eAAe;;;AAGtD;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA,6CAA6C,uBAAuB,uCAAuC;AAC3G,8CAA8C,uBAAuB,wCAAwC;AAC7G,2CAA2C,uBAAuB,qCAAqC;AACvG;;;;AAIA;AACA,oBAAoB,UAAU;;;;AAI9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;AAGA,S;;AAEA,wEAAwE,YAAY,cAAc,8BAA8B,sBAAsB,EAAE;AACxJ;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,cAAc;AAClC,8CAA8C,YAAY,IAAI,YAAY;AAC1E;AACA;AACA,8EAA8E,UAAU,IAAI,MAAM;AAClG,kCAAkC,e;AAClC;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA,iC;AACA;;;;;AAKA;;AAEA,sEAAW;;;;;;;;;;;;;;AClKX;AAAA;AAAA;AAA4D;;;;AAI7C,uBAAuB,sEAAW;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sEAAW;;;;;;;;;;;;;AClCX;AAAA;AAAA;AAAA;AAA2D;AACd;;AAE9B,+BAA+B,sEAAW;;;;AAIzD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;;AAEA;AACA,uBAAuB,4BAA4B;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,sEAAW;AACxB,kCAAkC,sEAAW;AAC7C,SAAS;AACT;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,iB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;;AAEA;AACA,sB;AACA;AACA;;;AAGA,sEAAW,2D;;;;;;;;;;;;ACpLX;AAAA;AAAA;AAA6D;AAC9C,uBAAuB,sEAAW;;;;AAIjD;AACA;;AAEA,eAAe,sEAAW;;;AAG1B;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4FAA4F,WAAW;AACvG,SAAS;AACT,uDAAuD,WAAW;AAClE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA,8DAA8D,iBAAiB,qBAAqB,oBAAoB;AACxH,yGAAyG,c;AACzG;AACA,qGAAqG;AACrG;AACA;AACA;;AAEA,+DAA+D,yBAAyB,oBAAoB,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AAOA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,0BAA0B;AACjD,gBAAgB,sEAAW,iCAAiC,+BAA+B;AAC3F;AACA;AACA;;;;AAIA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;;AAEA;;AAEA,2BAA2B,sEAAW;AACtC;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA,uBAAuB,0BAA0B;AACjD,gBAAgB,sEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;AAMA;;AAEA,sEAAW;;;;;;;;;;;;;;ACrRX;AAAA;AAAA;AAA8D;;AAE/C,qBAAqB,sEAAW;;;;AAI/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC,sCAAsC;AACtE;AACA;AACA;;AAEA,sEAAW;;;;;;;;;;;;;AClCX;AAAA;AAAA;AAAA;AAA6D;AAC/B;;;;AAIf,yBAAyB,sEAAW;;AAEnD;AACA;;AAEA,eAAe,sEAAW;;AAE1B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;;AAEA;;AAEA,+BAA+B,QAAQ;AACvC;;AAEA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,sEAAW;AACnD;AACA;AACA;AACA,0EAA0E,QAAQ;AAClF;AACA;AACA,oCAAoC,sEAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D,6CAA6C,iBAAiB;AAC9D,kBAAkB,mCAAmC;AACrD,SAAS;AACT;AACA;AACA;;AAEA;;;;AAIA,sEAAW;;;;;;;;;;;;;;;ACjLX;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6D;AACxB;AACwB;AACjB;;;AAG7B,wBAAwB,sEAAW;;AAElD;;AAEA;;AAEA,eAAe,sEAAW;;;AAG1B;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;;;;;AAMb;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;;;AAGA;AACA;;;AAGA;;AAEA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA,mEAAmE,yBAAyB,QAAQ,EAAE;AACtG;AACA;AACA;AACA;AACA;;;AAGA,SAAS;;AAET;;AAEA;AACA,sEAAsE,sCAAsC;AAC5G;AACA,SAAS;;;AAGT;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,S;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gEAAgE,aAAa;AAC7E,SAAS;AACT;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA,QAAQ,sEAAW;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,oCAAoC;AAC3D;AACA,qBAAqB,sEAAW;AAChC;AACA;AACA;AACA;AACA,4CAA4C,cAAc,yBAAyB,EAAE;AACrF;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C,2BAA2B,mEAAkB;AAC7C;AACA,iCAAiC,mEAAkB;;AAEnD;AACA;;;;;AAKA,6BAA6B,yEAAwB,eAAe;AACpE,oBAAoB,yEAAwB;;AAE5C;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;;AAEA,sEAAW;;;;;;;;;;;;;;;;;;;;AC5NX;AAAA;AAAA;AAA2D;AAC5C,uBAAuB,sEAAW;;;;AAIjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,uCAAuC,eAAe;;AAEtD,kEAAkE,UAAU;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,uBAAuB;AACvB,oBAAoB,8BAA8B;;AAElD;AACA;AACA,SAAS;AACT;;;;AAIA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,4B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uEAAuE,SAAS,OAAO,SAAS;AAChG,+EAA+E,SAAS,SAAS,SAAS,WAAW,sBAAsB;;;AAG3I;AACA,eAAe,aAAa;AAC5B,iCAAiC;AACjC,oCAAoC,oBAAoB;AACxD,6DAA6D,oBAAoB;AACjF;AACA;AACA;AACA;;;AAGA;;AAEA,sEAAW,0C;;;;;;;;;;;;AC/JX;AAAA;AAAA;AAA2D;AAC5C,2BAA2B,sEAAW;;;;AAIrD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,sEAAW;;AAE7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA,wEAAwE,KAAK;;AAE7E;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD,oBAAoB,8BAA8B;AAClD;;AAEA;AACA;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,iBAAiB;AACjB;AACA,SAAS;;AAET;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,4B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,UAAU;AAC9C,8BAA8B,UAAU;AACxC,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;;AAEA,sEAAW;;;;;;;;;;;;;;ACjMX;AAAA;AAAA;AAAA;AAA4D;AAClB;;AAE3B,yBAAyB,sEAAW;;AAEnD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,kBAAkB;AAClD,yBAAyB;AACzB;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,iEAAI;AAChC;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB,EAAE,mBAAmB,EAAE,sBAAsB;AAClG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D,4CAA4C,qBAAqB;AACjE,6CAA6C,sBAAsB;AACnE,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,sEAAW;;;;;;;;;;;;;;ACvHX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACyE;AACI;AACF;AACZ;AACc;AACK;AACJ;AAClB;AACoB;AACjB;AAC0B;AACP;AACnB;AACG;AACG;AACN;AACc;AACR;AACF;;;;;;;;;;;;;;;;;;;;;;;AClB5D;;AAEP;AACA;AACA;AACA;AACA,SAAS,OAAO,YAAY,OAAO,GAAG;;AAEtC,KAAK;;;AAGL;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA,6BAA6B,eAAe,OAAO,EAAE;AACrD;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,qBAAqB,eAAe;AACpC,2CAA2C;AAC3C;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,EAAE,8BAA8B;AACxE;AACA;AACA,2BAA2B,MAAM,EAAE,8BAA8B;AACjE;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ,IAAI,UAAU,EAAE,uBAAuB,UAAU,SAAS,sBAAsB,EAAE,KAAK,EAAE;AACrH;AACA;;;;;;;;;;;;;ACnGA;AAAA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iCAAiC;AACjC,GAAG;AACH;AACA;AACA;AACA;AACA,wEAAwE;AACxE,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iCAAiC,EAAE;AAC5D,6BAA6B,qCAAqC,EAAE;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA,oCAAoC;AACpC;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,gCAAgC;AAChC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,cAAc;AACd,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,OAAO,gCAAgC;AACvC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,+DAA+D;;AAE5F;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,MAAM,KAA6B;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC,CAAC,SAAI,CAAC,EAAE;;;;;;;;;;;;;;AC/rBT;AAAA;AAAA;AAAA;AAAgC;AACU;;;;AAI1C;;;AAGA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;AAGA;;AAEA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;AAGA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;AACA,qBAAqB,2DAAG;AACxB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;;;AAIA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;;;AAIA;;AAEA,oBAAoB,2DAAG;AACvB,uBAAuB,sBAAsB;AAC7C,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA,qDAAqD,4CAA4C;AACjG,mFAAmF,8BAA8B;AACjH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA,oBAAoB,2DAAG;;AAEvB,uBAAuB,uBAAuB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,gBAAgB;;AAExC;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,uBAAuB,mBAAmB;;AAE1C;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;;;;;AAKA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA,mBAAmB,2DAAG;AACtB,mBAAmB,2DAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA,oBAAoB,2DAAG;AACvB,uBAAuB,+BAA+B;;AAEtD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,2DAAG;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI;;;AAG/E,mBAAmB,2DAAG;AACtB,mBAAmB,mDAAmD;AACtE;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA,+BAA+B,oCAAoC;;AAEnE;AACA;;AAEA;;AAEA;AACA;;AAEA,aAAa;;;AAGb;AACA,yDAAyD,YAAY;;AAErE;AACA,+BAA+B,4BAA4B;;AAE3D;AACA;AACA;;AAEA;AACA;;AAEA,aAAa;;AAEb;AACA,wBAAwB,2DAAG;AAC3B,2BAA2B,2DAAG,sBAAsB,0DAA0D;AAC9G;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,2DAAG;AAC9B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;;;AAGrB;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;;AAEA;AACA;;AAEA,yCAAyC,2DAAG,oBAAoB,0EAA0E;;;AAG1I;AACA,sDAAsD,qDAAqD;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,2DAAG,mBAAmB,oDAAoD;AACjH;;;;AAIA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,2DAAG;;AAElC;AACA;AACA;AACA,+BAA+B,0EAA0E;AACzG;;;AAGA;;;AAGA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;;AAEb;AACA;;AAEA,wBAAwB,2DAAG;;AAE3B,uDAAuD,iDAAiD;;AAExG,2BAA2B,2DAAG;AAC9B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,8BAA8B,2DAAG;AACjC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;;;;;AAKA,sDAAsD,qDAAqD;AAC3G,oDAAoD,qDAAqD;;;AAGzG;;;;;AAKA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;;AAEA,aAAa;;;AAGb;AACA;;AAEA;AACA,qDAAqD,0BAA0B;;AAE/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;;;AAGA;AACA,kCAAkC,4BAA4B;;AAE9D;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB;;AAEhB;AACA,gCAAgC,2DAAG;;AAEnC;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;;AAEA,2BAA2B,2DAAG;AAC9B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB,gCAAgC,2DAAG;AACnC;AACA;AACA,gCAAgC,iEAAI;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,iBAAiB;;;;;;AAMjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;;AAEb;AACA;;AAEA;AACA,qDAAqD,8BAA8B;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;;;AAGA;AACA,kCAAkC,4BAA4B;;AAE9D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,0BAA0B;AAChE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA,gCAAgC,2DAAG;;AAEnC;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;;AAEA,gCAAgC,2DAAG;AACnC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB,oBAAoB;;;;;;AAMpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;;AAEb;AACA,yDAAyD,YAAY;;AAErE;AACA,+BAA+B,4BAA4B;;AAE3D;AACA;AACA;;AAEA;AACA;;AAEA,aAAa;;;;;AAKb;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA,qBAAqB;;;AAGrB;;AAEA;AACA;;AAEA,qBAAqB;;AAErB;;AAEA;AACA;;AAEA,qBAAqB;;AAErB;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;AAIA,Q;;;;;;;;;;;;ACj+BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,YAAY,EAAE;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,QAAQ,mBAAmB,UAAU,EAAE,EAAE;AAC3E,EAAE;;AAEF,oCAAoC;AACpC;;AAEA;AACA,iFAAiF,OAAO;;AAExF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;;AAExB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC,IAAI;AACJ,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gBAAgB;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gBAAgB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;;AAEA;AACA,qDAAqD;;AAErD;;AAEA;AACA;AACA,kFAAkF;AAClF,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wEAAwE;AACxE;;AAEA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY,eAAe;AACjC;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,sDAAsD;AACtD,IAAI;AACJ,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc,EAAE;AAC9D,yBAAyB,+CAA+C;AACxE,EAAE,qCAAqC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE;;AAEF;AACA;AACA,UAAU,uEAAuE;AACjF;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,+EAA+E;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,8CAA8C,uCAAuC,EAAE;;AAEvF;AACA;AACA,UAAU,4DAA4D;AACtE;AACA,EAAE;;AAEF,yBAAyB,2EAA2E,oCAAoC,mBAAmB,GAAG,EAAE,OAAO,oCAAoC,8HAA8H,GAAG,EAAE,sBAAsB;;AAEpW;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,gDAAgD;AAChD;AACA;AACA,IAAI;AACJ;;AAEA;;;;AAIA;;AAEA;AACA;AACA,0CAA0C,iCAAiC;AAC3E;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA,sBAAsB,qDAAqD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,+BAA+B;AAC/B,gCAAgC;AAChC,gCAAgC;AAChC,4CAA4C;AAC5C,UAAU,iCAAiC;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD,uBAAuB,2CAA2C,WAAW,IAAI;AACjF,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA,MAAM;AACN;AACA,8CAA8C,iDAAiD;AAC/F,MAAM;AACN,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,kCAAkC;AACjH;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,iFAAiF,eAAe;AAChG;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU,uEAAuE;AACjF;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF,UAAU,oDAAoD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,2BAA2B,mBAAmB,EAAE;AAChD,2BAA2B,oBAAoB;AAC/C,EAAE;;AAEF,UAAU,0EAA0E;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,UAAU,sDAAsD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,UAAU,0DAA0D,kCAAkC,EAAE,GAAG;AAC3G;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,6BAA6B,YAAY,QAAQ;AACjD;AACA,kDAAkD;AAClD,EAAE,GAAG;AACL;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,YAAY,6BAA6B;AACzC;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA,+BAA+B,aAAa;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;AAMA,iCAAiC,aAAa;;AAE9C;AACA;AACA,sEAAsE,0CAA0C;AAChH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gBAAgB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,aAAa;;AAE9C;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,4CAA4C;AACtF,8CAA8C,4CAA4C;AAC1F,gDAAgD,4CAA4C;AAC5F,MAAM,qBAAqB,sCAAsC;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA,0CAA0C,kCAAkC;AAC5E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,eAAe,uFAAuF;AAC5G;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,+BAA+B;AAC/B,iCAAiC;AACjC,WAAW;AACX,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,kBAAkB,EAAE;;AAErE;AACA;AACA;AACA;AACA,IAAI,gBAAgB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,4DAA4D,eAAe;AAC3E;;AAEA;AACA,yDAAyD;AACzD,EAAE;;AAEF;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA,iBAAiB;AACjB,IAAI,EAAE;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS,EAAE;AAC1D,EAAE,gBAAgB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,IAAI,gBAAgB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,sDAAsD;AACtD;AACA,mDAAmD,iBAAiB,EAAE;AACtE;AACA;AACA,6EAA6E,iCAAiC,EAAE;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,yDAAyD;;AAErE;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC,MAAM;AACN;AACA;;AAEA;;;;;;;;;AASA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mCAAmC;AACnC,qCAAqC;AACrC,eAAe;AACf,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,+DAA+D;AACzF,EAAE;;AAEF,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,WAAW;AACX,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D,gEAAgE;AAC3H;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA,UAAU,+BAA+B;AACzC;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,iEAAiE;AAC3E;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM,YAAY;AAClB,IAAI;AACJ;;AAEA;AACA;AACA,UAAU,2EAA2E;AACrF;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,0BAA0B,4CAA4C;AACtE;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;;AAEA,4BAA4B,mBAAmB,aAAa;;AAE5D;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;AACA,eAAe;AACf,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,4CAA4C;AAC7E;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,gDAAgD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;;AAGA;AACA;AACA,UAAU,wEAAwE;AAClF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,IAAI;AACJ,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;;;AAG7B;AACA,mGAAmG;;AAEnG;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;;;AAGJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,0BAA0B;;AAE1B,2DAA2D;;AAE3D,sDAAsD;;AAEtD;AACA,4BAA4B;AAC5B,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,gBAAgB;;AAEhB;AACA;AACA,EAAE;;AAEF;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA,+BAA+B,QAAQ;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,yBAAyB;;AAEzB,sCAAsC;;AAEtC;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA,yBAAyB;;AAEzB,iCAAiC;;AAEjC;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;;AAGA;AACA;AACA;AACA,UAAU,gFAAgF;AAC1F;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,gDAAgD,SAAS,EAAE;AAC3D,IAAI;AACJ;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,uEAAuE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,uEAAuE;AACjF;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,iCAAiC,EAAE;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,0EAA0E;;AAE1E,wBAAwB,EAAE,UAAU,EAAE,UAAU,EAAE,KAAK;;AAEvD,sCAAsC;;AAEtC,oCAAoC;;AAEpC,+BAA+B;;AAE/B,0BAA0B;;AAE1B,yBAAyB,IAAI,IAAI;;AAEjC,sBAAsB;;AAEtB,uBAAuB,GAAG,GAAG;;AAE7B,0BAA0B;;AAE1B,0DAA0D;;AAE1D,+BAA+B;;AAE/B,uDAAuD;;AAEvD,0BAA0B;AAC1B;;AAEA,0BAA0B;;AAE1B,oCAAoC;;AAEpC,oCAAoC;;AAEpC,iFAAiF;;AAEjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;;AAGA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,UAAU,mEAAmE;AAC7E;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D,gEAAgE;AAC9H;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;;AAGN;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA,IAAI;AACJ,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA,UAAU,oEAAoE;AAC9E;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC,qEAAqE;;AAErE;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;;AAEzC;AACA,qCAAqC;;AAErC,gDAAgD;;AAEhD;AACA,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,+CAA+C;AACzD,iCAAiC;AACjC;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;;AAGA;AACA;AACA;AACA,UAAU,6EAA6E;AACvF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,UAAU,8CAA8C;AACxD;AACA,EAAE;;AAEF;AACA;AACA;;AAEA,sCAAsC,6BAA6B,0BAA0B,YAAY,EAAE;AAC3G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,GAAG,eAAe;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,+BAA+B;AAC7E;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,EAAE;AACZ,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;AAGZ;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;;AAGV;AACA;AACA,wDAAwD;;AAExD;AACA;AACA;AACA;AACA,yEAAyE;;AAEzE;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;;AAEA;AACA,UAAU;;;AAGV;AACA,4BAA4B;;AAE5B;;AAEA;;AAEA,oDAAoD;;;AAGpD;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;;AAEA;;AAEA,6DAA6D;;;AAG7D;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;AAG3B;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,wBAAwB;;;AAGxB;AACA;AACA,6EAA6E;;AAE7E;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA,2EAA2E;;AAE3E;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;AAG3B;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,wBAAwB;;;AAGxB;AACA;AACA,+BAA+B;;AAE/B,gCAAgC;;AAEhC;AACA;AACA,oKAAoK;;AAEpK;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,wBAAwB;;;AAGxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA,QAAQ;AACR;;AAEA;;AAEA;;AAEA;;AAEA;AACA,QAAQ;AACR;;AAEA;;AAEA;;AAEA;;AAEA;AACA,QAAQ;AACR;;AAEA;;AAEA;;AAEA;;AAEA;AACA,QAAQ;AACR;;AAEA;;AAEA;;AAEA;;AAEA;AACA,QAAQ;AACR;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;;AAEF,gDAAgD,eAAe,EAAE;;AAEjE;AACA;AACA,UAAU,8DAA8D;AACxE;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,MAAM;AACN;AACA,qCAAqC,cAAc,OAAO;AAC1D,sCAAsC,cAAc,OAAO;AAC3D;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qCAAqC,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,UAAU,kDAAkD;AAC5D;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA,uDAAuD;;AAEvD,+ZAA+Z;;AAE/Z;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;;AAEA;AACA;AACA,6BAA6B;;;AAG7B,6MAA6M;;AAE7M;AACA,+DAA+D;;AAE/D;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA,iEAAiE;;AAEjE;AACA,uEAAuE;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA,0DAA0D;;AAE1D;AACA;AACA;AACA,wBAAwB;;AAExB;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,sJAAsJ;AACtJ,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2HAA2H;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;;AAE3D;AACA,MAAM;AACN;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,sGAAsG,uCAAuC,+BAA+B,yFAAyF,OAAO,KAAK;AACjR,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,2FAA2F,aAAa;AACxG;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,6CAA6C;;AAE7C,qCAAqC;;AAErC;AACA,8EAA8E,eAAe;AAC7F;AACA;;AAEA;AACA;;AAEA;AACA,IAAI,IAAI;AACR;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sFAAsF;AACtF;AACA,6CAA6C;;AAE7C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;;AAEA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uDAAuD;;AAEvD;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA,YAAY;AACZ;AACA,YAAY;;;AAGZ;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,gEAAgE;AAC1H;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM,IAAI;AACV,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM,OAAO;;AAEb;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA,yBAAyB;;AAEzB,gDAAgD;;AAEhD;AACA,gCAAgC;;AAEhC;AACA;AACA,iKAAiK;;AAEjK;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA,0DAA0D;;AAE1D;AACA,4BAA4B;;AAE5B;AACA,yDAAyD;;AAEzD;AACA;AACA,yCAAyC;;AAEzC;AACA,YAAY;;;AAGZ;AACA;;AAEA,wCAAwC;;;AAGxC;AACA,6BAA6B;AAC7B,cAAc;AACd;AACA;AACA,YAAY;AACZ,UAAU;;;AAGV;AACA,QAAQ;AACR;;;AAGA,yDAAyD;;AAEzD;AACA,4DAA4D;;AAE5D,gCAAgC;;AAEhC,uCAAuC,OAAO;AAC9C;AACA;;AAEA,kCAAkC;;AAElC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,gGAAgG;;AAEhG,oBAAoB;;AAEpB;;AAEA;AACA;AACA,sEAAsE;AACtE;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,wEAAwE;AACxE;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE,EAAE;;AAEJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE,IAAI;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,oFAAoF;AAC9F;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,UAAU,yEAAyE;AACnF;AACA,EAAE;;AAEF;AACA;AACA,UAAU,yEAAyE;AACnF;AACA,EAAE;;AAEF;;;AAGA,gDAAgD,qCAAqC,EAAE;AACvF;;AAEA;AACA;AACA,UAAU,qEAAqE;AAC/E;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,UAAU,mDAAmD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,6CAA6C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEtV,iCAAiC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,iDAAiD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,2CAA2C,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAEzgB;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA,MAAM;AACN,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,EAAE;;AAEV;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,wCAAwC;;AAExC,kDAAkD,QAAQ;AAC1D;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;;;AAGA,6CAA6C;;AAE7C,wCAAwC,SAAS;AACjD;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC,2BAA2B;;AAE3B;AACA,MAAM;;;AAGN;AACA,IAAI;AACJ;AACA;AACA,2BAA2B;;AAE3B;AACA,gBAAgB;;AAEhB;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,2BAA2B;;AAE3B,8BAA8B,QAAQ;AACtC;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,6BAA6B;;AAE7B;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,0EAA0E,aAAa;AACvF;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,iDAAiD;AAC3D;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;;AAEF;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB,sCAAsC;;AAEtC;AACA,8EAA8E;;AAE9E,iDAAiD;;AAEjD;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA,wCAAwC,sCAAsC;AAC9E;AACA;AACA,QAAQ;AACR,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;;AAEA;AACA;AACA,uCAAuC,QAAQ;AAC/C;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA,oDAAoD;;AAEpD,8BAA8B,QAAQ;AACtC;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,yBAAyB;AAC3D;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA,8CAA8C,QAAQ;AACtD;AACA,QAAQ;AACR;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,MAAM;AACN;AACA;AACA,QAAQ;AACR,MAAM;;;AAGN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE,QAAQ;AACV,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,gFAAgF;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAA2C;AAC/D,MAAM;AACN,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;;;AAGR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;AACA;AACA,MAAM;;;AAGN;AACA,IAAI;AACJ;AACA,wBAAwB;;AAExB,+CAA+C;;AAE/C;AACA;AACA;AACA,MAAM,EAAE;;AAER;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;;;AAGR;AACA,MAAM;;;AAGN;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,oCAAoC;;AAEpC;AACA,wBAAwB;;AAExB,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;;AAGA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;;AAER;AACA;AACA,QAAQ;;AAER;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,KAAK;AAC9C;AACA;AACA,wCAAwC;AACxC;;AAEA,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;;AAEA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA,0DAA0D;;;AAG1D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,yCAAyC;AACzC;;AAEA;;AAEA;AACA,8BAA8B;AAC9B,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;;;AAGA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,6CAA6C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEtV,mCAAmC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,iDAAiD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,2CAA2C,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAE3gB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kFAAkF;;AAElF,4BAA4B;;AAE5B,6DAA6D;;AAE7D,iFAAiF;;AAEjF;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA,kEAAkE;;AAElE,yBAAyB;;AAEzB;AACA;AACA,yBAAyB;;AAEzB,2BAA2B;;AAE3B;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA,sCAAsC;;AAEtC;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;;AAGA;AACA,2EAA2E;;AAE3E,6BAA6B;;AAE7B;AACA,mCAAmC;;;AAGnC;;AAEA;;AAEA;AACA,QAAQ;AACR;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;AACV;;;AAGA;AACA,gEAAgE;;AAEhE,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,oDAAoD;;AAEpD,gDAAgD,SAAS;AACzD;AACA,sCAAsC;;AAEtC;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;;AAEA,gDAAgD,SAAS;AACzD;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE,EAAE;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA,+CAA+C;AAC/C;AACA;;;AAGA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;AAEN;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA,kGAAkG;;AAElG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mEAAmE;;AAEnE,gCAAgC;;;AAGhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA,QAAQ;AACR;;AAEA;AACA;AACA,uCAAuC;;AAEvC;AACA,qCAAqC;;AAErC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR,sCAAsC;AACtC;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,4BAA4B;;AAE5B,oDAAoD;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM,EAAE;;AAER;;AAEA;AACA,IAAI;AACJ;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM,EAAE;;AAER;;AAEA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;;AAE5C,2BAA2B;;AAE3B,0BAA0B;;AAE1B;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA,YAAY;;;AAGZ;AACA;AACA,YAAY;;;AAGZ;AACA;;AAEA;AACA,QAAQ;;;AAGR;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,mCAAmC;;AAEnC,2CAA2C,QAAQ;AACnD;AACA;AACA,QAAQ;;;AAGR;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA,wDAAwD;;AAExD;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA,QAAQ;;;AAGR;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,EAAE;;AAEV;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,+FAA+F;;AAE/F;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC,mCAAmC;AACnC;;AAEA,iEAAiE;;AAEjE,6DAA6D;;AAE7D;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,EAAE;;AAEV;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,0FAA0F;;AAE1F;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA,6CAA6C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEtV,mCAAmC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,iDAAiD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,2CAA2C,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAE3gB;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA,+CAA+C;AAC/C;;AAEA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA,QAAQ;;;AAGR,iDAAiD;;AAEjD;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;AACD;;AAEe,sEAAO,EAAC;;;;;;;;;;;;;;ACh9VvB;AAAA;;AAEe,8EAAe,oEAAoE,uBAAuB,0CAA0C,gGAAU,GAAG,gBAAgB,OAAO,OAAO,qCAAqC,aAAa,0CAA0C,aAAa,wCAAwC,WAAW,OAAO,WAAW,iBAAiB,EAAE;AAC/Y,wBAAwB,sBAAsB,mBAAmB,aAAa,aAAa,iDAAiD,qBAAqB,OAAC,QAAQ,wBAAwB,qDAAqD,uCAAuC,iBAAiB,YAAY,GAAG,uCAAuC,oBAAoB,mBAAmB,6BAA6B,sBAAsB,6DAA6D,cAAc,aAAa,WAAW,WAAW;AAC7iB;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK,GAAG,yRAAyR;AACjS;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,uBAAuB,eAAe;AACtC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK,IAAI;AACT;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B;AAC1B,gCAAgC;AAChC,sCAAsC;AACtC,4BAA4B;AAC5B,kCAAkC;AAClC,mCAAmC;AACnC,4BAA4B;AAC5B,8BAA8B;AAC9B,gCAAgC;AAChC,mCAAmC;AACnC,+BAA+B;AAC/B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,6BAA6B;AAC7B,mCAAmC;AACnC,+BAA+B;AAC/B,oCAAoC;AACpC,0CAA0C;AAC1C,2CAA2C;AAC3C,mCAAmC;AACnC,yCAAyC,KAAK;AAC9C,oCAAoC;AACpC,0CAA0C,KAAK;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,6CAA6C,gBAAgB;AAC7D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4DAA4D,gBAAgB;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD,gBAAgB;;AAEtE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,gBAAgB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,sDAAsD,gBAAgB;AACtE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,EAAE;AACrC;;AAEA;AACA;;AAEA;;AAEA,iDAAiD,gBAAgB;AACjE;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA,aAAa;AACb;;AAEA,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,0CAA0C,8BAA8B;AACxE;;AAEA;AACA;;AAEA,KAAK,GAAG,2FAA2F;AACnG;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA,KAAK,IAAI;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,6CAA6C,EAAE;AAC/C;AACA,4CAA4C,EAAE,eAAe,EAAE,YAAY;;;AAG3E,4BAA4B,4CAA4C;;AAExE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,UAAU;AAC1C,gCAAgC,UAAU;AAC1C,gCAAgC,UAAU;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,yDAAyD,qBAAqB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD;AACnD;;AAEA;;AAEA,qDAAqD,kBAAkB;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,kBAAkB;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,kBAAkB;AAC1E;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;;AAEA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA,aAAa;AACb;AACA;;AAEA,oBAAoB,eAAe;AACnC;;AAEA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa;AACb;AACA;;AAEA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;;AAEA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA,SAAS,yBAAyB;AAClC,4BAA4B,IAAI;AAChC;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA,kFAAkF;AAClF,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;AACA,cAAc,+CAA+C;AAC7D;;AAEA;AACA,gBAAgB,+CAA+C;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb,mCAAmC;AACnC;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA,aAAa;AACb,kEAAkE,sBAAsB;AACxF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf,yEAAyE;;AAEzE,eAAe;AACf;AACA;AACA,4BAA4B;AAC5B;;AAEA,aAAa;AACb,oEAAoE;;AAEpE,aAAa;AACb;AACA;AACA,0BAA0B;AAC1B;;AAEA,WAAW;AACX,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,cAAc,+CAA+C;AAC7D;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA,SAAS;AACT;;AAEA,SAAS;AACT;;AAEA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;;AAEA,0EAA0E,0BAA0B;AACpG;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,qFAAqF;AACrF;;AAEA,8CAA8C;AAC9C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,+CAA+C;AACjE;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,sDAAsD,gBAAgB;AACtE;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD,8BAA8B;AACrF;;;AAGA;AACA,0CAA0C,8BAA8B;AACxE;;;AAGA;AACA;AACA;AACA;;AAEA,KAAK,GAAG,wGAAwG;AAChH;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;;;AAGA;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB,qBAAqB;AACrB;AACA,SAAS;;AAET;AACA;AACA;;AAEA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,iCAAiC,EAAE;AACjF;AACA;;AAEA,0CAA0C,6BAA6B,EAAE;AACzE;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;;AAGA;;AAEA,KAAK,GAAG,gDAAgD;AACxD;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,+BAA+B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,uHAAuH;AAC/H;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,8JAA8J;AACtK;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,0EAA0E;AAClF;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,mHAAmH;AAC3H;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,0DAA0D,aAAa;AACvE,kEAAkE,aAAa;AAC/E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK,GAAG,mBAAmB;AAC3B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO,aAAa;;AAEpB;;;AAGA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA,qBAAqB,WAAW;AAChC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kCAAkC,EAAE;AAC5E,wCAAwC,kCAAkC,EAAE;AAC5E,wCAAwC,kCAAkC;AAC1E,SAAS;AACT;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA,SAAS;AACT;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gCAAgC;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6EAA6E,EAAE;AACjH,iCAAiC,2EAA2E,EAAE;AAC9G,mCAAmC,yBAAyB,EAAE;AAC9D;AACA,uCAAuC,2GAA2G;AAClJ,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gCAAgC;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,yCAAyC,cAAc;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,cAAc;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,mBAAmB;AAC3B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,mBAAmB;AAC3B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,mBAAmB;AAC3B;;AAEA;;AAEA;AACA;AACA,oCAAoC,kCAAkC;AACtE,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY,EAAE;AAChD,kCAAkC,eAAe,EAAE;AACnD,kCAAkC,eAAe,EAAE;AACnD,kCAAkC,eAAe;AACjD,SAAS;AACT;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+CAA+C,gBAAgB;AAC/D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,+CAA+C,gBAAgB;AAC/D;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,+CAA+C,gBAAgB;AAC/D;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;AACA,oCAAoC,kCAAkC;AACtE,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;AACA,oCAAoC,kCAAkC;AACtE,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;AAEA;;AAEA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;;AAEA,wBAAwB;AACxB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,KAAK,GAAG,gBAAgB;AACxB;;;AAGA;;;AAGA;;AAEA,KAAK,GAAG,wBAAwB;AAChC,GAAG,IAAI;AACP,CAAC,CAAC,EAAC","file":"aaCustomElements.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"executableHTML\"] = factory();\n\telse\n\t\troot[\"executableHTML\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import BaseElement from '../aa-baseElement/baseElement.js';\nexport default class AAAffectGrid extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n\n            'top-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'bottom-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'left-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'center-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'right-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'top-left-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'top-right-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'bottom-left-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'bottom-right-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'left-top-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'left-bottom-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'right-top-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            'right-bottom-label': {\n                type: String,\n                userDefined: true,\n                value: ''\n            },\n\n            rows: {\n                type: Number,\n                userDefined: true,\n                value: 11\n            },\n\n            columns: {\n                type: Number,\n                userDefined: true,\n                value: 11\n            },\n\n            value:{\n                type: Array,\n\n            }\n\n        }\n    }\n\n    static get acceptsElements() {\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAAffectGrid.properties);\n    }\n\n\n\n    get x(){\n        let val = this.getAttribute(\"value\");\n        if(!val) return null;\n        return parseInt(val.split(\",\")[0]);\n    }\n\n    get y(){\n        let val = this.getAttribute(\"value\");\n        if(!val) return null;\n        return parseInt(val.split(\",\")[1]);\n    }\n\n    get value() {\n        let val = this.getAttribute(\"value\");\n        if(!val) return null\n\n        let s = val.split(\",\");\n        return [ parseInt(s[0]), parseInt(s[1])];\n    }\n    set value(val) {\n        this.setAttribute('value', val);\n\n    }\n\n    get minLabel() {\n        return this.getAttribute('min-label');\n    }\n\n    get maxLabel() {\n        return this.getAttribute('max-label');\n    }\n\n    set minLabel(val) {\n        this.setAttribute('min-label', val);\n    }\n\n    set maxLabel(val) {\n        this.setAttribute('max-label', val);\n    }\n\n    set min(val) {\n        this.setAttribute('min', val);\n    }\n\n    set max(val) {\n        this.setAttribute('max', val);\n    }\n\n\n    constructor() {\n        super();\n\n        if(this.topLeftLabel === null) this.topLeftLabel='';\n        if(this.topLabel === null) this.topLabel='';\n        if(this.topRightLabel === null) this.topRightLabel='';\n        if(this.leftTopLabel === null) this.leftTopLabel='';\n        if(this.leftLabel === null) this.leftLabel='';\n        if(this.leftBottomLabel === null) this.leftBottomLabel='';\n        if(this.rightTopLabel === null) this.rightTopLabel='';\n        if(this.rightLabel === null) this.rightLabel='';\n        if(this.rightBottomLabel === null) this.rightBottomLabel='';\n        if(this.bottomLeftLabel === null) this.bottomLeftLabel='';\n        if(this.bottomLabel === null) this.bottomLabel='';\n        if(this.bottomRightLabel === null) this.bottomRightLabel='';\n        this.root = this.attachShadow({ mode: 'open' });\n\n        \n        \n    }\n\n\n\n    connectedCallback() {\n        super.connectedCallback();\n\n\n        this.root.innerHTML = this.css + this.html;\n\n        // this.topLeft = this.root.querySelector('.top-left');\n       \n        // this.topRight = this.root.querySelector('.top-right');\n        // this.leftMargin =  this.root.querySelector('.left-margin');\n        // this.rightMargin = this.root.querySelector('.right-margin');\n        \n\n        \n\n        this.grid = this.root.querySelector('.grid');\n        this.grid.addEventListener(\"mousedown\", (e)=>{\n            let currentValue = this.value;\n\n            let cell = e.path[0];\n            this.value = [cell.dataset.x, cell.dataset.y];\n            \n            \n            if(this.selectedCell){\n                this.selectedCell.classList.remove('selected');\n            }\n            this.selectedCell = cell;\n            this.selectedCell.classList.add('selected');\n\n            let newValue = this.value;\n            console.log(currentValue, newValue);\n\n            if(!currentValue) this.dispatchEvent(new CustomEvent(\"change\", {bubbles:true}))\n            else{\n                if((currentValue[0]!=newValue[0])||(currentValue[1]!=newValue[1])){\n                    this.dispatchEvent(new CustomEvent(\"change\", {bubbles:true}));\n                }\n            }\n            \n\n        });\n\n        this.totalContainer = this.root.querySelector('.total-container');\n\n        this.totalContainer.style.height = window.getComputedStyle(this.totalContainer).width;\n        this.root.querySelector(\".leftLabels\").style.width = window.getComputedStyle(this.grid).height;\n        this.root.querySelector(\".rightLabels\").style.width = window.getComputedStyle(this.grid).height;\n        \n        //register a resize observer for top container\n        if(ResizeObserver){\n            new ResizeObserver( ()=>{\n\n                this.totalContainer.style.height = window.getComputedStyle(this.totalContainer).width;\n                this.root.querySelector(\".leftLabels\").style.width = window.getComputedStyle(this.grid).height;\n                this.root.querySelector(\".rightLabels\").style.width = window.getComputedStyle(this.grid).height;\n\n            }).observe(this.root.querySelector('.top-label'));\n        }\n        // else{\n        //     console.warn(\"ResizeObserver is not defined here\");\n        // }\n\n       \n\n\n        \n    }\n\n    get css() {\n        return html`<style>\n\n        \n        :host{\n            display:block;\n            font-family: Roboto, Noto, sans-serif;\n            \n        }\n        .top-section{\n            height:40px;\n            width:100%;\n         \n        }\n\n        .top-left{\n            text-align:left;\n        }\n\n        .top-label{\n            text-align:center;\n        }\n        .top-right{\n            text-align:right;\n        }\n\n        .bottom-left{\n            text-align:left;\n        }\n        .bottom{\n            text-align:center;\n        }\n        .bottom-right{\n            text-align:right;\n        }\n\n\n        .top-left-corner{\n            width:40px;\n            height:40px;\n        }\n        .top-right-corner{\n            width:40px;\n            height:40px;\n        }\n\n        .bottom-left-corner{\n            width:40px;\n            height:40px;\n        }\n        .bottom-right-corner{\n            width:40px;\n            height:40px;\n        }\n\n\n        .middle-section{\n         \n            flex-grow:2;\n        }\n\n\n        \n        .bottom-section{\n           \n            height:40px;\n            width:100%;\n        }\n        .left-margin{\n            width:40px;\n            height:100%;\n        }\n        .right-margin{\n            width:40px;\n            height:100%;\n        }\n\n        .grid{\n            display:grid;\n            grid-template-columns: repeat(${this.columns}, ${100/this.columns}%);\n            \n            flex-grow:2;\n            width:100%;\n            height:100%;\n        }\n        .cell{\n            border:solid thin;\n            /* transition:background-color 0.2s; */\n        }\n\n        .cell.top{\n            border-top:solid 2px;\n        }\n\n        .cell.bottom{\n            border-bottom:solid 2px;\n        }\n\n        .cell.left{\n            border-left:solid 2px;\n        }\n\n        .cell.right{\n            border-right: solid 2px;\n        }\n        .cell.selected{\n            background-color: #3367D6;\n            \n        }\n\n\n        .label{\n            flex-grow:1\n        }\n        </style>\n        `;\n    }\n\n    get html() {\n        \n\n        let grid ='';\n        for(let j=0; j<this.rows; j++){\n            for(let i=0; i<this.columns; i++){\n                grid+=html`<div class=\"cell  ${j==0?'top':''} ${j==this.rows-1?`bottom`:''}  ${i==0?`left`:''}  ${i==this.columns-1?`right`:''}\" data-x=\"${ i+1 - Math.round(this.columns/2) }\" data-y=\"${Math.round(this.rows/2) - j - 1}\">\n            </div>`;\n            }\n        }\n\n        let source = html`\n            <div class=\"total-container\" style=\"position:relative; display:flex; flex-direction:column;\">\n                \n                <div class=\"top-section\" style=\"display:flex; flex-direction:row\">\n                    <div class=\"top-left-corner\"></div>    \n                    <div style=\"width:100%; display:flex; flex-direction:row; justify-content:space-between\">\n                        <div class=\"top-left label\" style=\"width:33.3%\">${this.topLeftLabel}</div>\n                        <div class=\"top-label\" style=\"width:33.3%; text-align:center\">${this.topLabel}</div>\n                        <div class=\"top-right label\" style=\"width:33.3%\">${this.topRightLabel}</div>\n                    </div>\n                    <div class=\"top-right-corner\"></div>    \n                </div>\n            \n                \n                <div class=\"middle-section\" style=\"display:flex; flex-direction:row\">\n                    <div class=\"left-margin\" style=\"display:flex; flex-direction:column;\"></div>\n                    <div class=\"grid\" style=\"padding:0px\">${grid}</div>\n                    <div class=\"right-margin\" style=\"display:flex; flex-direction:column\"></div>\n                </div>\n                \n\n                <div class=\"bottom-section\" style=\"display:flex; flex-direction:row;margin-top:10px\">\n                <div class=\"bottom-left-corner\" ></div>    \n                <div style=\"width:100%; display:flex; flex-direction:row; justify-content:space-between\">\n                    <div class=\"bottom-left label\" style=\"width:33.3%\">${this.bottomLeftLabel}</div>\n                    <div class=\"bottom label\" style=\"width:33.3%\">${this.bottomLabel}</div>\n                    <div class=\"bottom-right label\" style=\"width:33.3%\">${this.bottomRightLabel}</div>\n                \n                </div>\n                    <div class=\"bottom-right-corner\"></div>    \n                \n                </div>\n\n                <div class=\"leftLabels\" style=\"position:absolute; bottom:30px; left:0px;  display:flex; flex-direction:row; justify-content:space-between; transform:rotate(-90deg); transform-origin:top left;\">\n                    <div style=\"width:33.3%; text-align:left; \">${this.leftBottomLabel}</div>    \n                    <div style=\"width:33.3%; text-align:center; flex-grow:2\">${this.leftLabel}</div>    \n                    <div style=\"width:33.3%;text-align:right\">${this.leftTopLabel}</div>    \n                </div>\n\n                <div class=\"rightLabels\" style=\"position:absolute; bottom:50px; right:20px; display:flex; flex-direction:row; justify-content:space-between; transform:rotate(90deg); transform-origin:bottom right;\">\n                    <div style=\"width:33.3%; text-align:left\">${this.rightTopLabel}</div>    \n                    <div style=\"width:33.3%; text-align:center; flex-grow:2\">${this.rightLabel}</div>    \n                    <div style=\"width:33.3%; text-align:right\">${this.rightBottomLabel}</div>    \n                </div>\n\n            </div>\n        \n        `;\n               \n        return source;\n    }\n\n\n}\n\nBaseElement.registerAAElement('aa-affect-grid', AAAffectGrid);","import '../../lib/yaml/js-yaml.js';\nimport * as html2jsl from '../../lib/html2jsl/html2jsl.js';\nimport { mySVG } from '../../lib/mySVG/mySVG.js';\n\nvar html = function (txt, ...val) {\n\n    let result = txt[0];\n    for (let i = 0; i < val.length; i++) {\n\n        result += val[i];\n        result += txt[i + 1];\n    }\n    return result;\n}\n\nif (window) window.html = html;\n\nexport default class BaseElement extends HTMLElement {\n\n\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n\n            'diagram': {\n                type: Boolean,\n                value: false,\n                userDefined: true\n            },\n        }\n    }\n    static registerAAElement(name, elem) {\n        if (!customElements.get(name)) {\n            window.AANodeNames = window.AANodeNames || [];\n            window.AANodeNames.push(name.toUpperCase());\n            customElements.define(name, elem);\n        }\n    }\n\n    static isAAElement(node) {\n        if (AANodeNames.indexOf(node.nodeName) != -1) {\n            return true;\n        }\n        return false;\n    }\n\n    static createFragmentForNode(node) {\n        let fragment = document.createDocumentFragment();\n        for (let i = 0; i < node.childNodes.length; i++) {\n            fragment.append(node.childNodes[i].cloneNode(true));\n            // fragment.append(BaseElement.copy(node.childNodes[i])\n        }\n        return fragment;\n    }\n\n    static createHolderForNode(o) {\n        let node = o.cloneNode(false);\n        node.innerFragment = BaseElement.createFragmentForNode(o);\n        return node;\n    }\n\n    static scanAndReplace(node) {\n        if (node.nodeName === \"TEMPLATE\") {\n            BaseElement.scanAndReplace(node.content);\n        }\n        else if (BaseElement.isAAElement(node)) {\n            // if(node.innerFragment) { return };\n            let holder = BaseElement.createHolderForNode(node);\n            node.replaceWith(holder);\n            node.innerFragment = holder.innerFragment;\n\n        } else\n            for (let i = 0; i < node.childNodes.length; i++) {\n                BaseElement.scanAndReplace(node.childNodes[i]);\n            }\n    }\n\n    constructor() {\n        super();\n        // console.log(this.nodeName+\"#\"+this.id, \"created\");\n        this._props = this.makePropertiesFromAttributes();\n\n    }\n\n    connectedCallback() {\n\n\n        // console.log(this.id, \" connected\");\n        this._attachedTimestamp = new Date().getTime();\n        this._debug = (this.debug === true) || (this.debug === null);\n        if (this.innerFragment) {\n\n            // I have commented BaseElement.scanAndReplace out because a shallow copy and an innerFragment\n            // is already created by BaseElement.copy for childNodes of this.innerFrament\n            // as they are appended to this element.\n            // BaseElement.scanAndReplace(this.innerFragment);\n            for (let i = 0; i < this.innerFragment.childNodes.length; i++) {\n                this.appendChild(BaseElement.copy(this.innerFragment.childNodes[i]));\n            }\n\n        }\n\n        this.setAttributeDefaultValues();\n    }\n\n    getMemory() {\n        let el = this;\n        while (el.parentNode != null) {\n            if (el._mem) return el._mem;\n            el = el.parentNode;\n        }\n        return null;\n    }\n\n    /**\n     * Properties are the member variables of the HTMLElement object.\n     * Attributes are the html tag's attributes.\n     * By convention, properties are in camelCase, e.g., someMembVariable\n     * while the corresponding attribute whould be hyphenated, e.g., some-member-variable.\n     * The purpose of this function is, based on the hyphenated attributes \n     * of the element, to generate corresponding camelCase properties\n     * \n     * Attribute names are provided by observedAttributes of the HTMLElement object,\n     * however objects that inherit from baseElement can also provide a more\n     * meaningful declaration, including datatype and default value, in \n     * a static get properties function, like so:\n     * \n     *  static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:true\n            },\n            \"submit-button-text\":{\n                type:String,\n                value:\"submit\",\n                userDefined:true\n            },\n\n    \n     * This function also generates corresponding getter and setter functions\n     * for each property, so that properties and attributes always remain in sync\n     * with each other \n     */\n    makePropertiesFromAttributes() {\n\n        let ElementClass = customElements.get(this.tagName.toLowerCase());\n\n        let attr = ElementClass.observedAttributes;\n        if (!attr) return null;\n        let props = {};\n        for (let i = 0; i < attr.length; i++) {\n            let prop = this.toCamelCase(attr[i]);\n            props[prop] = attr[i];\n\n\n            if (typeof this[prop] != 'undefined') {\n                continue;\n            } else {\n\n                Object.defineProperty(this, prop, {\n                    get: () => {\n\n                        let result = this.getAttribute(attr[i]);\n                        if (result === 'true') { return true; }\n                        else if (result === 'false') { return false; }\n                        else { return result; }\n                    },\n                    set: (value) => {\n                        this.setAttribute(attr[i], value);\n                    }\n                });\n            }\n        }\n        return props;\n    }\n\n    toCamelCase(str) {\n        let words = str.split('-');\n        let result = words[0];\n        for (let i = 1; i < words.length; i++) {\n            result += words[i][0].toUpperCase() + words[i].substr(1);\n        }\n        return result;\n    }\n    toHyphenated(str) {\n        let result = '';\n        for (let i = 0; i < str.length; i++) {\n            let letter = str[i];\n            if (letter.toLowerCase() !== letter) {\n                // letter is uppercase\n                result += `-${letter.toLowerCase()}`;\n            } else {\n                result += letter;\n            }\n        }\n        return result;\n    }\n\n    setAttributeDefaultValues() {\n        let p = this.constructor.properties;\n        if (p) {\n            let keys = Object.keys(p);\n            for (let i = 0; i < keys.length; i++) {\n                let prop = this.toCamelCase(keys[i]);\n                if ((typeof this[prop] === 'undefined') || (this[prop] === null) || (this[prop] === '')) {\n                    if (p[keys[i]].type === Boolean) {\n                        if (this.getAttribute(keys[i]) === '') {\n                            this.setAttribute(keys[i], true);\n\n                        } else if (this.getAttribute(keys[i]) === 'true') {\n                            this.setAttribute(keys[i], true);\n\n                        } else if (this.getAttribute(keys[i]) === 'false') {\n                            this.setAttribute(keys[i], false);\n\n                        } else if (this.getAttribute(keys[i]) === null) {\n                            this.setAttribute(keys[i], p[keys[i]].value);\n                        }\n                    }\n                    else {\n                        let val = this.getAttribute(keys[i]) || (p[keys[i]].value || null);\n\n                        if (val) this.setAttribute(keys[i], val);\n                        if (val === false) this.setAttribute(keys[i], val);\n                    }\n                }\n            }\n        }\n\n    }\n\n    static copy(node) {\n        let nodeCopy;\n        if (BaseElement.isAAElement(node)) {\n\n            if (node.innerFragment) {\n                nodeCopy = node.cloneNode();\n                nodeCopy.innerFragment = BaseElement.createFragmentForNode(node.innerFragment);\n            } else {\n                nodeCopy = node.cloneNode();\n                nodeCopy.innerFragment = BaseElement.createFragmentForNode(node);\n            }\n        }\n        else {\n            nodeCopy = node.cloneNode(true);\n        }\n        return nodeCopy;\n    }\n\n    getAttributes() {\n        let result = {};\n        let attributes = Object.keys(this.constructor.properties);\n        for (let i = 0; i < attributes.length; i++) {\n            if (!this.constructor.properties[attributes[i]].userDefined) {\n                // users should need not be concerned\n                continue;\n            }\n            if ((typeof this.getAttribute(attributes[i]) !== 'undefined') && (this.getAttribute(attributes[i]) !== 'undefined')) {\n                if (this.constructor.properties[attributes[i]].value == this.getAttribute(attributes[i])) {\n                    // value is default value, no need to be part of specification\n                    continue;\n                }\n                result[attributes[i]] = this.getAttribute(attributes[i]);\n            }\n        }\n        return result;\n    }\n\n    toJSON() {\n        let result = {};\n        result[this.tagName.toLowerCase()] = this.getAttributes()\n        return result;\n    }\n\n    static nodeToJSON(node) {\n\n        if ((node.nodeType === document.TEXT_NODE) || (node.nodeType === document.COMMENT_NODE)) {\n            let result = {};\n            let text = node.textContent.replace(/\\n/g, ' ').replace(/\\t/g, ' ').replace(/\\s\\s+/g, ' ').trim();\n            if (text !== '') {\n                result[node.nodeName] = text;\n                return result;\n            }\n            else { return null; }\n        }\n        else if (node.toJSON) {\n            return node.toJSON();\n        }\n        else try {\n\n            let result = {};\n\n            let attrs = node.getAttributeNames();\n            let attrObj = {};\n            for (let i = 0; i < attrs.length; i++) {\n                attrObj[attrs[i]] = node.getAttribute(attrs[i]);\n            }\n            let childNodes = [];\n            for (let i = 0; i < node.childNodes.length; i++) {\n                let el = BaseElement.nodeToJSON(node.childNodes[i]);\n                if (el) {\n                    childNodes.push(BaseElement.nodeToJSON(node.childNodes[i]));\n                }\n            }\n            result[node.tagName] = attrObj;\n            result[node.tagName].childNodes = childNodes;\n\n            return result;\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    toYAML() {\n        return jsyaml.dump(this.toJSON())\n    }\n\n\n    toJSL() {\n        return html2jsl.nodeToJSL(this);\n    }\n\n\n\n    produceDiagram() {\n        if (!this.root) {\n            this.root = this.attachShadow({ mode: 'open' });\n        }\n        this.root.innerHTML = '<div id=\"svgContainer\" ></div>'\n        let div = this.root.childNodes[0];\n        let diagram = new mySVG();\n        let svg = diagram.render(this);\n\n        let button = document.createElement('paper-button');\n        button.innerHTML = \"download\";\n        button.raised = true;\n        button.style.backgroundColor = \"#0d47a1\";\n        button.style.color = \"white\";\n        button.classList.add('indigo');\n        div.appendChild(svg);\n        div.appendChild(button);\n        // div.appendChild(diagram.renderKey());\n\n        let filename = '';\n        if (this.name) {\n            filename = this.name + \".\" + this.nodeName.toLowerCase() + \".svg\";\n        } else {\n            filename = this.nodeName.toLowerCase() + \".svg\";\n        }\n        button.addEventListener(\"click\", () => {\n            diagram.download(filename);\n        })\n\n    }\n\n\n\n\n\n    static getDomPathAsName(el) {\n        var stack = [];\n       \n        while ((el.nodeName !== \"AA-SESSION\") && (el.parentNode != null)) {\n\n            var sibCount = 0;\n            var sibIndex = 0;\n            for (var i = 0; i < el.parentNode.childNodes.length; i++) {\n                var sib = el.parentNode.childNodes[i];\n                if (sib.nodeName == el.nodeName) {\n                    if (sib === el) {\n                        sibIndex = sibCount;\n                    }\n                    sibCount++;\n                }\n            }\n            if (!BaseElement.isAAElement(el)) {\n                el = el.parentNode;\n                continue;\n\n            }\n            if (el.hasAttribute('name') && el.name != '') {\n                stack.unshift(el.name);\n            } else if (el.hasAttribute('id') && el.id != '') {\n                stack.unshift(el.nodeName.toLowerCase() + '#' + el.id);\n            } else if (sibCount > 1) {\n                stack.unshift(el.nodeName.toLowerCase() + ':eq(' + sibIndex + ')');\n            } else {\n                stack.unshift(el.nodeName.toLowerCase());\n            }\n            el = el.parentNode;\n        }\n        if (el.nodeName === \"AA-SESSION\") {\n            if (el.hasAttribute('name') && el.name != '') {\n                stack.unshift(el.name);\n            } else if (el.hasAttribute('id') && el.id != '') {\n                stack.unshift(el.nodeName.toLowerCase() + '#' + el.id);\n            } else if (sibCount > 1) {\n                stack.unshift(el.nodeName.toLowerCase() + ':eq(' + sibIndex + ')');\n            } else {\n                stack.unshift(el.nodeName.toLowerCase());\n            }\n        }\n        let name = \"\";\n        for (let i = 0; i < stack.length - 1; i++) {\n            name += stack[i] + \".\";\n        }\n        name += stack[stack.length - 1];\n\n        // console.log(stack, name)\n        return name; // removes the html element\n    }\n\n    static getVariableName(el) {\n        if (el.name) {\n            return el.name;\n        } else {\n            return BaseElement.getDomPathAsName(el);\n        }\n    }\n\n\n    _dispatchDebugEvent(detail) {\n        if (this.debug) {\n            this.dispatchEvent(new CustomEvent('debugEvent', { detail, bubbles: true }));\n        }\n    }\n\n\n\n    _dispatchEndEvent(detail) {\n        //  use setTimeout to allow aaSequence.next() to return,\n        //  so that calls to aaSequence.next are not recursive\n        // setTimeout(()=>{\n        // debugger;\n        this.dispatchEvent(new CustomEvent('endEvent', { bubbles: true, detail }));\n        // },0);\n    }\n\n    _getParentSession() {\n        let _sessionElement = this;\n        while ((_sessionElement != null) && (_sessionElement.nodeName != 'AA-SESSION')) {\n            _sessionElement = _sessionElement.parentNode;\n        }\n        return _sessionElement;\n    }\n}\n\n\nif (!customElements.get('aa-base-element')) {\n    window.AANodeNames = window.AANodeNames || [];\n    window.AANodeNames.push('AA-BASE-ELEMENT');\n    customElements.define('aa-base-element', BaseElement);\n}\n\n\nwindow.nodeToJSON = BaseElement.nodeToJSON;\n","import BaseElement from '../aa-baseElement/baseElement.js';\nimport '../aa-choice-item/aa-choice-item.js';\n\nexport default class AACheckboxes extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n            horizontal: {\n                type: Boolean,\n                value: false,\n                userDefined: true\n            },\n\n            vertical: {\n                type: Boolean,\n                value: true,\n                userDefined: true\n            },\n\n            name: {\n                type: String,\n                userDefined: true\n            },\n\n            value: {\n                type: String,\n                userDefined: false\n            },\n            \n\n\n\n        }\n    }\n\n    static get acceptsElements() {\n        return [\n            'aa-choice-item'\n        ]\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AACheckboxes.properties);\n    }\n\n\n    get value() {\n\n        let result = [];\n        if (this.boxes) {\n            for (let i = 0; i < this.boxes.length; i++) {\n                if (this.boxes[i].checked) {\n                    result.push(this.boxes[i].value);\n                }\n                else {\n                    result.push(null);\n                }\n            }\n\n        }\n        console.log(result);\n        return result\n    }\n\n    set value(val) {\n        this.setAttribute('value', val);\n        this.boxGroup.selected = val;\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n        this.root.innerHTML = this.css + this.html;\n        this.boxes = [];\n        for (let i = 0; i < this.childNodes.length; i++) {\n            this.attachToShadowDomAccordingToKind(this.childNodes[i]);\n        }\n\n        this.boxes = this.root.querySelectorAll('paper-checkbox')\n\n        let val = this.getAttribute('value');\n        if (this.boxes) {\n            for (let i = 0; i < this.boxes.length; i++) {\n                if (this.boxes[i].value == val) {\n                    this.boxes[i].checked = true\n                }\n            }\n        }\n\n\n    }\n\n    attachToShadowDomAccordingToKind(node) {\n\n\n        if (!BaseElement.isAAElement(node)) {\n            this.root.appendChild(BaseElement.copy(node));\n        } else {\n            if (node.tagName === 'AA-CHOICE-ITEM') {\n                let child = document.createElement('paper-checkbox');\n                if (node.getAttribute('value')) {\n                    child.setAttribute('name', node.getAttribute('value'));\n                    child.setAttribute('value', node.getAttribute('value'));\n                } else {\n                    child.setAttribute('name', node.innerText.trim());\n                    child.setAttribute('value', node.innerText.trim());\n                }\n                if (!((this.horizontal === '') || (this.horizontal))) {\n                    child.style.display = 'block';\n                }\n                child.innerHTML = node.innerHTML;\n                this.root.appendChild(child);\n\n                // console.log('name: ', child.name);\n                this.boxes.push(child);\n            }\n        }\n    }\n\n    get html() {\n        return html``;\n    }\n\n    get css() {\n        return html`\n        <style>\n            paper-checkbox{\n                padding:12px;\n            }\n        </style>\n        \n        \n        `;\n    }\n\n    toJSON(){\n        let result = super.toJSON();\n        let children = [];\n        for(let i=0; i<this.children.length; i++){\n            children.push(this.children[i].toJSON());\n        }\n        \n        result[this.tagName.toLowerCase()].items = children;\n        return result; \n    }\n\n}\n\n\nBaseElement.registerAAElement('aa-checkboxes', AACheckboxes);","import BaseElement from '../aa-baseElement/baseElement.js';\nexport default class AAChoiceItem extends BaseElement {\n\n\n    static get properties(){\n        return{\n            value:{\n                type:String,\n                userDefined:true\n            }           \n        }\n    }\n    static get observedAttributes() {\n        return [\n            'name',\n            'value'\n        ];\n    }\n\n    static get acceptsElements(){\n        return null;\n    }\n\n    constructor() {\n        super();\n\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n\n    }\n\n    toJSON(){\n        let result= super.toJSON();\n        result[this.tagName.toLowerCase()].label = this.innerHTML.trim();\n        return result;\n    }\n}\n\nBaseElement.registerAAElement('aa-choice-item', AAChoiceItem);","import BaseElement from './../aa-baseElement/baseElement.js';\nimport './aa-when/aa-when.js';\nimport './aa-otherwise/aa-otherwise.js';\nimport jsep from '../../lib/jsep/jsep.js';\n\nexport default class AAChoose extends BaseElement {\n\n\n    static get properties(){\n        return {\n\n            ...BaseElement.properties,\n\n            name:{\n                type:String,\n                userDefined:true\n            },\n            \"should-run\":{\n                type:Boolean,\n                value:true,\n                userDefined:false\n            },\n            \"debug\":{\n                type:Boolean,\n                value:false,\n                userDefined:false\n            }\n        }\n    }\n\n    static get acceptsElements(){\n        return[\n            \"aa-when\", \"aa-otherwise\"\n        ]\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAChoose.properties);\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.innerHTML = '<slot></slot>';\n        this.originalContent = this.innerHTML;\n    }\n\n\n    connectedCallback() {\n        this.setAttributeDefaultValues();\n\n        if(this.diagram){\n\n            this.produceDiagram();\n            return;\n        }\n\n        this._shouldRun = (this.shouldRun === null) || (this.shouldRun === true);\n        this.sessionElement = this._getParentSession();\n\n\n        if (this._shouldRun) {\n            if (typeof this.innerFragment !== 'undefined') {\n                BaseElement.scanAndReplace(this.innerFragment);\n                let nodes = this._getNodeToInstantiate();\n                if (nodes.length === 0) {\n                    this._dispatchEndEvent();\n                } else {\n                    let doesAnyNodeExpectWait = false;\n                    for (let i = 0; i < nodes.length; i++) {\n                        let node = nodes[i];\n                        if (typeof node !== 'undefined') {\n\n                            /**\n                             * certain elements, mainly the screen,\n                             * are synchronous and need to dispatch\n                             * their own \"end\" events.\n                             * \n                             * so look into the list of childNodes\n                             * contained into the part of the choose-when-otherwise\n                             * block that gets instantiated, and if you see\n                             * one with the property expectWait, don't tell\n                             * the sequence to move forward.\n                             * \n                             * Possibly the architecture for this needs to change,\n                             * and have the sequence specifically extract newly\n                             * produced nodes and insert them itself\n                            **/\n                           \n                            for(let j=0; j<node.childNodes.length;j++){\n                                \n                                // the element has not been attached\n                                // so we have to access the static properties getter\n                                // to get the default value for expectWait\n                                if(node.childNodes[j].constructor)\n                                if(node.childNodes[j].constructor.properties)\n                                if(node.childNodes[j].constructor.properties['expect-wait']){\n                                    doesAnyNodeExpectWait = true;\n                                }\n                            }\n\n                            this.parentNode.insertBefore(node, this.nextSibling);\n                        }\n                    }\n            \n                    /** \n                     * so here dispatch evdEvent only if you haven't encountered\n                     * something that has expectWait:true\n                     */\n                    if(!doesAnyNodeExpectWait) {\n                        this._dispatchEndEvent();\n                    }\n                }\n            }\n            else {\n                if (this.childNodes.length === 0) {\n                    this._dispatchEndEvent();\n                }\n            }\n        }\n        this.remove();\n    }\n\n    _getNodeToInstantiate() {\n        let nodesToReturn = [];\n        let nodeOtherwise = [];\n        let isChildTrue = false;\n        for (let i = 0; i < this.innerFragment.children.length; i++) {\n            let child = this.innerFragment.children[i];\n            if (child.nodeName === 'AA-WHEN') {\n                isChildTrue = this.evaluate(child);\n                if (isChildTrue) {\n                    nodesToReturn.push(BaseElement.copy(child).innerFragment);\n                }\n            } else if (child.nodeName === 'AA-OTHERWISE') {\n                nodeOtherwise.push(BaseElement.copy(child).innerFragment);\n            }\n        }\n        if (nodesToReturn.length === 0) {\n            return nodeOtherwise;\n        }\n        else {\n            return nodesToReturn;\n        }\n    }\n\n\n    evaluate(element) {\n        let test = element.getAttribute('test');\n        if ((test == null) || (test == '')) return null;\n        return this.evaluateTestExpression(test);\n    }\n\n    evaluateTestExpression(test) {\n        console.log(test);\n        let expr = this.replaceExpressionIdentifiersWithValues(test);\n        // after replacing known variable names with their values in the string, test to see if the expression can be parsed\n\n\n        try {\n            var parseTree = jsep(expr);\n            if ((parseTree.left.type === 'Literal') && (parseTree.right.type === 'Literal')) {\n                return eval(expr);\n            }\n            else {\n                // there are still strings in the expression, which are unknown\n                // evaluate with values that the parseTreeProvides\n                return  eval(`${parseTree.left.value}${parseTree.operator}${parseTree.right.value}`);\n                //an exception should be raised\n                // throw 'unknown identifiers in expression : ' + expr;\n            }\n        } catch (e) {\n            console.error('parse error:', e);\n        }\n    }\n\n    replaceExpressionIdentifiersWithValues(expression, memoryElement) {\n\n        let memory = this.getMemory() || memoryElement;\n        let result = expression.toUpperCase();\n\n        let originalIdentifiers = Object.keys(memory.getDataDump());\n        let upperCaseIdentifiers = originalIdentifiers.map(s => s.toUpperCase());\n        for (let i in originalIdentifiers) {\n            let value = memory.getData(originalIdentifiers[i]);\n            let finalValue = parseInt(value);\n            if (finalValue != value) {\n                if (value === 'null') { finalValue = 'null'; }\n                else if (value === 'true') { finalValue = 'true'; }\n                else if (value === 'false') { finalValue = 'false'; }\n                else finalValue = `\"${value}\"`;\n            }\n            let r = new RegExp(upperCaseIdentifiers[i], 'g');\n            result = result.replace(r, finalValue);\n        }\n        return result;\n    }\n}\n\nBaseElement.registerAAElement('aa-choose', AAChoose);\n\n","import BaseElement from '../../aa-baseElement/baseElement.js';\n\nexport default class AAOtherwise extends BaseElement {\n\n    static get acceptsElements(){\n        return null;\n    }\n    \n    constructor() {\n        super();\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n    }\n}\n\n\nBaseElement.registerAAElement('aa-otherwise', AAOtherwise);\n","import BaseElement from './../../aa-baseElement/baseElement.js';\n\nexport default class AAWhen extends BaseElement {\n\n\n    static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:false\n            },\n            \"should-run\":{\n                type:Boolean,\n                value:true,\n                userDefined:false\n            },\n            \"debug\":{\n                type:Boolean,\n                value:false,\n                userDefined:false\n            },\n            \"test\":{\n                type:String,\n                userDefined:true\n            }\n        }\n    }\n    static get acceptsElements(){\n        return null;\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAWhen.properties);\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.innerHTML = '<slot></slot>'\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n    }\n}\n\nBaseElement.registerAAElement('aa-when', AAWhen);\n\n","import BaseElement from '../aa-baseElement/baseElement.js';\n\nexport default class AAFunctionRandom extends BaseElement {\n\n\n    static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:true\n            },\n           \n            \"debug\":{\n                type:Boolean,\n                value:false,\n                userDefined:false\n            },\n\n            \"value\":{\n                type:Number,\n                userDefined:false,\n            },\n\n            \"min\":{\n                type:Number,\n                userDefined:true,\n            },\n            \n            \"max\":{\n                type:Number,\n                userDefined:true,\n            },\n            \n\n        }\n    }\n\n    static get acceptsElements(){\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAFunctionRandom.properties);\n    }\n\n\n\n    constructor(){\n\n        super();\n    }\n\n    connectedCallback() {\n\n        let memory = this.getMemory();\n        if(memory) memory.setData(this.name, this.value);\n        this._dispatchEndEvent({ autoDispatch: true });\n        if (!this.debug) { this.remove(); }\n    }\n\n  \n    get value() {\n        var parsedMin = parseFloat(this.min);\n        var parsedMax = parseFloat(this.max);\n        let val = this.getRandomInt(parsedMin, parsedMax);\n        let memory = this.getMemory();\n        if(memory) memory.setData(BaseElement.getVariableName(this), val);\n        return  val;\n    }\n\n    getRandomInt(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min) + 0.5) + min;\n    }\n\n\n}\n\nBaseElement.registerAAElement('aa-function-random', AAFunctionRandom);\n\n","import BaseElement from './../aa-baseElement/baseElement.js'\nexport default class AAGeolocation extends BaseElement {\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n            'value': {\n                type: String,\n                userDefined: false\n            },\n\n            // 'lat': {\n            //     type: String,\n            //     userDefined: false\n            // },\n\n            // 'lon': {\n            //     type: String,\n            //     userDefined: false\n            // },\n\n            // 'timestamp':{\n            //     type: Date,\n            //     userDefined: false\n            // }\n\n        }\n    }\n\n    static get acceptsElements() {\n        return []\n    }\n\n    static get observedAttributes() {\n\n        return Object.keys(AAGeolocation.properties);\n\n    }\n\n    constructor() {\n        super();\n\n        this.root = this.attachShadow({ mode: 'open' });\n    }\n\n    connectedCallback() {\n\n\n        // let session = this._getParentSession();\n        // session.setData(this.name, this.value);\n        // this._dispatchEndEvent({autoDispatch:true});\n        // if(!this.debug) {this.remove();}\n\n        if (\"geolocation\" in navigator) {\n\n            navigator.geolocation.getCurrentPosition( (position)=> {\n\n                //  in this way it is synchronous, there will be no progression to the next\n                //  item in a sequence unless this callback function is called.\n\n                //  it could also be made asynchronous, where there will be a progression\n                //  regardless. Perhaps asynchronous components should notify parents\n                //  of their presence.\n\n                // do_something(position.coords.latitude, position.coords.longitude);\n\n                let lat = position.coords.latitude;\n                let lon = position.coords.longitude;\n                let timestamp = new Date();\n                this.value = { lat,  lon, timestamp}\n           \n                var valueSubmitEvent = new CustomEvent('valueSubmit', {bubbles:true, detail:{value:this.value}});\n                this.dispatchEvent(valueSubmitEvent);\n\n\n\n                // var assignableEndEvent = new CustomEvent(\"assignableEnd\", {bubbles:true, detail:{value:this.value}});\n                // this.dispatchEvent(assignableEndEvent);\n                this._dispatchEndEvent({value:this.value})\n            });\n        }\n    }\n\n\n}\n\nBaseElement.registerAAElement('aa-geolocation', AAGeolocation);\n\n","import BaseElement from '../aa-baseElement/baseElement.js';\nexport default class AALabel extends BaseElement {\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n        this.root.innerHTML = this.css + this.html;\n    }\n\n    get css(){\n        return html`\n            <style>\n                    :host{\n                        display:block;\n                        font-family: Roboto, Noto, sans-serif;\n                        font-weight:bold;\n                        margin-top:40px;\n                        margin-bottom:10px;\n                        \n                    }\n\n            </style>\n        `\n    }\n\n    get html(){\n        return `<slot></slot>`\n    }\n}\n\nBaseElement.registerAAElement('aa-label', AALabel);","import BaseElement from '../aa-baseElement/baseElement.js';\nimport '../aa-multiple-choice/aa-multiple-choice.js';\n\nexport default class AALikertScale extends BaseElement {\n\n\n    static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:true\n            },\n           \n            \"debug\":{\n                type:Boolean,\n                value:false,\n                userDefined:false\n            },\n\n            \"value\":{\n                type:Number,\n                userDefined:false,\n            },\n\n            \"items\":{\n                type:String,\n                userDefined:true,\n            },\n\n            \"start-label\":{\n                type:String,\n                userDefined:true,\n                value:''\n            },\n\n            \"middle-label\":{\n                type:String,\n                userDefined:true,\n                value:''\n            },\n\n            \"end-label\":{\n                type:String,\n                userDefined:true,\n                value:''\n            },\n\n            \"start-item\":{\n                type:Number,\n                userDefined:true,\n                value:1\n            }\n            \n            \n\n        }\n    }\n\n    static get acceptsElements(){\n        return [];\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AALikertScale.properties);\n    }\n\n\n\n    constructor(){\n\n        super();\n\n        this.root = this.attachShadow({ mode: 'open' });\n\n\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n\n        \n        this.root.innerHTML = this.html;\n\n        this.mChoice = this.root.querySelector(\"aa-multiple-choice\")\n        this.choiceItems = this.mChoice.choiceItems\n    }\n\n\n    getTags(){\n        \n        let c = '';\n        let start = `<div style=\"width:100px; white-space:nowrap\">${this.getAttribute(\"start-label\") || ''}</div>`\n        let middle = `<div style=\"width:100px; white-space:nowrap\">${this.getAttribute(\"middle-label\") || ''}</div>`\n        let end = `<div style=\"width:100px; white-space:nowrap\">${this.getAttribute(\"end-label\") || ''}</div>`\n        let placeholder = `<div style=\"width:50px\"></div>`;\n        \n\n\n        let items = parseInt(this.items)\n        for(let i=1; i<=items; i++){\n            \n            \n            \n            if(i==1) {\n                c+=start;\n            }\n            else if(i==Math.floor((items+1)/2)) {\n\n                c+=middle;\n            }\n            else if(i==items) {\n                c+=end;\n            } else{\n                c+=placeholder;\n            }\n\n            \n        }   \n\n        let result = `<div style=\"font-family: Roboto, Noto, sans-serif; width:100%; display:flex; justify-content:space-evenly; text-align:center\">${c}</div>`\n        return result;\n\n    }\n    get html(){\n        let items = ``;\n\n        let startItem = parseFloat(this.startItem)\n\n        if((!this.items)||(this.items===\"undefined\")) this.items = 5;\n        for(let i=0; i<this.items; i++){\n            items += `<aa-choice-item name=\"${i+startItem}\">${i+startItem}</aa-choice-item>`;\n        }\n        let result =  html`<div>\n                                <aa-multiple-choice horizontal=\"true\" name=\"${this.name}\">${items}</aa-multiple-choice>\n                                ${this.getTags()}    \n                            </div>\n                                `\n        \n        return result;\n    }\n\n\n    get value(){\n\n        if(this.mChoice)\n        {\n            return parseInt(this.mChoice.value);\n        } else{\n            return parseInt(this.getAttribute('value'));\n        }\n    }\n\n\n    getValue() {\n       return this.mChoice.value; \n    }\n\n \n\n\n}\n\nBaseElement.registerAAElement('aa-likert-scale', AALikertScale);\n\n","import BaseElement from './../aa-baseElement/baseElement.js'\n\n\n\nexport default class AAMemory extends BaseElement {\n\n    get observedAttributes(){\n        return [\"name\"];\n    }\n\n    constructor(){\n        super();\n    }\n\n    connectedCallback(){\n        \n    }\n\n    \n    \n    setData(name,value){\n        // this.dataset[name] = value;\n        localStorage[name] = value;\n    }\n\n    getData(name){\n        return localStorage[name];\n    }\n\n    getDataDump(){\n        return localStorage;\n    }\n}\n\nBaseElement.registerAAElement('aa-memory', AAMemory);\n","import BaseElement from '../aa-baseElement/baseElement.js';\nimport '../aa-choice-item/aa-choice-item.js';\n\nexport default class AAMultipleChoice extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n            horizontal: {\n                type: Boolean,\n                value: false,\n                userDefined: true\n            },\n\n            vertical: {\n                type: Boolean,\n                value: true,\n                userDefined: true\n            },\n\n            name: {\n                type: String,\n                userDefined: true\n            },\n\n            value: {\n                type: String,\n                userDefined: true,\n\n            },\n\n        }\n    }\n\n    static get acceptsElements() {\n        return [\n            'aa-choice-item'\n        ]\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAMultipleChoice.properties);\n    }\n\n    get staticObject(){\n        return AAMultipleChoice;\n    }\n\n    get value() {\n\n        if (this.radioGroup) {\n            return this.radioGroup.selected;\n        }\n        return this.getAttribute('value');\n    }\n\n    set value(val) {\n\n        this.setAttribute('value', val);\n        this.radioGroup.selected = val;\n    }\n\n    constructor() {\n        super();\n\n        if(this.horizontal===''){\n            this.horizontal = true;\n        }\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.innerHTML = this.css + this.html;\n\n        this.radioGroup = this.root.querySelector('#radioGroup');\n        this.radioGroup.addEventListener('change', (e) => {\n            this.value = e.target.name;\n            // console.log(this.value);\n        });\n\n    }\n\n    connectedCallback() {\n\n        super.connectedCallback();\n\n        this.choiceItems = [];\n        for (let i = 0; i < this.childNodes.length; i++) {\n            this.attachToShadowDomAccordingToKind(this.childNodes[i]);\n        }\n\n        if ((this.getAttribute('value'))&&(this.getAttribute('value')!=='undefined')) {\n            this.radioGroup.setAttribute('selected', this.getAttribute('value'));\n        }\n\n        this.style.display = 'block';\n    }\n\n    attachToShadowDomAccordingToKind(node) {\n\n        if (!BaseElement.isAAElement(node)) {\n            this.root.appendChild(BaseElement.copy(node));\n        } else {\n            if (node.tagName === 'AA-CHOICE-ITEM') {\n\n                let child = document.createElement('paper-radio-button');\n                if (node.getAttribute('value')) {\n                    child.setAttribute('name', node.getAttribute('value'));\n                } else {\n                    child.setAttribute('name', node.innerText.trim());\n                }\n                if (!((this.horizontal === '') || (this.horizontal))) {\n                    child.style.display = 'block';\n                }\n\n                child.innerHTML = node.innerHTML;\n                 \n                this.radioGroup.appendChild(child);\n                this.choiceItems.push(child);\n\n\n                if (((this.horizontal === '') || (this.horizontal))) {\n                    \n\n                    this.radioGroup.style.display='flex';\n                    this.radioGroup.style.justifyContent='space-evenly';\n\n                    // debugger;\n                    let d1 = child.shadowRoot.querySelector('#radioContainer');\n                    let d2 = child.shadowRoot.querySelector('#radioLabel');\n                    d2.style.textAlign = 'center';\n                    d2.style.marginLeft = '0px';\n                    d2.style.padding = '5px';\n                    // d2.style.whiteSpace = \"nowrap\";\n                    // d2.style.minWidth = \"50px\";\n                    // d2.style.maxWidth = \"90px\";\n                    let newDiv = document.createElement('div');\n                    newDiv.style.marginLeft = 'var(--paper-radio-button-label-spacing,10px)';\n                    newDiv.style.display='flex';\n                    newDiv.style.flexDirection='column';\n                    newDiv.style.alignItems = 'center';\n                    newDiv.style.textAlign = 'center';\n                    child.shadowRoot.appendChild(newDiv);\n                    newDiv.appendChild(d1);\n                    newDiv.appendChild(d2);\n \n                \n                } \n                // else {\n\n                // }\n\n            }\n        }\n    }\n\n    get html() {\n        return html`<paper-radio-group id='radioGroup'></paper-radio-group>`;\n    }\n\n    get css() {\n        return ``;\n    }\n\n\n    toJSON(){\n        let result = super.toJSON();\n        if((result.horizontal)){\n            result.horizontal = true;\n        }\n\n        let children = [];\n        for(let i=0; i<this.children.length; i++){\n            children.push(this.children[i].toJSON());\n        }\n        \n        result[this.tagName.toLowerCase()].items = children;\n        return result; \n    }\n}\n\n\nBaseElement.registerAAElement('aa-multiple-choice', AAMultipleChoice);","import BaseElement from './../aa-baseElement/baseElement.js';\nexport default class AAScreen extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n\n            ...BaseElement.properties,\n\n    \n            \"submit-button-text\": {\n                type: String,\n                value: \"submit\",\n                userDefined: true\n            },\n\n            \"submit-button-hidden\": {\n                type: Boolean,\n                value: false,\n                userDefined: true\n            },\n\n            'expect-wait': {\n                type: Boolean,\n                userDefined: false,\n                value: true\n            },\n\n            'autohide': {\n                type: Boolean,\n                userDefined: false,\n                value: true\n            }\n\n\n\n        }\n    }\n\n    static get acceptsElements() {\n        return null;\n    }\n    static get observedAttributes() {\n        return Object.keys(AAScreen.properties);\n    }\n\n\n    attributeChangedCallback(name, oldValue, newValue) {\n        switch (name) {\n            case 'submit-button-text':\n                if (this.submitButton) { this.submitButton.innerHTML = newValue; }\n                break;\n            case 'submit-button-hidden':\n                if (this.submitButtonContainer) {\n                    if ((newValue !== true) || (newValue !== 'true')) {\n                        this.submitButtonContainer.style.display = 'block';\n                    } else {\n                        this.submitButtonContainer.style.display = 'none';\n                    }\n                }\n                break;\n        }\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n        if (this.diagram) {\n            this.produceDiagram();\n            return;\n        }\n        this.root.innerHTML = this.css + this.html;\n        // this.submitButton = this.root.querySelector('.submitButton');\n        this.submitButtonContainer = this.root.querySelector('.submitButtonContainer');\n        if (this._started) { return; }\n        this._started = true;\n\n        if (this.submitButtonHidden) {\n            if (this.submitButtonContainer) {\n                this.submitButtonContainer.style.display = 'none';\n            }\n        }\n\n\n        this.root.querySelector('.submitButton').addEventListener('click', this.submitButtonClick.bind(this));\n\n\n    }\n\n\n    get css() {\n\n        return html`<style>\n                :host {\n                    display: block;\n                    height: fit-content;\n                    padding:20px;\n                    font-family:sans-serif;\n                }\n\n                .submitButtonContainer{\n                    text-align:right;\n                    justify-content: space-between; \n                    align-items:center;\n                    padding:20px;\n                }\n\n\n                paper-button.darkBlue {\n                    background-color: #0d47a1;\n                    color: white;\n                 }\n  \n         </style>`;\n    }\n\n    get html() {\n        return html`\n            <slot></slot>\n            <div id='userMessage'>\n                <div class='submitButtonContainer'>\n                    <div>\n                        ${this.getSubmitButton()}\n                    </div>\n                    <div id='userMessage'></div>\n                </div>`;\n    }\n\n    getSubmitButton() {\n        let buttonText = this.submitButtonText || 'submit';\n        if (customElements.get('paper-button')) {\n            return html`<paper-button class='submitButton darkBlue' raised class='indigo'>${buttonText}</paper-button>`;\n        } else {\n            return html`<button class='submitButton'>${buttonText}</button>`;\n        }\n    }\n\n    submitButtonClick(e) {\n\n        let userMessage = this.querySelector('#userMessage');\n        if (this.hasChildrenThatDemandResponse()) {\n\n            userMessage.innerHTML = html`\n                    <div style='display:flex; align-items:center'>\n                        <div>please fill out the required fields</div>\n                        <div id='attention' style='color: red; font-size: 20px;  border: solid thin; border-radius: 50%; width: 20px;\n                                                                                        margin-left:20px; height: 20px; \n                                                                                        text-align: center;\n                                                                                        padding: 5px;'>!</div>\n                    </div>`;\n            return;\n        }\n\n        let valueSubmitEvent = new CustomEvent('valueSubmit', { bubbles: true, detail: { value: this.value } });\n        this.dispatchEvent(valueSubmitEvent);\n        this._dispatchEndEvent(this.value);\n        if (typeof e.detail.callback != 'undefined') {\n            e.detail.callback(e);\n        }\n        if (this.autohide) {\n            this.hide();\n        }\n\n    }\n\n\n\n\n\n\n    hasChildrenThatDemandResponse() {\n\n        let aaChildren = this.getAAChildren(this);\n        let isMissingValues = false;\n        for (let i = 0; i < aaChildren.length; i++) {\n            if (aaChildren[i].mandatory) {\n                if (child.value === null) {\n                    // console.log(child, 'demands response');\n                    // TODO : add a class to the child\n                    isMissingValues = true;\n                }\n            }\n        }\n\n        return isMissingValues;\n    }\n\n    getAAChildren() {\n        let result = [];\n        for (let i = 0; i < this.children.length; i++) {\n            if (BaseElement.isAAElement(this.children[i])) { result.push(this.children[i]); }\n        }\n        return result;\n    }\n\n\n\n    getChildrenValues(node, result) {\n        node = node || this;\n        result = result || {};\n        for (let i = 0; i < node.children.length; i++) {\n            let c = node.children[i];\n\n            if (c.nodeName != 'AA-LABEL') {\n\n                let name = BaseElement.getVariableName(c);\n                console.log(c, name);\n                if (c.getValue) {\n                    result[name] = c.getValue();\n                } else if (c.value) {\n                    result[name] = c.value;\n                } else {\n                    result[name] = null;\n                }\n            }\n            else {\n\n\n                this.getChildrenValues(c, result);\n            }\n        }\n        return result;\n    }\n\n\n\n\n\n    get value() {\n        let __meta = {\n            attachedTimestamp: this._attachedTimestamp,\n            submitTimestamp: new Date().getTime()\n        };\n        let result = this.getChildrenValues(this);\n        result['__meta'] = __meta;\n        return result;\n    }\n\n    get valueWithKey() {\n        let result = {};\n\n        result[this.name] = this.value;\n\n        return result;\n    }\n\n\n    automate() {\n        for (let i = 0; i < this.children.length; i++) {\n            if (BaseElement.isAAElement(this.children[i])) {\n                if (typeof this.children[i].automate != 'undefined') {\n                    this.children[i].automate();\n                }\n            }\n        }\n        this.submitButtonClick();\n    }\n\n    hide() {\n        this.style.display = 'none';\n    }\n\n    show() {\n        this.style.display = 'block';\n    }\n\n\n\n\n\n}\n\nBaseElement.registerAAElement('aa-screen', AAScreen);\n\n","import BaseElement from '../../aa-baseElement/baseElement.js';\n\nexport default class AAJump extends BaseElement {\n\n\n\n    static get properties(){\n        return {\n            name:{\n                type:String,\n                userDefined:true\n            },\n            \"goto\":{\n                type:String,\n                userDefined:true\n            },\n\n        }\n    }\n\n    static get acceptsElements(){\n        return []\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AAJump.properties);\n    }\n\n    connectedCallback() {\n        this._dispatchEndEvent({ goto: this.goto, autoDispatch: true });\n        this.remove();\n    }\n}\n\nBaseElement.registerAAElement('aa-jump', AAJump);\n","import BaseElement from './../aa-baseElement/baseElement.js';\nimport './aa-jump/aa-jump.js';\n\n\n\nexport default class AASequence extends BaseElement {\n\n    static get properties() {\n        return {\n\n            ...BaseElement.properties,\n\n            name: {\n                type: String,\n                userDefined: true\n            },\n            'write-into': {\n                type: String,\n                userDefined: true\n            },\n\n            'should-run': {\n                type: Boolean,\n                userDefined: true,\n                value: true\n            },\n\n            'debug': {\n                type: Boolean,\n                value: false,\n                userDefined: false\n            },\n            'type': {\n                type: String, //there should be an array of options type\n                userDefined: false\n            },\n            'stopped': {\n                type: Boolean,\n                userDefined: false\n            },\n\n        }\n    }\n\n    static get acceptsElements() {\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AASequence.properties);\n    }\n\n    constructor() {\n        super();\n    }\n    connectedCallback() {\n        this.setAttributeDefaultValues();\n        if(this.diagram){\n            this.produceDiagram();\n            return;\n        }\n        this.addEventListener('endEvent', this.endEventListener.bind(this));\n        if ((this.shouldRun === null) || (this.shouldRun === true)) {\n            this.init()\n        }\n    }\n\n\n    get css() {\n        return html`\n            <style>\n                :host {\n                    display: block;\n                }\n            </style>\n        `\n    }\n\n    get html() {\n        return html`\n            <slot></slot>\n            <button id='nextButton' hidden></button>\n        `\n    }\n\n    init() {\n        this.stopped = false;\n        if (this.writeInto) {\n            this.target = document.querySelector(this.writeInto);\n        } else {\n            this.target = this;\n        }\n\n\n\n        if (typeof this.innerFragment === 'undefined') {\n            console.warn('.innerFragment is undefined');\n            // this.restoreHeldNodes(this)\n            return;\n        }\n\n\n        this.sIndex = 0;\n        if (!this.stopped) { this.start() }\n    }\n\n    start() {\n        this.stopped = false;\n        this.next();\n    }\n\n    stop() {\n        this.stopped = true;\n    }\n\n\n\n\n    next(name) {\n\n        return new Promise((resolve, reject) => {\n\n            if (this.stopped) { return; }\n            if (this.sIndex >= this.innerFragment.childNodes.length) return null;\n\n            if (typeof name === 'string') {\n                for (let i = 0; i < this.innerFragment.childNodes.length; i++) {\n                    if (this.innerFragment.childNodes[i].getAttribute) if (this.innerFragment.childNodes[i].getAttribute('name') == name) {\n                        this.sIndex = i;\n                        break;\n                    }\n                }\n            }\n\n            let fragmentChild = this.innerFragment.childNodes[this.sIndex];\n\n            // if (fragmentChild.nodeName == \"aa-screen\") debugger;\n            //  if the child is not an element just add it immediately \n            //  and move on to the next, there won't be a connectecCallback Function to execute anyway\n            while (fragmentChild.nodeType != Node.ELEMENT_NODE) {\n\n                let fragmentChildCopy = BaseElement.copy(fragmentChild);\n                this.target.appendChild(fragmentChildCopy);\n                this.currentNode = fragmentChildCopy;\n                this.sIndex++;\n                if (this.sIndex >= this.innerFragment.childNodes.length) { return; }\n                fragmentChild = this.innerFragment.childNodes[this.sIndex];\n            }\n            let fragmentChildCopy = BaseElement.copy(fragmentChild);\n            this.currentNode = fragmentChildCopy;\n            this.sIndex += 1;\n            // if (!fragmentChildCopy._dispatchEndEvent) {\n            //     this.target.appendChild(fragmentChildCopy);\n            //     // resolve(this.next());\n            //     resolve();\n            // } else {\n                this.target.appendChild(fragmentChildCopy);\n                setTimeout(() => resolve());\n            // }\n        })\n    }\n\n    endEventListener(e) {\n        e.stopPropagation();\n        if (e.detail) {\n            if (e.detail.goto) { this.next(e.detail.goto); }\n            else if (e.detail.autoDispatch) { this.next(true); }\n            else { setTimeout(() => this.next(true)); }\n        } else {\n            setTimeout(() => this.next(true))\n        }\n    }\n\n}\n\n\n\nBaseElement.registerAAElement('aa-sequence', AASequence);\n\n\n","import BaseElement from './../aa-baseElement/baseElement.js';\nimport './../aa-memory/aa-memory.js';\nimport * as html2jsl from './../../lib/html2jsl/html2jsl.js';\nimport { AASequence } from '../../index.js';\n\n\nexport default class AASession extends BaseElement {\n\n    static get properties() {\n\n        return {\n           \n            ...BaseElement.properties,\n\n\n            'should-run': {\n                type: Boolean,\n                userDefined: true,\n                value:true\n            },\n\n            'debug': {\n                type: Boolean,\n                value: false,\n                userDefined: false\n            },\n\n          \n\n            \n\n        }\n    }\n\n    static get acceptsElements() {\n        return null\n    }\n\n    static get observedAttributes() {\n\n        return Object.keys(AASession.properties);\n    }\n\n\n\n    constructor() {\n        super();\n\n\n        this.myTemplate = document.createElement('template');\n        this.myTemplate.innerHTML = this.innerHTML;\n\n\n        this.innerHTML = '';\n\n        // this.root = this.attachShadow({ mode: 'closed' });\n        // this.root.innerHTML = '<template><slot></slot></template>'\n        this._mem = document.createElement('aa-memory');\n        this.addEventListener('valueSubmit', (e) => {\n\n            // e.stopPropagation();\n            let input = {\n                data: e.detail.value,\n                sessionID: this.sessionID,\n                sessionTimestamp: this.sessionTime,\n                sessionName: this.name,\n                variables: Object.keys(e.detail.value),\n            };\n            // TODO:  this._mem.saveReplyValue(e.detail.value, false);\n            \n        \n\n            let inputSubmitEvent = new CustomEvent('inputSubmit', { bubbles: true, detail: { input } });\n            this.dispatchEvent(inputSubmitEvent);\n            //  ema-participant-client needs to catch this and either send it to the server,\n            //  or store it locally if we are offline\n            //  A reason that ema-participant-client needs to do this, is because it cares\n            //  about identification tokens\n\n\n        })\n\n        this.addEventListener('endEvent', (e) => {\n\n            if (!this.debug) e.stopPropagation();\n            let sessionEndEvent = new CustomEvent('sessionEndEvent', { bubbles: true, detail: 'sessionEnd' });\n            this.dispatchEvent(sessionEndEvent);\n        })\n\n\n    }\n\n    myIdGenerator() {\n\n        return 0;\n    }\n\n    connectedCallback() {\n        this.setAttributeDefaultValues()\n\n    \n        // console.log(this.tagName+\"#\"+this.id,\"connected\");\n        if(this.diagram===true){\n            this.produceDiagram()\n            return;\n        } \n        this.sessionID = this.myIdGenerator();\n        this.sessionTime = new Date().getTime();\n        let sessionDatum = Object.keys(this.dataset);\n        for (let i in sessionDatum) {\n            this.setData(sessionDatum[i], this.dataset[sessionDatum[i]]);\n        }\n        if ((this.shouldRun === null) || (this.shouldRun === true)) {\n            this.run();\n        }\n\n        setTimeout( ()=>{\n            this.dispatchEvent(new CustomEvent(\"sessionReady\", {bubbles:true}));\n        },0);\n    }\n\n\n    attachTemplateChildNodesToMyself(templateClone) {\n\n        while (templateClone.content.childNodes.length) {\n            //  if there's a direct template child, we want its children appended too\n            if (templateClone.content.childNodes[0].nodeName === \"TEMPLATE\") {\n                while (templateClone.content.childNodes[0].content.childNodes.length) {\n                    this.appendChild(templateClone.content.childNodes[0].content.childNodes[0]);\n                }\n                //  we are not appending the template element elsewhere \n                //  so throw it way so that the childnode count can be reduced\n                templateClone.content.childNodes[0].remove();\n            } else {\n                this.appendChild(templateClone.content.childNodes[0]);\n            }\n        }\n    }\n\n    run() {\n\n        let myTemplateClone = this.myTemplate.cloneNode(true);\n        BaseElement.scanAndReplace(myTemplateClone);\n        this.attachTemplateChildNodesToMyself(myTemplateClone);\n    }\n\n    getData(name) {\n        return this._mem.getData(name);\n    }\n\n    setData(name, value) {\n\n        return this._mem.setData(name, value);\n    }\n\n    getDataDump() {\n        return this._mem.getDataDump();\n    }\n\n\n    toJSON() {\n        // return super.toJSON();\n\n        let result = {};\n        result[this.tagName] = this.getAttributes();\n\n        let childNodes = [];\n        for (let i = 0; i < this.originalChildNodes.length; i++) {\n            let child = this.originalChildNodes[i];\n            let el = BaseElement.nodeToJSON(child);\n            if (el) {\n                childNodes.push(el);\n            }\n        }\n        result[this.tagName].childNodes = [{ \"template\": { childNodes: childNodes } }];\n        return result;\n\n    }\n\n    toJSL() {\n        let attrNames = this.getAttributeNames();\n        let attrObj = {};\n        for (let i = 0; i < attrNames.length; i++) {\n            if (this.getAttribute(attrNames[i]) !== 'undefined') {\n                attrObj[attrNames[i]] = this.getAttribute(attrNames[i]);\n            }\n        }\n\n        let argsStrings = [];\n        let childNodes = this.myTemplate.content.childNodes[0].content.childNodes;\n        for (let i = 0; i < childNodes.length; i++) {\n            let addition = html2jsl.nodeToJSL(childNodes[i]);\n            if (addition) {\n                argsStrings.push(html2jsl.nodeToJSL(childNodes[i]));\n\n            }\n        }\n\n        \n\n        \n        let templateString = html2jsl.formatJSLResult(\"TEMPLATE\", {}, argsStrings);\n        let final = html2jsl.formatJSLResult(\"AA_SESSION\", attrObj, [templateString]);\n\n        return final;\n    }\n\n\n\n    get originalChildNodes(){\n        if(this.myTemplate.content.childNodes.length==0) return [];\n        if(!this.myTemplate.content.childNodes[0].content) return this.childNodes;\n        return this.myTemplate.content.childNodes[0].content.childNodes;\n    }\n\n\n\n\n}\n\nBaseElement.registerAAElement('aa-session', AASession);\n\n\n\n\n\n\n\n","import BaseElement from '../aa-baseElement/baseElement.js';\nexport default class AASlider extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n            'min': {\n                type: Number,\n                userDefined: true\n            },\n            'max': {\n                type: Number,\n                userDefined: true\n            },\n            'min-label': {\n                type: String,\n                userDefined: true\n            },\n            'max-label': {\n                type: String,\n                userDefined: true\n            },\n            'value': {\n                type: Number,\n                userDefined: false\n            },\n\n        }\n    }\n\n    static get acceptsElements() {\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AASlider.properties);\n    }\n\n\n \n\n    get value() {\n        if (!this.inputItem) {\n            return this.getAttribute('value');\n        }\n        return this.inputItem.value;\n    }\n    set value(val) {\n        this.setAttribute('value', val);\n        if (this.inputItem) {\n            this.inputItem.value = val;\n        }\n\n    }\n\n    get minLabel() {\n        return this.getAttribute('min-label');\n    }\n\n    get maxLabel() {\n        return this.getAttribute('max-label');\n    }\n\n    set minLabel(val) {\n        this.setAttribute('min-label', val);\n        if (this.inputItem) {\n            this.inputItem.minLabel = val;\n        }\n    }\n\n    set maxLabel(val) {\n        this.setAttribute('max-label', val);\n        if (this.inputItem) {\n            this.inputItem.maxLabel = val;\n        }\n    }\n\n    set min(val) {\n        this.setAttribute('min', val);\n        if (this.inputItem) {\n            this.inputItem.min = val;\n        }\n    }\n\n    set max(val) {\n        this.setAttribute('max', val);\n        if (this.inputItem) {\n            this.inputItem.max = val;\n        }\n    }\n\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        \n        let innerHTML = this.css + `<div class='inputContainer'>${this.html}</div>`;\n        this.root.innerHTML = innerHTML;\n\n        let minLabel = this.minLabel;\n        let maxLabel = this.maxLabel;\n        // let min = this.min || 0;\n        // let max = this.max || 100;\n        let value = this.value || (this.min + this.max)/2;\n        this.inputItem = this.root.querySelector('.inputItem');\n        this.minLabelItem = this.root.querySelector('.minLabel');\n        this.maxLabelItem = this.root.querySelector('.maxLabel');\n        \n        if (minLabel) { this.minLabelItem.innerHTML = minLabel;}\n        if (maxLabel) { this.maxLabelItem.innerHTML = maxLabel;}\n        if (value) { this.inputItem.value = value; }\n        \n        this.inputItem.addEventListener('change', (e) => {\n            this.value = e.target.value;\n        });\n    }\n\n\n\n    connectedCallback() {\n        super.connectedCallback();\n\n\n    }\n\n    get css() {\n        return `<style>\n        :host{\n            display:block;\n            overflow:hidden;        \n        }\n        </style>\n        `;\n    }\n\n    get html() {\n        let inputElement = customElements.get('paper-slider')\n            ? `<paper-slider style=\"width:100%\" class='inputItem min=${this.min} max=${this.max}'></paper-slider>`\n            : `<input style=\"width:100%\" type=\"range\" class=\"inputItem\" min=\"${this.min}\" max=\"${this.max}\" value=\"${(this.max+this.min)/2}\">`;\n        \n\n        let source = html`\n        <div>${inputElement}</div>\n        <div style=\"display:flex; justify-content:space-between\">\n            <div class=\"minLabel\">${this.minLabel || ''}</div>\n            <div style=\"text-align:right\" class=\"maxLabel\">${this.maxLabel || ''}</div>\n        </div>\n        `\n        return source;\n    }\n   \n\n}\n\nBaseElement.registerAAElement('aa-slider', AASlider);","import BaseElement from '../aa-baseElement/baseElement.js';\nexport default class AATextAnswer extends BaseElement {\n\n\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n            'long': {\n                type: Boolean,\n                userDefined: true\n            },\n            label: {\n                type: String,\n                userDefined: true\n            },\n            'value': {\n                type: String,\n                userDefined: false\n            },\n            'type':{\n                type: String,\n                userDefined: true,\n                value:\"text\",\n                valuesAllowed: [\"date\", \"datetime\", \"datetime-local\", \"email\", \"number\", \"password\", \"tel\", \"text\", \"time\" ]\n            }\n\n        }\n    }\n\n    static get acceptsElements() {\n        return null\n    }\n\n    static get observedAttributes() {\n        return Object.keys(AATextAnswer.properties);\n    }\n\n\n    changeInputItem(type) {\n        if (type === 'long') {\n            let value = this.value;\n            let label = this.label;\n            this.inputItem = customElements.get('paper-textarea') ?\n                document.createElement('paper-textarea') : document.createElement('textarea');\n            this.inputItem.value = value;\n            this.inputItem.label = label;\n            this.inputItem.classList.add('inputItem');\n            this.fixBugInPaperTextarea(this.inputItem);\n            this.inputItem.addEventListener('change', (e) => {\n                this.value = e.target.value;\n            })\n            this.root.querySelector('.inputItem').replaceWith(this.inputItem);\n        } else {\n            let value = this.value;\n            let label = this.label;\n            this.inputItem = customElements.get('paper-input') ?\n                document.createElement('paper-input') : document.createElement('input');\n            this.inputItem.value = value;\n            this.inputItem.label = label;\n            this.inputItem.classList.add('inputItem');\n            this.inputItem.addEventListener('change', (e) => {\n                this.value = e.target.value;\n            })\n            this.root.querySelector('.inputItem').replaceWith(this.inputItem);\n        }\n    }\n\n\n    get value() {\n        if (!this.inputItem) {\n            return this.getAttribute('value');\n        }\n        return this.inputItem.value;\n    }\n    set value(val) {\n        this.setAttribute('value', val);\n        if (this.inputItem) {\n            this.inputItem.value = val;\n        }\n\n        let memory = this.getMemory();\n        if(memory) memory.setData(BaseElement.getVariableName(this), val);\n\n    }\n\n    get label() {\n        return this.getAttribute('label');\n    }\n\n    set label(val) {\n        this.setAttribute('label', val);\n        if (this.inputItem) {\n            this.inputItem.label = val;\n        }\n    }\n\n    set long(val) {\n        this.setAttribute('long', val);\n        if (val) {\n            this.changeInputItem('long');\n        } else {\n            this.changeInputItem('short');\n        }\n    }\n\n    get long() {\n        return this.getAttribute('long');\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        let html = (this.long || (this.long === '')) ? this.longHtml : this.html;\n\n        this.root.innerHTML = this.css + `<div class='inputContainer'>${html}</div>`;\n\n        let label = this.label;\n        let value = this.value;\n        this.inputItem = this.root.querySelector('.inputItem');\n        if (label) { this.inputItem.label = label; }\n        if (value) { this.inputItem.value = value; }\n        this.fixBugInPaperTextarea(this.inputItem);\n\n        this.inputItem.addEventListener('change', (e) => {\n            this.value = e.target.value;\n        });\n    }\n\n\n    fixBugInPaperTextarea(inputItem) {\n        // solves issue documented here: https://github.com/PolymerElements/paper-input/issues/125\n\n        setTimeout(() => {\n            if (inputItem.tagName === 'PAPER-TEXTAREA') {\n                inputItem.root.childNodes[2].children[1].textarea.style.overflow = 'hidden';\n                let width = window.getComputedStyle(this.root.querySelector('.inputContainer')).width;\n\n                inputItem.root.childNodes[2].style.width = width;\n                inputItem.addEventListener('focus', (e) => {\n                    let width = window.getComputedStyle(this.root.querySelector('.inputContainer')).width;\n                    inputItem.root.childNodes[2].style.width = width;\n                })\n\n                window.addEventListener('resize', () => {\n                    inputItem.root.childNodes[2].style.width = '';\n                    setTimeout(() => {\n                        let width = window.getComputedStyle(this.root.querySelector('.inputContainer')).width;\n                        inputItem.root.childNodes[2].style.width = width;\n                    }, 100);\n\n                })\n            }\n        }, 0);\n\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n\n\n    }\n\n    get css() {\n        return `<style>\n        :host{\n            display:block;\n            overflow:hidden;        \n        }\n        paper-textarea textarea {\n           overflow:hidden;\n        }\n        </style>`;\n    }\n\n    get html() {\n        let inputElement = customElements.get('paper-input')\n            ? `<paper-input type='${this.type}' class='inputItem'></paper-input>`\n            : `<input type='${this.type}' class='inputItem'>`;\n        return html`${inputElement}`\n    }\n    get longHtml() {\n        let inputElement = customElements.get('paper-input')\n            ? `<paper-textarea class='inputItem'></paper-input>`\n            : `<textarea class='inputItem'></textarea`;\n        return html`${inputElement}`\n    }\n\n}\n\nBaseElement.registerAAElement('aa-text-answer', AATextAnswer);\n\n","import BaseElement from './../aa-baseElement/baseElement.js'\nimport jsep from '../../lib/jsep/jsep.js';\n\nexport default class AAVariable extends BaseElement {\n\n    static get properties() {\n        return {\n            name: {\n                type: String,\n                userDefined: true\n            },\n            'value': {\n\n                /**\n                 * string values should be given in quotes, e.g.,\n                 * <aa-variable name=\"myString\" value=\"'myStringValue'\"></aa-variable>\n                 * Here 'myStringValue' is passed to the value attribute in single quotes\n                 * \n                 * otherwise it will try to find a named variable, e.g.,\n                 * <aa-variable name=\"myOtherSring\" value=\"'myStringValue'\"></aa-variable>\n                 * <aa-variable name=\"myString\" value=\"myOtherString\"></aa-variable>\n                 * Here the value will be the same value as a variable with name=\"myOtherString\"\n                 * \n                 */\n                type: String,\n                userDefined: true\n            },\n\n        }\n    }\n\n    static get acceptsElements() {\n        return []\n    }\n\n    static get observedAttributes() {\n\n        return Object.keys(AAVariable.properties);\n\n    }\n\n    constructor() {\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n    }\n\n    connectedCallback() {\n        let memory = this.getMemory();\n\n        // TODO:\n        // let value = this.evaluateValueExpression(this.value);\n\n        // leave as is for now\n        let value = this.value;\n\n        // let _value = valueExpression;\n        if(memory) memory.setData(this.name, value);\n        this._dispatchEndEvent({autoDispatch:true});\n        if(!this.debug) {this.remove();}\n    }\n\n\n\n    evaluateValueExpression(test) {\n        console.log(test);\n        let expr = this.replaceExpressionIdentifiersWithValues(test);\n        // after replacing known variable names with their values in the string, test to see if the expression can be parsed\n\n        debugger;\n        try {\n            var parseTree = jsep(expr);\n            if(parseTree.type===\"Identifier\"){\n                //Best be strict about it from the beginning an Identifier is always expected to be \n                //a reference to another variable\n\n            } else\n            if(parseTree.type===\"Literal\"){\n                //there's only a string present, figure out if it's a reference to a variable or a string\n            } else \n            if ((parseTree.left.type === 'Literal') && (parseTree.right.type === 'Literal')) {\n                return eval(expr);\n            }\n            else {\n                // there are still strings in the expression, which are unknown\n                // evaluate with values that the parseTreeProvides\n                return  eval(`${parseTree.left.value}${parseTree.operator}${parseTree.right.value}`);\n                //an exception should be raised\n                // throw 'unknown identifiers in expression : ' + expr;\n            }\n        } catch (e) {\n            console.error('parse error:', e);\n        }\n    }\n    replaceExpressionIdentifiersWithValues(expression, memoryElement) {\n\n\n        let memory = this.getMemory() || memoryElement;\n        let result = expression.toUpperCase();\n\n        let originalIdentifiers = Object.keys(memory.getDataDump());\n        let upperCaseIdentifiers = originalIdentifiers.map(s => s.toUpperCase());\n        for (let i in originalIdentifiers) {\n            let value = memory.getData(originalIdentifiers[i]);\n            let finalValue = parseInt(value);\n            if (finalValue != value) {\n                if (value === 'null') { finalValue = 'null'; }\n                else if (value === 'true') { finalValue = 'true'; }\n                else if (value === 'false') { finalValue = 'false'; }\n                else finalValue = `\"${value}\"`;\n            }\n            let r = new RegExp(upperCaseIdentifiers[i], 'g');\n            result = result.replace(r, finalValue);\n        }\n        return result;\n    }\n\n\n}\n\nBaseElement.registerAAElement('aa-variable', AAVariable);\n\n","// import '../dist/paper-polymer.js';\nimport BaseElement from './customElements/aa-baseElement/baseElement.js';\nimport AAAffectGrid from './customElements/aa-affect-grid/aa-affect-grid.js';\nimport AACheckboxes from './customElements/aa-checkboxes/aa-checkboxes.js';\nimport AAChoose from './customElements/aa-choose/aa-choose.js';\nimport AAChoiceItem from './customElements/aa-choice-item/aa-choice-item.js';\nimport AAFunctionRandom from './customElements/aa-function/aa-function-random.js';\nimport AAGeoLocation from './customElements/aa-geolocation/aa-geolocation.js';\nimport AALabel from './customElements/aa-label/aa-label.js';\nimport AALikertScale from './customElements/aa-likert-scale/aa-likert-scale.js';\nimport AAMemory from './customElements/aa-memory/aa-memory.js';\nimport AAMultipleChoice from './customElements/aa-multiple-choice/aa-multiple-choice.js';\nimport AAOtherwise from './customElements/aa-choose/aa-otherwise/aa-otherwise.js';\nimport AAScreen from './customElements/aa-screen/aa-screen.js';\nimport AASession from './customElements/aa-session/aa-session.js';\nimport AASequence from './customElements/aa-sequence/aa-sequence.js';\nimport AASlider from './customElements/aa-slider/aa-slider.js';\nimport AATextAnswer from './customElements/aa-text-answer/aa-text-answer.js';\nimport AAVariable from './customElements/aa-variable/aa-variable.js';\nimport AAWhen from './customElements/aa-choose/aa-when/aa-when.js';\n\n\n\n\n\n\nexport {\n    BaseElement, AAAffectGrid, AACheckboxes, AAChoose, \n    AAChoiceItem, AAFunctionRandom, AAGeoLocation, AALabel, \n    AALikertScale, AAMemory, AAMultipleChoice, AAOtherwise, \n    AAScreen, AASession, AASequence, AASlider, AATextAnswer, \n    AAVariable, AAWhen\n}","\nexport function nodeToJSL(node) {\n\n    if ((node.nodeType === document.TEXT_NODE)||(node.nodeType === document.COMMENT_NODE)) {\n        let result = node.textContent.replace(/\\n/g, ' ').replace(/\\t/g, ' ').replace(/\\s\\s+/g, ' ').trim();\n        if (result === '') {\n            return undefined;\n        } else { return `\"${result}\"`; }\n\n    } else {\n\n        \n        let attrNames = node.getAttributeNames();\n        let attrObj = {};\n        for (let i = 0; i < attrNames.length; i++) {\n            if (node.getAttribute(attrNames[i]) !== 'undefined') {\n                attrObj[attrNames[i]] = node.getAttribute(attrNames[i]);\n            }\n        }\n\n        let argsStrings = [];\n        for (let i = 0; i < node.childNodes.length; i++) {\n            let addition = nodeToJSL(node.childNodes[i]);\n            if (addition) {\n                argsStrings.push(nodeToJSL(node.childNodes[i]));\n\n            }\n        }\n\n        let tagName = node.tagName.replace(/\\-/g, '_');\n        return formatJSLResult(tagName, attrObj, argsStrings);\n\n    }\n\n}\n\n\n\nfunction tab(s) {\n    let result = s.replace(/\\n/g, '\\n\\t');\n    if (result[0] !== '\\n') { result = `\\t${result}`; }\n    return result;\n}\n\n\nfunction getAttrsAsString(attrObj) {\n\n    let keys = Object.keys(attrObj);\n    if(keys.length>3){\n        return JSON.stringify(attrObj, null, 2)\n    }else {\n        return JSON.stringify(attrObj);\n    }\n}\n\nfunction getArgsString(argsStrings) {\n    let result = '';\n    for (let i = 0; i < argsStrings.length; i++) {\n        result += `${argsStrings[i]}`;\n        if (i !== argsStrings.length - 1) {result += ',\\n';}\n    }\n    return result;\n}\n\nexport function formatJSLResult(tagName, attrObj, argsStrings) {\n    let attrs = getAttrsAsString(attrObj);\n    let args = getArgsString(argsStrings);\n    let isArgsMultiline = /\\n/.test(args);\n\n    //decide if newline for attributes:\n    let attrParam;\n    let newLineForAttrs = false;\n    //do they exist\n    let attrsExist = attrs !== '{}';\n    if (attrsExist) {\n        //do they contain newlines\n        if (attrs.indexOf('\\n') != -1) {\n            newLineForAttrs = true;\n        } else {\n            //are they long\n            if (attrs.length > 50) {\n                newLineForAttrs = true;\n            }\n        }\n        if (newLineForAttrs) {\n            attrParam = `\\n${tab(attrs)}${argsStrings.length ? ',' : ''}`;\n        }\n        else {\n            attrParam = `${attrs}${argsStrings.length ? ',' : ''}`;\n        }\n\n    } else {\n        //attributes don't exist;\n        attrParam = '';\n    }\n    // let argsParam;\n    // let newLineForArgs = false;\n    let result = `${tagName}( ${attrParam}${isArgsMultiline ? `\\n${tab(args)}\\n` : `${attrsExist ? ' ' : ''}${args}`} )`;\n    return result;\n}\n","/**\r\n * this is a modified version of the original jsep \r\n * which if the root parameter is undefined,\r\n * the jsep object returned so as to be exported   \r\n **/ \r\n\r\n\r\n//     JavaScript Expression Parser (JSEP) 0.3.4\r\n//     JSEP may be freely distributed under the MIT License\r\n//     http://jsep.from.so/\r\n\r\n/*global module: true, exports: true, console: true */\r\nexport default (function (root) {\r\n\t'use strict';\r\n\t// Node Types\r\n\t// ----------\r\n\t\r\n\t// This is the full set of types that any JSEP node can be.\r\n\t// Store them here to save space when minified\r\n\tvar COMPOUND = 'Compound',\r\n\t\tIDENTIFIER = 'Identifier',\r\n\t\tMEMBER_EXP = 'MemberExpression',\r\n\t\tLITERAL = 'Literal',\r\n\t\tTHIS_EXP = 'ThisExpression',\r\n\t\tCALL_EXP = 'CallExpression',\r\n\t\tUNARY_EXP = 'UnaryExpression',\r\n\t\tBINARY_EXP = 'BinaryExpression',\r\n\t\tLOGICAL_EXP = 'LogicalExpression',\r\n\t\tCONDITIONAL_EXP = 'ConditionalExpression',\r\n\t\tARRAY_EXP = 'ArrayExpression',\r\n\r\n\t\tPERIOD_CODE = 46, // '.'\r\n\t\tCOMMA_CODE  = 44, // ','\r\n\t\tSQUOTE_CODE = 39, // single quote\r\n\t\tDQUOTE_CODE = 34, // double quotes\r\n\t\tOPAREN_CODE = 40, // (\r\n\t\tCPAREN_CODE = 41, // )\r\n\t\tOBRACK_CODE = 91, // [\r\n\t\tCBRACK_CODE = 93, // ]\r\n\t\tQUMARK_CODE = 63, // ?\r\n\t\tSEMCOL_CODE = 59, // ;\r\n\t\tCOLON_CODE  = 58, // :\r\n\r\n\t\tthrowError = function(message, index) {\r\n\t\t\tvar error = new Error(message + ' at character ' + index);\r\n\t\t\terror.index = index;\r\n\t\t\terror.description = message;\r\n\t\t\tthrow error;\r\n\t\t},\r\n\r\n\t// Operations\r\n\t// ----------\r\n\r\n\t// Set `t` to `true` to save space (when minified, not gzipped)\r\n\t\tt = true,\r\n\t// Use a quickly-accessible map to store all of the unary operators\r\n\t// Values are set to `true` (it really doesn't matter)\r\n\t\tunary_ops = {'-': t, '!': t, '~': t, '+': t},\r\n\t// Also use a map for the binary operations but set their values to their\r\n\t// binary precedence for quick reference:\r\n\t// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\r\n\t\tbinary_ops = {\r\n\t\t\t'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,\r\n\t\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\r\n\t\t\t'<': 7,  '>': 7,  '<=': 7,  '>=': 7,\r\n\t\t\t'<<':8,  '>>': 8, '>>>': 8,\r\n\t\t\t'+': 9, '-': 9,\r\n\t\t\t'*': 10, '/': 10, '%': 10\r\n\t\t},\r\n\t// Get return the longest key length of any object\r\n\t\tgetMaxKeyLen = function(obj) {\r\n\t\t\tvar max_len = 0, len;\r\n\t\t\tfor(var key in obj) {\r\n\t\t\t\tif((len = key.length) > max_len && obj.hasOwnProperty(key)) {\r\n\t\t\t\t\tmax_len = len;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn max_len;\r\n\t\t},\r\n\t\tmax_unop_len = getMaxKeyLen(unary_ops),\r\n\t\tmax_binop_len = getMaxKeyLen(binary_ops),\r\n\t// Literals\r\n\t// ----------\r\n\t// Store the values to return for the various literals we may encounter\r\n\t\tliterals = {\r\n\t\t\t'true': true,\r\n\t\t\t'false': false,\r\n\t\t\t'null': null\r\n\t\t},\r\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\r\n\t\tthis_str = 'this',\r\n\t// Returns the precedence of a binary operator or `0` if it isn't a binary operator\r\n\t\tbinaryPrecedence = function(op_val) {\r\n\t\t\treturn binary_ops[op_val] || 0;\r\n\t\t},\r\n\t// Utility function (gets called from multiple places)\r\n\t// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\r\n\t\tcreateBinaryExpression = function (operator, left, right) {\r\n\t\t\tvar type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;\r\n\t\t\treturn {\r\n\t\t\t\ttype: type,\r\n\t\t\t\toperator: operator,\r\n\t\t\t\tleft: left,\r\n\t\t\t\tright: right\r\n\t\t\t};\r\n\t\t},\r\n\t\t// `ch` is a character code in the next three functions\r\n\t\tisDecimalDigit = function(ch) {\r\n\t\t\treturn (ch >= 48 && ch <= 57); // 0...9\r\n\t\t},\r\n\t\tisIdentifierStart = function(ch) {\r\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\r\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\r\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\r\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\r\n\t\t},\r\n\t\tisIdentifierPart = function(ch) {\r\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\r\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\r\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\r\n\t\t\t\t\t(ch >= 48 && ch <= 57) || // 0...9\r\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\r\n\t\t},\r\n\r\n\t\t// Parsing\r\n\t\t// -------\r\n\t\t// `expr` is a string with the passed in expression\r\n\t\tjsep = function(expr) {\r\n\t\t\t// `index` stores the character number we are currently at while `length` is a constant\r\n\t\t\t// All of the gobbles below will modify `index` as we move along\r\n\t\t\tvar index = 0,\r\n\t\t\t\tcharAtFunc = expr.charAt,\r\n\t\t\t\tcharCodeAtFunc = expr.charCodeAt,\r\n\t\t\t\texprI = function(i) { return charAtFunc.call(expr, i); },\r\n\t\t\t\texprICode = function(i) { return charCodeAtFunc.call(expr, i); },\r\n\t\t\t\tlength = expr.length,\r\n\r\n\t\t\t\t// Push `index` up to the next non-space character\r\n\t\t\t\tgobbleSpaces = function() {\r\n\t\t\t\t\tvar ch = exprICode(index);\r\n\t\t\t\t\t// space or tab\r\n\t\t\t\t\twhile(ch === 32 || ch === 9 || ch === 10 || ch === 13) {\r\n\t\t\t\t\t\tch = exprICode(++index);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// The main parsing function. Much of this code is dedicated to ternary expressions\r\n\t\t\t\tgobbleExpression = function() {\r\n\t\t\t\t\tvar test = gobbleBinaryExpression(),\r\n\t\t\t\t\t\tconsequent, alternate;\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tif(exprICode(index) === QUMARK_CODE) {\r\n\t\t\t\t\t\t// Ternary expression: test ? consequent : alternate\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\tconsequent = gobbleExpression();\r\n\t\t\t\t\t\tif(!consequent) {\r\n\t\t\t\t\t\t\tthrowError('Expected expression', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tif(exprICode(index) === COLON_CODE) {\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t\talternate = gobbleExpression();\r\n\t\t\t\t\t\t\tif(!alternate) {\r\n\t\t\t\t\t\t\t\tthrowError('Expected expression', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\ttype: CONDITIONAL_EXP,\r\n\t\t\t\t\t\t\t\ttest: test,\r\n\t\t\t\t\t\t\t\tconsequent: consequent,\r\n\t\t\t\t\t\t\t\talternate: alternate\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrowError('Expected :', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn test;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Search for the operation portion of the string (e.g. `+`, `===`)\r\n\t\t\t\t// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\r\n\t\t\t\t// and move down from 3 to 2 to 1 character until a matching binary operation is found\r\n\t\t\t\t// then, return that binary operation\r\n\t\t\t\tgobbleBinaryOp = function() {\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tvar  to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;\r\n\t\t\t\t\twhile(tc_len > 0) {\r\n\t\t\t\t\t\t// Don't accept a binary op when it is an identifier.\r\n\t\t\t\t\t\t// Binary ops that start with a identifier-valid character must be followed\r\n\t\t\t\t\t\t// by a non identifier-part valid character\r\n\t\t\t\t\t\tif(binary_ops.hasOwnProperty(to_check) && (\r\n\t\t\t\t\t\t\t!isIdentifierStart(exprICode(index)) ||\r\n\t\t\t\t\t\t\t(index+to_check.length< expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\r\n\t\t\t\t\t\t)) {\r\n\t\t\t\t\t\t\tindex += tc_len;\r\n\t\t\t\t\t\t\treturn to_check;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// This function is responsible for gobbling an individual expression,\r\n\t\t\t\t// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\r\n\t\t\t\tgobbleBinaryExpression = function() {\r\n\t\t\t\t\tvar node, biop, prec, stack, biop_info, left, right, i;\r\n\r\n\t\t\t\t\t// First, try to get the leftmost thing\r\n\t\t\t\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\r\n\t\t\t\t\tleft = gobbleToken();\r\n\t\t\t\t\tbiop = gobbleBinaryOp();\r\n\r\n\t\t\t\t\t// If there wasn't a binary operator, just return the leftmost node\r\n\t\t\t\t\tif(!biop) {\r\n\t\t\t\t\t\treturn left;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\r\n\t\t\t\t\t// precedence structure\r\n\t\t\t\t\tbiop_info = { value: biop, prec: binaryPrecedence(biop)};\r\n\r\n\t\t\t\t\tright = gobbleToken();\r\n\t\t\t\t\tif(!right) {\r\n\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstack = [left, biop_info, right];\r\n\r\n\t\t\t\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\r\n\t\t\t\t\twhile((biop = gobbleBinaryOp())) {\r\n\t\t\t\t\t\tprec = binaryPrecedence(biop);\r\n\r\n\t\t\t\t\t\tif(prec === 0) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbiop_info = { value: biop, prec: prec };\r\n\r\n\t\t\t\t\t\t// Reduce: make a binary expression from the three topmost entries.\r\n\t\t\t\t\t\twhile ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\r\n\t\t\t\t\t\t\tright = stack.pop();\r\n\t\t\t\t\t\t\tbiop = stack.pop().value;\r\n\t\t\t\t\t\t\tleft = stack.pop();\r\n\t\t\t\t\t\t\tnode = createBinaryExpression(biop, left, right);\r\n\t\t\t\t\t\t\tstack.push(node);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnode = gobbleToken();\r\n\t\t\t\t\t\tif(!node) {\r\n\t\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstack.push(biop_info, node);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ti = stack.length - 1;\r\n\t\t\t\t\tnode = stack[i];\r\n\t\t\t\t\twhile(i > 1) {\r\n\t\t\t\t\t\tnode = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);\r\n\t\t\t\t\t\ti -= 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// An individual part of a binary expression:\r\n\t\t\t\t// e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\r\n\t\t\t\tgobbleToken = function() {\r\n\t\t\t\t\tvar ch, to_check, tc_len;\r\n\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tch = exprICode(index);\r\n\r\n\t\t\t\t\tif(isDecimalDigit(ch) || ch === PERIOD_CODE) {\r\n\t\t\t\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\r\n\t\t\t\t\t\treturn gobbleNumericLiteral();\r\n\t\t\t\t\t} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\r\n\t\t\t\t\t\t// Single or double quotes\r\n\t\t\t\t\t\treturn gobbleStringLiteral();\r\n\t\t\t\t\t} else if (ch === OBRACK_CODE) {\r\n\t\t\t\t\t\treturn gobbleArray();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tto_check = expr.substr(index, max_unop_len);\r\n\t\t\t\t\t\ttc_len = to_check.length;\r\n\t\t\t\t\t\twhile(tc_len > 0) {\r\n\t\t\t\t\t\t// Don't accept an unary op when it is an identifier.\r\n\t\t\t\t\t\t// Unary ops that start with a identifier-valid character must be followed\r\n\t\t\t\t\t\t// by a non identifier-part valid character\r\n\t\t\t\t\t\t\tif(unary_ops.hasOwnProperty(to_check) && (\r\n\t\t\t\t\t\t\t\t!isIdentifierStart(exprICode(index)) ||\r\n\t\t\t\t\t\t\t\t(index+to_check.length < expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\r\n\t\t\t\t\t\t\t)) {\r\n\t\t\t\t\t\t\t\tindex += tc_len;\r\n\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\ttype: UNARY_EXP,\r\n\t\t\t\t\t\t\t\t\toperator: to_check,\r\n\t\t\t\t\t\t\t\t\targument: gobbleToken(),\r\n\t\t\t\t\t\t\t\t\tprefix: true\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis\r\n\t\t\t\t\t\t\t// `foo`, `bar.baz`\r\n\t\t\t\t\t\t\treturn gobbleVariable();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t},\r\n\t\t\t\t// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\r\n\t\t\t\t// keep track of everything in the numeric literal and then calling `parseFloat` on that string\r\n\t\t\t\tgobbleNumericLiteral = function() {\r\n\t\t\t\t\tvar number = '', ch, chCode;\r\n\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\r\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tch = exprI(index);\r\n\t\t\t\t\tif(ch === 'e' || ch === 'E') { // exponent marker\r\n\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\tch = exprI(index);\r\n\t\t\t\t\t\tif(ch === '+' || ch === '-') { // exponent sign\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) { //exponent itself\r\n\t\t\t\t\t\t\tnumber += exprI(index++);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(!isDecimalDigit(exprICode(index-1)) ) {\r\n\t\t\t\t\t\t\tthrowError('Expected exponent (' + number + exprI(index) + ')', index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tchCode = exprICode(index);\r\n\t\t\t\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\r\n\t\t\t\t\tif(isIdentifierStart(chCode)) {\r\n\t\t\t\t\t\tthrowError('Variable names cannot start with a number (' +\r\n\t\t\t\t\t\t\t\t\tnumber + exprI(index) + ')', index);\r\n\t\t\t\t\t} else if(chCode === PERIOD_CODE) {\r\n\t\t\t\t\t\tthrowError('Unexpected period', index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\tvalue: parseFloat(number),\r\n\t\t\t\t\t\traw: number\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Parses a string literal, staring with single or double quotes with basic support for escape codes\r\n\t\t\t\t// e.g. `\"hello world\"`, `'this is\\nJSEP'`\r\n\t\t\t\tgobbleStringLiteral = function() {\r\n\t\t\t\t\tvar str = '', quote = exprI(index++), closed = false, ch;\r\n\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tch = exprI(index++);\r\n\t\t\t\t\t\tif(ch === quote) {\r\n\t\t\t\t\t\t\tclosed = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else if(ch === '\\\\') {\r\n\t\t\t\t\t\t\t// Check for all of the common escape codes\r\n\t\t\t\t\t\t\tch = exprI(index++);\r\n\t\t\t\t\t\t\tswitch(ch) {\r\n\t\t\t\t\t\t\t\tcase 'n': str += '\\n'; break;\r\n\t\t\t\t\t\t\t\tcase 'r': str += '\\r'; break;\r\n\t\t\t\t\t\t\t\tcase 't': str += '\\t'; break;\r\n\t\t\t\t\t\t\t\tcase 'b': str += '\\b'; break;\r\n\t\t\t\t\t\t\t\tcase 'f': str += '\\f'; break;\r\n\t\t\t\t\t\t\t\tcase 'v': str += '\\x0B'; break;\r\n\t\t\t\t\t\t\t\tdefault : str += ch;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstr += ch;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(!closed) {\r\n\t\t\t\t\t\tthrowError('Unclosed quote after \"'+str+'\"', index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\tvalue: str,\r\n\t\t\t\t\t\traw: quote + str + quote\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobbles only identifiers\r\n\t\t\t\t// e.g.: `foo`, `_value`, `$x1`\r\n\t\t\t\t// Also, this function checks if that identifier is a literal:\r\n\t\t\t\t// (e.g. `true`, `false`, `null`) or `this`\r\n\t\t\t\tgobbleIdentifier = function() {\r\n\t\t\t\t\tvar ch = exprICode(index), start = index, identifier;\r\n\r\n\t\t\t\t\tif(isIdentifierStart(ch)) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrowError('Unexpected ' + exprI(index), index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tch = exprICode(index);\r\n\t\t\t\t\t\tif(isIdentifierPart(ch)) {\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tidentifier = expr.slice(start, index);\r\n\r\n\t\t\t\t\tif(literals.hasOwnProperty(identifier)) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttype: LITERAL,\r\n\t\t\t\t\t\t\tvalue: literals[identifier],\r\n\t\t\t\t\t\t\traw: identifier\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else if(identifier === this_str) {\r\n\t\t\t\t\t\treturn { type: THIS_EXP };\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttype: IDENTIFIER,\r\n\t\t\t\t\t\t\tname: identifier\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobbles a list of arguments within the context of a function call\r\n\t\t\t\t// or array literal. This function also assumes that the opening character\r\n\t\t\t\t// `(` or `[` has already been gobbled, and gobbles expressions and commas\r\n\t\t\t\t// until the terminator character `)` or `]` is encountered.\r\n\t\t\t\t// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\r\n\t\t\t\tgobbleArguments = function(termination) {\r\n\t\t\t\t\tvar ch_i, args = [], node, closed = false;\r\n\t\t\t\t\twhile(index < length) {\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t\tif(ch_i === termination) { // done parsing\r\n\t\t\t\t\t\t\tclosed = true;\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else if (ch_i === COMMA_CODE) { // between expressions\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnode = gobbleExpression();\r\n\t\t\t\t\t\t\tif(!node || node.type === COMPOUND) {\r\n\t\t\t\t\t\t\t\tthrowError('Expected comma', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\targs.push(node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!closed) {\r\n\t\t\t\t\t\tthrowError('Expected ' + String.fromCharCode(termination), index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn args;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Gobble a non-literal variable name. This variable name may include properties\r\n\t\t\t\t// e.g. `foo`, `bar.baz`, `foo['bar'].baz`\r\n\t\t\t\t// It also gobbles function calls:\r\n\t\t\t\t// e.g. `Math.acos(obj.angle)`\r\n\t\t\t\tgobbleVariable = function() {\r\n\t\t\t\t\tvar ch_i, node;\r\n\t\t\t\t\tch_i = exprICode(index);\r\n\r\n\t\t\t\t\tif(ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\tnode = gobbleGroup();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode = gobbleIdentifier();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\twhile(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\tif(ch_i === PERIOD_CODE) {\r\n\t\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\r\n\t\t\t\t\t\t\t\tcomputed: false,\r\n\t\t\t\t\t\t\t\tobject: node,\r\n\t\t\t\t\t\t\t\tproperty: gobbleIdentifier()\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t} else if(ch_i === OBRACK_CODE) {\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\r\n\t\t\t\t\t\t\t\tcomputed: true,\r\n\t\t\t\t\t\t\t\tobject: node,\r\n\t\t\t\t\t\t\t\tproperty: gobbleExpression()\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t\t\tif(ch_i !== CBRACK_CODE) {\r\n\t\t\t\t\t\t\t\tthrowError('Unclosed [', index);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\t} else if(ch_i === OPAREN_CODE) {\r\n\t\t\t\t\t\t\t// A function call is being made; gobble all the arguments\r\n\t\t\t\t\t\t\tnode = {\r\n\t\t\t\t\t\t\t\ttype: CALL_EXP,\r\n\t\t\t\t\t\t\t\t'arguments': gobbleArguments(CPAREN_CODE),\r\n\t\t\t\t\t\t\t\tcallee: node\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\t\tch_i = exprICode(index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Responsible for parsing a group of things within parentheses `()`\r\n\t\t\t\t// This function assumes that it needs to gobble the opening parenthesis\r\n\t\t\t\t// and then tries to gobble everything within that parenthesis, assuming\r\n\t\t\t\t// that the next thing it should see is the close parenthesis. If not,\r\n\t\t\t\t// then the expression probably doesn't have a `)`\r\n\t\t\t\tgobbleGroup = function() {\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t\tvar node = gobbleExpression();\r\n\t\t\t\t\tgobbleSpaces();\r\n\t\t\t\t\tif(exprICode(index) === CPAREN_CODE) {\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t\treturn node;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrowError('Unclosed (', index);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// Responsible for parsing Array literals `[1, 2, 3]`\r\n\t\t\t\t// This function assumes that it needs to gobble the opening bracket\r\n\t\t\t\t// and then tries to gobble the expressions as arguments.\r\n\t\t\t\tgobbleArray = function() {\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: ARRAY_EXP,\r\n\t\t\t\t\t\telements: gobbleArguments(CBRACK_CODE)\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\r\n\t\t\t\tnodes = [], ch_i, node;\r\n\r\n\t\t\twhile(index < length) {\r\n\t\t\t\tch_i = exprICode(index);\r\n\r\n\t\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\r\n\t\t\t\t// separators\r\n\t\t\t\tif(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\r\n\t\t\t\t\tindex++; // ignore separators\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Try to gobble each expression individually\r\n\t\t\t\t\tif((node = gobbleExpression())) {\r\n\t\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\r\n\t\t\t\t\t// the expression passed in probably has too much\r\n\t\t\t\t\t} else if(index < length) {\r\n\t\t\t\t\t\tthrowError('Unexpected \"' + exprI(index) + '\"', index);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If there's only one expression just try returning the expression\r\n\t\t\tif(nodes.length === 1) {\r\n\t\t\t\treturn nodes[0];\r\n\t\t\t} else {\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: COMPOUND,\r\n\t\t\t\t\tbody: nodes\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t// To be filled in by the template\r\n\tjsep.version = '0.3.4';\r\n\tjsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };\r\n\r\n\t/**\r\n\t * @method jsep.addUnaryOp\r\n\t * @param {string} op_name The name of the unary op to add\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addUnaryOp = function(op_name) {\r\n\t\tmax_unop_len = Math.max(op_name.length, max_unop_len);\r\n\t\tunary_ops[op_name] = t; return this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.addBinaryOp\r\n\t * @param {string} op_name The name of the binary op to add\r\n\t * @param {number} precedence The precedence of the binary op (can be a float)\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addBinaryOp = function(op_name, precedence) {\r\n\t\tmax_binop_len = Math.max(op_name.length, max_binop_len);\r\n\t\tbinary_ops[op_name] = precedence;\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.addLiteral\r\n\t * @param {string} literal_name The name of the literal to add\r\n\t * @param {*} literal_value The value of the literal\r\n\t * @return jsep\r\n\t */\r\n\tjsep.addLiteral = function(literal_name, literal_value) {\r\n\t\tliterals[literal_name] = literal_value;\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeUnaryOp\r\n\t * @param {string} op_name The name of the unary op to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeUnaryOp = function(op_name) {\r\n\t\tdelete unary_ops[op_name];\r\n\t\tif(op_name.length === max_unop_len) {\r\n\t\t\tmax_unop_len = getMaxKeyLen(unary_ops);\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllUnaryOps\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllUnaryOps = function() {\r\n\t\tunary_ops = {};\r\n\t\tmax_unop_len = 0;\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeBinaryOp\r\n\t * @param {string} op_name The name of the binary op to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeBinaryOp = function(op_name) {\r\n\t\tdelete binary_ops[op_name];\r\n\t\tif(op_name.length === max_binop_len) {\r\n\t\t\tmax_binop_len = getMaxKeyLen(binary_ops);\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllBinaryOps\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllBinaryOps = function() {\r\n\t\tbinary_ops = {};\r\n\t\tmax_binop_len = 0;\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeLiteral\r\n\t * @param {string} literal_name The name of the literal to remove\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeLiteral = function(literal_name) {\r\n\t\tdelete literals[literal_name];\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\t * @method jsep.removeAllLiterals\r\n\t * @return jsep\r\n\t */\r\n\tjsep.removeAllLiterals = function() {\r\n\t\tliterals = {};\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// In desktop environments, have a way to restore the old value for `jsep`\r\n\tif (typeof exports === 'undefined') {\r\n\r\n\t\tif(!root){\r\n\t\t\treturn  jsep;\r\n\t\t}\r\n\t\tvar old_jsep = root.jsep;\r\n\t\t// The star of the show! It's a function!\r\n\t\troot.jsep = jsep;\r\n\t\t// And a courteous function willing to move out of the way for other similarly-named objects!\r\n\t\tjsep.noConflict = function() {\r\n\t\t\tif(root.jsep === jsep) {\r\n\t\t\t\troot.jsep = old_jsep;\r\n\t\t\t}\r\n\t\t\treturn jsep;\r\n\t\t};\r\n\t} else {\r\n\t\t// In Node.JS environments\r\n\t\tif (typeof module !== 'undefined' && module.exports) {\r\n\t\t\texports = module.exports = jsep;\r\n\t\t} else {\r\n\t\t\texports.parse = jsep;\r\n\t\t}\r\n\t}\r\n}(this));\r\n","import SVG from '../svg/svg.js';\nimport jsep from '../../lib/jsep/jsep.js';\n\n\n\nclass Container {\n\n\n    x(v) {\n        if (typeof v !== 'undefined') {\n            this._x = v;\n            this.group.x(v);\n        } else {\n            return this.group.x();\n        }\n    }\n\n    y(v) {\n        if (typeof v !== 'undefined') {\n            this._y = v;\n            this.group.y(v);\n        } else {\n            return this.group.y();\n        }\n    }\n\n    dy(v) {\n        if (typeof v !== 'undefined') {\n            this._y += v;\n            this.group.dy(v);\n        } else {\n            return this._y;\n        }\n    }\n\n    getItemStartPoints(item) {\n\n        if (item.noStartPoints) return [];\n        if (item.getStartPoints) {\n            return item.getStartPoints();\n        } else {\n\n            return [[item.x(), item.y() + item.height() / 2]];\n        }\n    }\n\n\n    getItemEndPoints(item) {\n        if (item.getEndPointsFrom) {\n            item = item.getEndPointsFrom;\n        }\n        if (item.noEndPoints) return [];\n        if (item.getEndPoints) {\n            return item.getEndPoints();\n        } else {\n            return [[item.x() + item.width(), item.y() + item.height() / 2]];\n        }\n    }\n\n    getStartPoints() {\n        if (this.noStartPoints) return [];\n        switch (this.type) {\n            case 'serial':\n                if (this.c.length) {\n                    let firstItem = this.c[0];\n                    return this.getItemStartPoints(firstItem);\n                } else {\n                    return [];\n                }\n\n\n            case 'parallel': {\n\n                let points = [];\n                for (let i = 0; i < this.c.length; i++) {\n                    points = points.concat(this.getItemStartPoints(this.c[i]));\n                }\n                return points;\n            }\n\n        }\n    }\n\n    getEndPoints() {\n        if (this.noEndPoints) return [];\n        switch (this.type) {\n            case 'serial':\n                if (this.c.length) {\n                    let lastItem = this.c[this.c.length - 1];\n                    return this.getItemEndPoints(lastItem);\n                } else {\n                    return [];\n                }\n\n\n            case 'parallel': {\n                let points = [];\n                for (let i = 0; i < this.c.length; i++) {\n                    points = points.concat(this.getItemEndPoints(this.c[i]));\n                }\n                return points;\n\n            }\n\n        }\n    }\n\n\n    width(v) {\n        if (typeof v === 'undefined') {\n\n            return this.group.width();\n        }\n    }\n\n\n    height(v) {\n        if (typeof v === 'undefined') {\n            return this.group.height();\n        }\n    }\n\n\n    addTo(svgjs) {\n        this.group.addTo(svgjs);\n        return this;\n    }\n\n\n\n\n    constructor(type, node) {\n        this.gap = 30;\n        this.c = [];\n\n\n        this.type = type;\n        this.myNode = node;\n        this.group = SVG().group();\n    }\n\n    push(item) {\n\n        switch (this.type) {\n\n            case 'serial':\n                if (this.c.length) {\n                    item.x(this.c[this.c.length - 1].x() + this.c[this.c.length - 1].width() + this.gap)\n                } else {\n                    item.x(10);\n                }\n                item.y(10);\n                this.c.push(item);\n\n\n\n                //now ensure everything is centered on the x axis\n                let yCenter = 0\n                for (let i = 0; i < this.c.length; i++) {\n                    yCenter = Math.max(yCenter, this.c[i].height() / 2)\n                }\n                for (let i = 0; i < this.c.length; i++) {\n                    this.c[i].y(yCenter - this.c[i].height() / 2)\n                }\n\n\n                break;\n            case 'parallel':\n                if (this.c.length) {\n\n                    let y = this.c[this.c.length - 1].y() + this.c[this.c.length - 1].height() + this.gap\n                    item.y(y);\n                } else {\n                    item.y(10);\n                }\n                item.x(10);\n                this.c.push(item);\n                break;\n        }\n        if (item instanceof Container) {\n            item.group.addTo(this.group)\n        } else {\n            item.addTo(this.group);\n        }\n\n    }\n\n\n\n    makeLines(endPoints, startPoints) {\n\n        let lines = SVG().group();\n        for (let i = 0; i < endPoints.length; i++) {\n            for (let j = 0; j < startPoints.length; j++) {\n                let p1 = endPoints[i];\n                let p2 = startPoints[j];\n                let offset = - 1;\n                let path = mySVG.bezier(p1[0], p1[1], p2[0], p2[1], offset);\n                if (this.strokeDashArray) path.attr({ 'stroke-dasharray': this.strokeDashArray, });\n                if ((this.type == 'serial') && !(this.strokeDashArray)) path.attr({ 'marker-end': 'url(#arrow)' });\n                // path.addTo(draw);\n                path.addTo(lines);\n\n            }\n        }\n        return lines;\n    }\n\n    renderLines() {\n\n\n        let lines = SVG().group();\n\n        for (let i = 0; i < this.c.length - 1; i++) {\n\n            if (this.c[i] instanceof Container) {\n                let l = this.c[i].renderLines();\n                l.addTo(lines);\n            }\n            if (this.type === 'serial') {\n                let endPoints = this.getItemEndPoints(this.c[i]);\n                let startPoints = this.getItemStartPoints(this.c[i + 1]);\n\n                let l = this.makeLines(endPoints, startPoints);\n                if (l) { l.addTo(lines); }\n\n            }\n        }\n        if (this.c[this.c.length - 1] instanceof Container) {\n            let l = this.c[this.c.length - 1].renderLines();\n            l.addTo(lines);\n        }\n\n\n        return lines;\n\n    }\n\n    applyItemsAfterwards() {\n\n\n        // if(this.applyItemsAfterwards){\n        //     this.applyItemsAfterwards();\n        // }\n\n        if (this.group.applyItemsAfterwards) {\n\n            this.group.applyItemsAfterwards();\n\n        }\n\n        //check also the children\n        for (let i = 0; i < this.c.length; i++) {\n\n            if (this.c[i].applyItemsAfterwards) {\n\n                this.c[i].applyItemsAfterwards();\n            }\n        }\n    }\n\n\n    breakLine() {\n        switch (this.type) {\n            case 'serial':\n\n                for (let i = 0; i < c.length - 1; i++) {\n                    w += c[i].width() + this.gap;\n                }\n                w += c[c.length - 1].width();\n                return w;\n\n            case 'parallel':\n\n            //find the longest member amd break it, then break others progressively\n        }\n    }\n\n\n\n}\n\nclass mySVG {\n\n\n\n\n    model(node) {\n\n        if (!node) return;\n\n\n        if (Object.keys(this.modellingFunctions).indexOf(node.nodeName) === -1) {\n            return;\n        }\n        if (this.elementsFound.indexOf(node.nodeName) == -1) {\n            this.elementsFound.push(node.nodeName);\n        }\n        return this.modellingFunctions[node.nodeName](node);\n    }\n\n    constructor() {\n\n        this.elementsFound = [];\n\n\n    }\n    render(node) {\n\n        if (!node) return;\n\n        let draw = SVG();\n        let defs = SVG(\n            `<defs>\n            <marker id=\"arrow\" markerWidth=\"5\" markerHeight=\"4\" refX=\"5\" refY=\"2\" orient=\"auto\" markerUnits=\"strokeWidth\">\n              <path d=\"M0,0 L0,4 L5,2 z\" fill=\"#000\" />\n            </marker>\n          </defs>`\n        );\n        defs.addTo(draw);\n\n\n        let item = this.model(node);\n        console.log(this.elementsFound);\n\n        item.addTo(draw);\n\n        if (item.renderLines) {\n            let lines = item.renderLines();\n            lines.addTo(item.group);\n        }\n        item.x(10);\n        item.y(10);\n\n        if (item.applyItemsAfterwards) {\n            item.applyItemsAfterwards();\n        };\n\n\n        draw.node.dataset.source = encodeURIComponent(node.outerHTML.replace(/\\n/g, ' ').replace(/\\t/g, ' ').replace(/\\s\\s+/g, ' ').trim());\n        // mySVG.svg = draw.node;\n\n\n        draw.size(item.width() + 100, item.height() + 100);\n        this.svg = draw.node;\n        return draw.node;\n\n    }\n\n    renderKey() {\n\n        let group = SVG().group();\n        for (let i = 0; i < this.elementsFound.length; i++) {\n\n            let example = this.examples[this.elementsFound[i]];\n            if (!example) {\n                continue;\n            }\n\n            let el = document.createElement('div');\n\n            el.innerHTML = example.html;\n\n            let m = this.model(el);\n\n\n            // console.log(m);\n            m.addTo(group);\n            m.y(group.height() + 25);\n            if (m.renderLines) {\n\n                let lines = m.renderLines();\n                lines.addTo(m.group);\n            }\n\n        }\n        let svg = SVG().size(group.width() + 50, group.height() + 50);\n        group.x(10);\n        group.y(10);\n        group.addTo(svg);\n        return svg.node;\n    }\n\n    download(filename) {\n\n        let blob = new Blob([this.svg.outerHTML]);\n\n        let element = document.createElement(\"a\");\n        element.download = filename;\n        element.href = window.URL.createObjectURL(blob);\n        element.click();\n        element.remove();\n    }\n\n\n\n\n\n    static bezier(p1x, p1y, p2x, p2y) {\n\n        let c1x = p1x + (p2x - p1x) / 1.5;\n        let c1y = p1y;\n        let c2x = p2x - (p2x - p1x) / 1.5;\n        let c2y = p2y;\n\n        let curve = `M ${p1x},${p1y} C${c1x},${c1y} ${c2x},${c2y} ${p2x},${p2y}`;\n\n\n        let path = SVG().path(curve);\n        path.attr({ fill: 'none', stroke: 'black', 'stroke-width': 3 });\n        return path;\n    }\n\n\n    get modellingFunctions() {\n        return {\n\n\n            'AA-SESSION': (node) => {\n                let row = new Container('parallel', node);\n                for (let i = 0; i < node.originalChildNodes.length; i++) {\n\n                    let m = this.model(node.originalChildNodes[i])\n                    if (m) row.push(m);\n\n                }\n\n                row.myNode = node;\n                return row;\n\n            },\n\n\n            'AA-SEQUENCE': (node) => {\n                // let svgItem = SVG().rect(30,50).attr({fill:'none'});\n\n                let row = new Container('serial', node);\n                for (let i = 0; i < node.childNodes.length; i++) {\n\n                    let m = this.model(node.childNodes[i])\n                    if (m) row.push(m)\n                }\n\n                row.myNode = node;\n                return row;\n\n            },\n\n            'AA-SCREEN': (node) => {\n                let g = SVG().group();\n                let rect = SVG().rect(30, 50).attr({ fill: 'none', stroke: 'black', 'stroke-width': 5, rx: 3 }).addTo(g);\n                let text;\n                if (node.getAttribute('name')) {\n                    let name = node.getAttribute('name');\n\n                    if (name.length > 14) {\n                        name = name.substr(0, 11) + \"...\";\n\n                    }\n                    text = SVG().text(function (add) {\n                        add.tspan(name).font({\n                            family: 'serif',\n                            style: 'italic',\n                            size: '12px',\n                            weight: 'bold'\n                        });\n                    })\n\n\n                    // text.addTo(g);\n                    // transparentGap.addTo(g);\n                    rect.x(g.x() + g.width() / 2 - rect.width() / 2);\n                    rect.y(g.height() / 2 - rect.height() / 2) + 10;\n                    text.y(rect.y() + rect.height() + 5);\n\n\n\n                }\n                g.myNode = node;\n                g.nocentering = true;\n                g.getEndPoints = () => {\n                    return [[rect.x() + rect.width(), rect.y() + rect.height() / 2]]\n                }\n                g.getStartPoints = () => {\n                    return [[rect.x(), rect.y() + rect.height() / 2]]\n                }\n\n                if (text) {\n                    g.applyItemsAfterwards = () => {\n                        text.addTo(g);\n                        text.x(rect.x() + rect.width() / 2 - text.bbox().width / 2);\n                        text.y(rect.y() + rect.height() + 7);\n                    }\n                }\n\n                return g;\n            },\n\n            'AA-CHOOSE': (node) => {\n\n                let chooseRow = new Container('serial', node);\n                chooseRow.strokeDashArray = '3';\n\n                let chooseSVGItemStart = SVG().circle(20).attr({ fill: 'none', stroke: 'black', 'stroke-width': 5, 'stroke-dasharray': 0 });\n\n\n                // let chooseSVGItemStart = SVG().group();\n                // let pStart = SVG().circle(2).attr({ fill: 'black', stroke: 'black', 'stroke-width': 5, }).addTo(chooseSVGItemStart);\n                // let text = SVG().text(function (add) {\n                //     add.tspan('?').font({\n                //         family: 'serif',\n                //         style: 'italic',\n                //         size: '50px',\n                //         weight: 'bold'\n                //     });\n\n                // }).addTo(chooseSVGItemStart);\n                // pStart.y(chooseSVGItemStart.y() + chooseSVGItemStart.height() / 2 - pStart.height() / 2);\n                // window.pStart = pStart;\n                // window.text = text;\n                // window.g = chooseSVGItemStart;\n                // // debugger;\n\n                let chooseSVGItemEnd = SVG().circle(2).attr({ fill: 'black', stroke: 'black', 'stroke-width': 5 });\n                let contentsRow = new Container('parallel', node);\n\n\n\n                // let hasOtherwiseNode = false;\n                let maxContentWidth = 0;\n                let hasOtherwiseNode = false;\n                let lastChild;\n                for (let i = 0; i < node.childNodes.length; i++) {\n                    console.log(node.childNodes[i].nodeName);\n                    if (node.childNodes[i].nodeName === \"AA-OTHERWISE\") {\n                        hasOtherwiseNode = true;\n                    }\n\n                    let m = this.model(node.childNodes[i]);\n                    if (m) {\n                        contentsRow.push(m);\n                        maxContentWidth = Math.max(m.width(), maxContentWidth);\n                        lastChild = m\n                    }\n                }\n\n                console.log(maxContentWidth);\n                if (!hasOtherwiseNode) {\n\n                    let defaultPath = new Container('serial');\n                    let line = SVG().line();\n                    \n                    // line.addTo(defaultPath);\n                    defaultPath.push(line);\n                    line.plot(10, 100, maxContentWidth, 100);\n                    line.attr({ fill: 'black', stroke: 'black', 'stroke-dasharray': 3, 'stroke-width':3 });\n                    contentsRow.push(defaultPath);\n                    \n                    \n                }\n\n\n                //center along y axis\n                for (let i = 0; i < contentsRow.c.length; i++) {\n                    let c = contentsRow.c[i];\n                    c.x(maxContentWidth / 2 - c.width() / 2);\n                }\n\n                chooseRow.push(chooseSVGItemStart);\n                chooseRow.push(contentsRow);\n                chooseRow.push(chooseSVGItemEnd);\n\n                chooseRow.myNode = node;\n\n\n                chooseRow.applyItemsAfterwards = ()=>{\n                    for (let i = 0; i < contentsRow.c.length; i++) {\n                        console.log(contentsRow.c[i]);\n                        if(contentsRow.c[i].applyItemsAfterwards){\n                            \n                            contentsRow.c[i].applyItemsAfterwards();\n                        }\n                        \n                    }\n                }\n                return chooseRow;\n\n            },\n\n            'AA-FUNCTION-RANDOM': (node) => {\n                let item = new Container('serial', node);\n\n                let g = SVG().group();\n\n                // let rect = SVG().rect(30, 50).attr({ fill: 'none', stroke: 'red', 'stroke-width': 5 }).addTo(g);\n\n                let text = SVG().text(function (add) {\n                    add.tspan('f').font({\n                        family: 'serif',\n                        style: 'italic',\n                        size: '50px',\n                        weight: 'bold'\n                    });\n                    add.tspan('random ').font({\n                        family: 'serif',\n                        style: 'italic',\n                        size: '15px'\n                    })\n                });\n                text.addTo(g);\n                let varName = SVG().text(function (add) {\n                    add.tspan(node.getAttribute(\"name\")).font({\n                        family: 'monospace',\n                        // style: 'italic',\n                        size: '12px',\n                        weight: 'bold'\n                    });\n                });\n                varName.addTo(g);\n                varName.dy(20);\n                varName.dx(-10);\n\n\n\n\n                // let pStart = SVG().circle(2).attr({ fill: 'black', stroke: 'black', 'stroke-width': 5, }).addTo(g);\n                // let pEnd = SVG().circle(2).attr({ fill: 'black', stroke: 'black', 'stroke-width': 5, }).addTo(g);\n\n\n                item.push(g);\n\n\n\n\n                // pStart.x(0);\n                // pEnd.x(item.width());\n                // pStart.y(item.height() / 2 - pStart.height() / 2);\n                // pEnd.y(item.height() / 2 - pStart.height() / 2)\n\n\n                item.myNode = node;\n                return item;\n                // return {\n                //     node: item,\n                //     inputs:()=>{\n                //         return [ [item.x(), item.cy()] ]\n                //     },\n                //     outputs:()=>{\n                //         return [ [item.x() + item.width(), item.cy()] ]\n                //     },\n                // }\n\n            },\n\n\n            // 'AA-WHEN': (node) => {\n            //     let row = new Container('serial', node);\n\n            //     let group = SVG().group();\n            //     let rect = SVG().rect(1, 1).attr({stroke:\"none\", fill:\"red\"});\n\n            //     rect.addTo(group);\n            //     let text = SVG().text(function (add) {\n            //         let w = add.tspan('when').font({\n            //             family: 'serif',\n            //             style: 'italic',\n            //             size: '50px',\n            //             weight: 'bold'\n            //         });\n            //         let t= add.tspan(node.getAttribute(\"test\")).font({\n            //             family: 'monospace',\n            //             // style: 'italic',\n            //             size: '12px',\n            //             weight: 'bold'\n            //         });\n            //         t.dy(20);\n            //         t.dx(-110);\n            //     })\n            //     text.addTo(group);\n\n            //     // group.noEndPoints = true;\n            //     row.push(group);\n\n\n            //     let contentsRow = new Container('parallel');\n            //     for (let i = 0; i < node.childNodes.length; i++) {\n\n            //         let m = this.model(node.childNodes[i])\n            //         if (m) contentsRow.push(m)\n\n            //     }\n\n            //     row.push(contentsRow);\n            //     // contentsRow.x(row.width());\n            //     row.strokeDashArray = '3';\n\n            //     row.myNode = node;\n            //     return row;\n\n            // },\n\n            'AA-WHEN': (node) => {\n                let container = SVG().group();\n\n                let contentsRow = new Container('parallel');\n                for (let i = 0; i < node.childNodes.length; i++) {\n                    let m = this.model(node.childNodes[i])\n                    if (m) contentsRow.push(m)\n                }\n\n                let when = SVG().text(function (add) {\n                    add.tspan('when').font({\n                        family: 'serif',\n                        style: 'italic',\n                        size: '30px',\n                        weight: 'bold'\n                    });\n                });\n\n                let condition = SVG().text(function (add) {\n                    let textToRender = node.getAttribute(\"test\");\n                    if(textToRender){\n                        let j = jsep(textToRender);\n\n                        if(j.left) if(j.left.name) if(j.left.name.length>7){\n                            let newName = j.left.name.substr(0,5)+\"...\";\n                            debugger;\n                            textToRender = textToRender.replace(j.left.name, newName);\n                        }\n                    }\n                    add.tspan(textToRender).font({\n                        family: 'monospace',\n                        // style: 'italic',\n                        size: '12px',\n                        weight: 'bold'\n                    });\n\n                })\n\n\n\n\n\n                contentsRow.addTo(container);\n                when.addTo(container);\n                condition.addTo(container);\n                // when.y(contentsRow.y() + contentsRow.height());\n                condition.y(when.y() + when.bbox().height);\n                contentsRow.x(when.x() + when.bbox().width + 40);\n                contentsRow.y(when.y() + when.bbox().height / 1.5 - contentsRow.height()/2);\n\n                container.strokeDashArray = '3';\n\n                container.myNode = node;\n\n                container.getEndPoints = () => {\n\n                    let result = [[contentsRow.x() + contentsRow.width(), contentsRow.y() + contentsRow.height() / 2]];\n                    // if(container.renderDefaultPath){\n                    //     debugger;\n                    //     result.push([container.x()  + container.width()/2, contentsRow.y() + contentsRow.height()*2.5])\n                    // }\n                    return result;\n                }\n                container.getStartPoints = () => {\n\n                    // console.log(\"returning\",  [text.bbox().x + text.bbox().width, text.bbox().y + text.bbox().height/2]);\n                    let result = [[when.bbox().x, when.bbox().y + when.bbox().height / 2]];\n                    // if(container.renderDefaultPath){\n                    //     result.push([container.x()  + container.width()/2, contentsRow.y() + contentsRow.height()*2.5])\n                    // }\n\n                    return result;\n                }\n\n                container.applyItemsAfterwards = ()=>{\n                    for (let i = 0; i < contentsRow.c.length; i++) {\n                        console.log(contentsRow.c[i]);\n                        if(contentsRow.c[i].applyItemsAfterwards){\n                            \n                            contentsRow.c[i].applyItemsAfterwards();\n                        }\n                        \n                    }\n                }\n                return container;\n\n            },\n\n            // 'AA-OTHERWISE': (node) => {\n            //     let row = new Container('serial', node);\n\n            //     let group = SVG().group();\n            //     let rect = SVG().rect(1, 1).attr({ stroke: \"none\", fill: \"red\" });\n\n            //     rect.addTo(group);\n            //     let text = SVG().text(function (add) {\n            //         let w = add.tspan('otrwz').font({\n            //             family: 'serif',\n            //             style: 'italic',\n            //             size: '30px',\n            //             weight: 'bold'\n            //         });\n            //         // let t= add.tspan(node.getAttribute(\"test\")).font({\n            //         //     family: 'monospace',\n            //         //     // style: 'italic',\n            //         //     size: '12px',\n            //         //     weight: 'bold'\n            //         // });\n            //         // t.dy(20);\n            //         // t.dx(-110);\n            //     })\n            //     text.addTo(group);\n\n            //     // group.noEndPoints = true;\n            //     row.push(group);\n\n\n            //     let contentsRow = new Container('parallel');\n            //     for (let i = 0; i < node.childNodes.length; i++) {\n\n            //         let m = this.model(node.childNodes[i])\n            //         if (m) contentsRow.push(m)\n\n            //     }\n\n            //     row.push(contentsRow);\n            //     // contentsRow.x(row.width());\n            //     // row.strokeDashArray = '3';\n            //     row.myNode = node;\n\n            //     row.applyItemsAfterwards = ()=>{\n            //         for (let i = 0; i < contentsRow.c.length; i++) {\n            //             console.log(contentsRow.c[i]);\n            //             if(contentsRow.c[i].applyItemsAfterwards){\n                            \n            //                 contentsRow.c[i].applyItemsAfterwards();\n            //             }\n                        \n            //         }\n            //     }\n            //     return row;\n            // },\n\n            'AA-OTHERWISE': (node) => {\n                let container = SVG().group();\n\n                let contentsRow = new Container('parallel');\n                for (let i = 0; i < node.childNodes.length; i++) {\n                    let m = this.model(node.childNodes[i])\n                    if (m) contentsRow.push(m)\n                }\n\n                let otherwise = SVG().text(function (add) {\n                    add.tspan('otherwise').font({\n                        family: 'serif',\n                        style: 'italic',\n                        size: '30px',\n                        weight: 'bold'\n                    });\n                });\n\n                // let condition = SVG().text(function (add) {\n                //     let textToRender = node.getAttribute(\"test\");\n                //     if(textToRender){\n                //         let j = jsep(textToRender);\n\n                //         if(j.left) if(j.left.name) if(j.left.name.length>7){\n                //             let newName = j.left.name.substr(0,5)+\"...\";\n                //             debugger;\n                //             textToRender = textToRender.replace(j.left.name, newName);\n                //         }\n                //     }\n                //     add.tspan(textToRender).font({\n                //         family: 'monospace',\n                //         // style: 'italic',\n                //         size: '12px',\n                //         weight: 'bold'\n                //     });\n\n                // })\n\n\n\n\n\n                contentsRow.addTo(container);\n                otherwise.addTo(container);\n                // condition.addTo(container);\n                // when.y(contentsRow.y() + contentsRow.height());\n                // condition.y(when.y() + when.bbox().height);\n                contentsRow.x(otherwise.x() + otherwise.bbox().width + 10);\n                contentsRow.y(otherwise.y() + otherwise.bbox().height / 1.5 - contentsRow.height()/2);\n\n                container.strokeDashArray = '3';\n\n                container.myNode = node;\n\n                container.getEndPoints = () => {\n\n                    let result = [[contentsRow.x() + contentsRow.width(), contentsRow.y() + contentsRow.height() / 2]];\n                    // if(container.renderDefaultPath){\n                    //     debugger;\n                    //     result.push([container.x()  + container.width()/2, contentsRow.y() + contentsRow.height()*2.5])\n                    // }\n                    return result;\n                }\n                container.getStartPoints = () => {\n\n                    // console.log(\"returning\",  [text.bbox().x + text.bbox().width, text.bbox().y + text.bbox().height/2]);\n                    let result = [[otherwise.bbox().x, otherwise.bbox().y + otherwise.bbox().height / 2]];\n                    // if(container.renderDefaultPath){\n                    //     result.push([container.x()  + container.width()/2, contentsRow.y() + contentsRow.height()*2.5])\n                    // }\n\n                    return result;\n                }\n\n                container.applyItemsAfterwards = ()=>{\n                    for (let i = 0; i < contentsRow.c.length; i++) {\n                        console.log(contentsRow.c[i]);\n                        if(contentsRow.c[i].applyItemsAfterwards){\n                            \n                            contentsRow.c[i].applyItemsAfterwards();\n                        }\n                        \n                    }\n                }\n                return container;\n\n            },\n\n            'DIV': (node) => {\n                // let svgItem = SVG().rect(30,50).attr({fill:'none'});\n\n                let row = new Container('parallel', node);\n                for (let i = 0; i < node.childNodes.length; i++) {\n\n                    let m = this.model(node.childNodes[i])\n                    if (m) row.push(m)\n                }\n\n                row.myNode = node;\n                return row;\n\n            },\n\n\n\n\n        }\n    }\n\n\n            get examples() {\n                return {\n\n                    'AA-SEQUENCE': {\n\n                        html: '<aa-sequence><aa-screen name=\"first screen\"></aa-screen><aa-screen name=\"second screen\"></aa-screen></aa-sequence>',\n                        comment: \"sequence\",\n\n                    },\n\n\n                    'AA-SCREEN': {\n\n                        html: '<aa-screen name=\"<name>\"></aa-screen>',\n                        comment: \"screen\",\n\n                    },\n\n                    'AA-FUNCTION-RANDOM': {\n\n                        html: '<aa-function-random></aa-function-random>',\n                        comment: \"random number generator\",\n\n                    },\n\n                    'AA-CHOOSE': {\n\n                        html: '<aa-choose><aa-when><aa-screen></aa-screen></aa-when></aa-choose>',\n                        comment: \"random number generator\",\n\n                    }\n                }\n            }\n\n\n        }\n\n\n\n        export { mySVG }","/*!\n* @svgdotjs/svg.js - A lightweight library for manipulating and animating SVG.\n* @version 3.0.16\n* https://svgdotjs.github.io/\n*\n* @copyright Wout Fierens <wout@mick-wout.com>\n* @license MIT\n*\n* BUILT: Tue Nov 12 2019 21:57:16 GMT+0100 (GMT+01:00)\n*/;\nvar SVG = (function () {\n\t'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar check = function (it) {\n\t  return it && it.Math == Math && it;\n\t};\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global_1 =\n\t  // eslint-disable-next-line no-undef\n\t  check(typeof globalThis == 'object' && globalThis) ||\n\t  check(typeof window == 'object' && window) ||\n\t  check(typeof self == 'object' && self) ||\n\t  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n\t  // eslint-disable-next-line no-new-func\n\t  Function('return this')();\n\n\tvar fails = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar descriptors = !fails(function () {\n\t  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n\t});\n\n\tvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\n\tvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// Nashorn ~ JDK8 bug\n\tvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n\t// `Object.prototype.propertyIsEnumerable` method implementation\n\t// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable\n\tvar f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n\t  var descriptor = getOwnPropertyDescriptor(this, V);\n\t  return !!descriptor && descriptor.enumerable;\n\t} : nativePropertyIsEnumerable;\n\n\tvar objectPropertyIsEnumerable = {\n\t\tf: f\n\t};\n\n\tvar createPropertyDescriptor = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\tvar toString = {}.toString;\n\n\tvar classofRaw = function (it) {\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n\tvar split = ''.split;\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar indexedObject = fails(function () {\n\t  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n\t  // eslint-disable-next-line no-prototype-builtins\n\t  return !Object('z').propertyIsEnumerable(0);\n\t}) ? function (it) {\n\t  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);\n\t} : Object;\n\n\t// `RequireObjectCoercible` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-requireobjectcoercible\n\tvar requireObjectCoercible = function (it) {\n\t  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n\t  return it;\n\t};\n\n\t// toObject with fallback for non-array-like ES3 strings\n\n\n\n\tvar toIndexedObject = function (it) {\n\t  return indexedObject(requireObjectCoercible(it));\n\t};\n\n\tvar isObject = function (it) {\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n\t// `ToPrimitive` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-toprimitive\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tvar toPrimitive = function (input, PREFERRED_STRING) {\n\t  if (!isObject(input)) return input;\n\t  var fn, val;\n\t  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n\t  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n\t  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\n\tvar has = function (it, key) {\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n\tvar document$1 = global_1.document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar EXISTS = isObject(document$1) && isObject(document$1.createElement);\n\n\tvar documentCreateElement = function (it) {\n\t  return EXISTS ? document$1.createElement(it) : {};\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar ie8DomDefine = !descriptors && !fails(function () {\n\t  return Object.defineProperty(documentCreateElement('div'), 'a', {\n\t    get: function () { return 7; }\n\t  }).a != 7;\n\t});\n\n\tvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// `Object.getOwnPropertyDescriptor` method\n\t// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\n\tvar f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n\t  O = toIndexedObject(O);\n\t  P = toPrimitive(P, true);\n\t  if (ie8DomDefine) try {\n\t    return nativeGetOwnPropertyDescriptor(O, P);\n\t  } catch (error) { /* empty */ }\n\t  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);\n\t};\n\n\tvar objectGetOwnPropertyDescriptor = {\n\t\tf: f$1\n\t};\n\n\tvar anObject = function (it) {\n\t  if (!isObject(it)) {\n\t    throw TypeError(String(it) + ' is not an object');\n\t  } return it;\n\t};\n\n\tvar nativeDefineProperty = Object.defineProperty;\n\n\t// `Object.defineProperty` method\n\t// https://tc39.github.io/ecma262/#sec-object.defineproperty\n\tvar f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if (ie8DomDefine) try {\n\t    return nativeDefineProperty(O, P, Attributes);\n\t  } catch (error) { /* empty */ }\n\t  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n\t  if ('value' in Attributes) O[P] = Attributes.value;\n\t  return O;\n\t};\n\n\tvar objectDefineProperty = {\n\t\tf: f$2\n\t};\n\n\tvar createNonEnumerableProperty = descriptors ? function (object, key, value) {\n\t  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\tvar setGlobal = function (key, value) {\n\t  try {\n\t    createNonEnumerableProperty(global_1, key, value);\n\t  } catch (error) {\n\t    global_1[key] = value;\n\t  } return value;\n\t};\n\n\tvar SHARED = '__core-js_shared__';\n\tvar store = global_1[SHARED] || setGlobal(SHARED, {});\n\n\tvar sharedStore = store;\n\n\tvar shared = createCommonjsModule(function (module) {\n\t(module.exports = function (key, value) {\n\t  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});\n\t})('versions', []).push({\n\t  version: '3.3.6',\n\t  mode:  'global',\n\t  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'\n\t});\n\t});\n\n\tvar functionToString = shared('native-function-to-string', Function.toString);\n\n\tvar WeakMap = global_1.WeakMap;\n\n\tvar nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(functionToString.call(WeakMap));\n\n\tvar id = 0;\n\tvar postfix = Math.random();\n\n\tvar uid = function (key) {\n\t  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n\t};\n\n\tvar keys = shared('keys');\n\n\tvar sharedKey = function (key) {\n\t  return keys[key] || (keys[key] = uid(key));\n\t};\n\n\tvar hiddenKeys = {};\n\n\tvar WeakMap$1 = global_1.WeakMap;\n\tvar set, get, has$1;\n\n\tvar enforce = function (it) {\n\t  return has$1(it) ? get(it) : set(it, {});\n\t};\n\n\tvar getterFor = function (TYPE) {\n\t  return function (it) {\n\t    var state;\n\t    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n\t      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n\t    } return state;\n\t  };\n\t};\n\n\tif (nativeWeakMap) {\n\t  var store$1 = new WeakMap$1();\n\t  var wmget = store$1.get;\n\t  var wmhas = store$1.has;\n\t  var wmset = store$1.set;\n\t  set = function (it, metadata) {\n\t    wmset.call(store$1, it, metadata);\n\t    return metadata;\n\t  };\n\t  get = function (it) {\n\t    return wmget.call(store$1, it) || {};\n\t  };\n\t  has$1 = function (it) {\n\t    return wmhas.call(store$1, it);\n\t  };\n\t} else {\n\t  var STATE = sharedKey('state');\n\t  hiddenKeys[STATE] = true;\n\t  set = function (it, metadata) {\n\t    createNonEnumerableProperty(it, STATE, metadata);\n\t    return metadata;\n\t  };\n\t  get = function (it) {\n\t    return has(it, STATE) ? it[STATE] : {};\n\t  };\n\t  has$1 = function (it) {\n\t    return has(it, STATE);\n\t  };\n\t}\n\n\tvar internalState = {\n\t  set: set,\n\t  get: get,\n\t  has: has$1,\n\t  enforce: enforce,\n\t  getterFor: getterFor\n\t};\n\n\tvar redefine = createCommonjsModule(function (module) {\n\tvar getInternalState = internalState.get;\n\tvar enforceInternalState = internalState.enforce;\n\tvar TEMPLATE = String(functionToString).split('toString');\n\n\tshared('inspectSource', function (it) {\n\t  return functionToString.call(it);\n\t});\n\n\t(module.exports = function (O, key, value, options) {\n\t  var unsafe = options ? !!options.unsafe : false;\n\t  var simple = options ? !!options.enumerable : false;\n\t  var noTargetGet = options ? !!options.noTargetGet : false;\n\t  if (typeof value == 'function') {\n\t    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);\n\t    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');\n\t  }\n\t  if (O === global_1) {\n\t    if (simple) O[key] = value;\n\t    else setGlobal(key, value);\n\t    return;\n\t  } else if (!unsafe) {\n\t    delete O[key];\n\t  } else if (!noTargetGet && O[key]) {\n\t    simple = true;\n\t  }\n\t  if (simple) O[key] = value;\n\t  else createNonEnumerableProperty(O, key, value);\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, 'toString', function toString() {\n\t  return typeof this == 'function' && getInternalState(this).source || functionToString.call(this);\n\t});\n\t});\n\n\tvar path = global_1;\n\n\tvar aFunction = function (variable) {\n\t  return typeof variable == 'function' ? variable : undefined;\n\t};\n\n\tvar getBuiltIn = function (namespace, method) {\n\t  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])\n\t    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];\n\t};\n\n\tvar ceil = Math.ceil;\n\tvar floor = Math.floor;\n\n\t// `ToInteger` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-tointeger\n\tvar toInteger = function (argument) {\n\t  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n\t};\n\n\tvar min = Math.min;\n\n\t// `ToLength` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-tolength\n\tvar toLength = function (argument) {\n\t  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n\t};\n\n\tvar max = Math.max;\n\tvar min$1 = Math.min;\n\n\t// Helper for a popular repeating case of the spec:\n\t// Let integer be ? ToInteger(index).\n\t// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).\n\tvar toAbsoluteIndex = function (index, length) {\n\t  var integer = toInteger(index);\n\t  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n\t};\n\n\t// `Array.prototype.{ indexOf, includes }` methods implementation\n\tvar createMethod = function (IS_INCLUDES) {\n\t  return function ($this, el, fromIndex) {\n\t    var O = toIndexedObject($this);\n\t    var length = toLength(O.length);\n\t    var index = toAbsoluteIndex(fromIndex, length);\n\t    var value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    // eslint-disable-next-line no-self-compare\n\t    if (IS_INCLUDES && el != el) while (length > index) {\n\t      value = O[index++];\n\t      // eslint-disable-next-line no-self-compare\n\t      if (value != value) return true;\n\t    // Array#indexOf ignores holes, Array#includes - not\n\t    } else for (;length > index; index++) {\n\t      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n\tvar arrayIncludes = {\n\t  // `Array.prototype.includes` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n\t  includes: createMethod(true),\n\t  // `Array.prototype.indexOf` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n\t  indexOf: createMethod(false)\n\t};\n\n\tvar indexOf = arrayIncludes.indexOf;\n\n\n\tvar objectKeysInternal = function (object, names) {\n\t  var O = toIndexedObject(object);\n\t  var i = 0;\n\t  var result = [];\n\t  var key;\n\t  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while (names.length > i) if (has(O, key = names[i++])) {\n\t    ~indexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n\t// IE8- don't enum bug keys\n\tvar enumBugKeys = [\n\t  'constructor',\n\t  'hasOwnProperty',\n\t  'isPrototypeOf',\n\t  'propertyIsEnumerable',\n\t  'toLocaleString',\n\t  'toString',\n\t  'valueOf'\n\t];\n\n\tvar hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');\n\n\t// `Object.getOwnPropertyNames` method\n\t// https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n\tvar f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n\t  return objectKeysInternal(O, hiddenKeys$1);\n\t};\n\n\tvar objectGetOwnPropertyNames = {\n\t\tf: f$3\n\t};\n\n\tvar f$4 = Object.getOwnPropertySymbols;\n\n\tvar objectGetOwnPropertySymbols = {\n\t\tf: f$4\n\t};\n\n\t// all object keys, includes non-enumerable and symbols\n\tvar ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n\t  var keys = objectGetOwnPropertyNames.f(anObject(it));\n\t  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n\t  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n\t};\n\n\tvar copyConstructorProperties = function (target, source) {\n\t  var keys = ownKeys(source);\n\t  var defineProperty = objectDefineProperty.f;\n\t  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n\t  }\n\t};\n\n\tvar replacement = /#|\\.prototype\\./;\n\n\tvar isForced = function (feature, detection) {\n\t  var value = data[normalize(feature)];\n\t  return value == POLYFILL ? true\n\t    : value == NATIVE ? false\n\t    : typeof detection == 'function' ? fails(detection)\n\t    : !!detection;\n\t};\n\n\tvar normalize = isForced.normalize = function (string) {\n\t  return String(string).replace(replacement, '.').toLowerCase();\n\t};\n\n\tvar data = isForced.data = {};\n\tvar NATIVE = isForced.NATIVE = 'N';\n\tvar POLYFILL = isForced.POLYFILL = 'P';\n\n\tvar isForced_1 = isForced;\n\n\tvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\t/*\n\t  options.target      - name of the target object\n\t  options.global      - target is the global object\n\t  options.stat        - export as static methods of target\n\t  options.proto       - export as prototype methods of target\n\t  options.real        - real prototype method for the `pure` version\n\t  options.forced      - export even if the native feature is available\n\t  options.bind        - bind methods to the target, required for the `pure` version\n\t  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n\t  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n\t  options.sham        - add a flag to not completely full polyfills\n\t  options.enumerable  - export as enumerable property\n\t  options.noTargetGet - prevent calling a getter on target\n\t*/\n\tvar _export = function (options, source) {\n\t  var TARGET = options.target;\n\t  var GLOBAL = options.global;\n\t  var STATIC = options.stat;\n\t  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n\t  if (GLOBAL) {\n\t    target = global_1;\n\t  } else if (STATIC) {\n\t    target = global_1[TARGET] || setGlobal(TARGET, {});\n\t  } else {\n\t    target = (global_1[TARGET] || {}).prototype;\n\t  }\n\t  if (target) for (key in source) {\n\t    sourceProperty = source[key];\n\t    if (options.noTargetGet) {\n\t      descriptor = getOwnPropertyDescriptor$1(target, key);\n\t      targetProperty = descriptor && descriptor.value;\n\t    } else targetProperty = target[key];\n\t    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n\t    // contained in target\n\t    if (!FORCED && targetProperty !== undefined) {\n\t      if (typeof sourceProperty === typeof targetProperty) continue;\n\t      copyConstructorProperties(sourceProperty, targetProperty);\n\t    }\n\t    // add a flag to not completely full polyfills\n\t    if (options.sham || (targetProperty && targetProperty.sham)) {\n\t      createNonEnumerableProperty(sourceProperty, 'sham', true);\n\t    }\n\t    // extend global\n\t    redefine(target, key, sourceProperty, options);\n\t  }\n\t};\n\n\t// `Object.keys` method\n\t// https://tc39.github.io/ecma262/#sec-object.keys\n\tvar objectKeys = Object.keys || function keys(O) {\n\t  return objectKeysInternal(O, enumBugKeys);\n\t};\n\n\t// `ToObject` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-toobject\n\tvar toObject = function (argument) {\n\t  return Object(requireObjectCoercible(argument));\n\t};\n\n\tvar nativeAssign = Object.assign;\n\n\t// `Object.assign` method\n\t// https://tc39.github.io/ecma262/#sec-object.assign\n\t// should work with symbols and should have deterministic property order (V8 bug)\n\tvar objectAssign = !nativeAssign || fails(function () {\n\t  var A = {};\n\t  var B = {};\n\t  // eslint-disable-next-line no-undef\n\t  var symbol = Symbol();\n\t  var alphabet = 'abcdefghijklmnopqrst';\n\t  A[symbol] = 7;\n\t  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n\t  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;\n\t}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n\t  var T = toObject(target);\n\t  var argumentsLength = arguments.length;\n\t  var index = 1;\n\t  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n\t  var propertyIsEnumerable = objectPropertyIsEnumerable.f;\n\t  while (argumentsLength > index) {\n\t    var S = indexedObject(arguments[index++]);\n\t    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n\t    var length = keys.length;\n\t    var j = 0;\n\t    var key;\n\t    while (length > j) {\n\t      key = keys[j++];\n\t      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n\t    }\n\t  } return T;\n\t} : nativeAssign;\n\n\t// `Object.assign` method\n\t// https://tc39.github.io/ecma262/#sec-object.assign\n\t_export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {\n\t  assign: objectAssign\n\t});\n\n\t// `IsArray` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-isarray\n\tvar isArray = Array.isArray || function isArray(arg) {\n\t  return classofRaw(arg) == 'Array';\n\t};\n\n\tvar createProperty = function (object, key, value) {\n\t  var propertyKey = toPrimitive(key);\n\t  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));\n\t  else object[propertyKey] = value;\n\t};\n\n\tvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {\n\t  // Chrome 38 Symbol has incorrect toString conversion\n\t  // eslint-disable-next-line no-undef\n\t  return !String(Symbol());\n\t});\n\n\tvar Symbol$1 = global_1.Symbol;\n\tvar store$2 = shared('wks');\n\n\tvar wellKnownSymbol = function (name) {\n\t  return store$2[name] || (store$2[name] = nativeSymbol && Symbol$1[name]\n\t    || (nativeSymbol ? Symbol$1 : uid)('Symbol.' + name));\n\t};\n\n\tvar userAgent = getBuiltIn('navigator', 'userAgent') || '';\n\n\tvar process = global_1.process;\n\tvar versions = process && process.versions;\n\tvar v8 = versions && versions.v8;\n\tvar match, version;\n\n\tif (v8) {\n\t  match = v8.split('.');\n\t  version = match[0] + match[1];\n\t} else if (userAgent) {\n\t  match = userAgent.match(/Edge\\/(\\d+)/);\n\t  if (!match || match[1] >= 74) {\n\t    match = userAgent.match(/Chrome\\/(\\d+)/);\n\t    if (match) version = match[1];\n\t  }\n\t}\n\n\tvar v8Version = version && +version;\n\n\tvar SPECIES = wellKnownSymbol('species');\n\n\tvar arrayMethodHasSpeciesSupport = function (METHOD_NAME) {\n\t  // We can't use this feature detection in V8 since it causes\n\t  // deoptimization and serious performance degradation\n\t  // https://github.com/zloirock/core-js/issues/677\n\t  return v8Version >= 51 || !fails(function () {\n\t    var array = [];\n\t    var constructor = array.constructor = {};\n\t    constructor[SPECIES] = function () {\n\t      return { foo: 1 };\n\t    };\n\t    return array[METHOD_NAME](Boolean).foo !== 1;\n\t  });\n\t};\n\n\tvar SPECIES$1 = wellKnownSymbol('species');\n\tvar nativeSlice = [].slice;\n\tvar max$1 = Math.max;\n\n\t// `Array.prototype.slice` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.slice\n\t// fallback for not array-like ES3 strings and DOM objects\n\t_export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('slice') }, {\n\t  slice: function slice(start, end) {\n\t    var O = toIndexedObject(this);\n\t    var length = toLength(O.length);\n\t    var k = toAbsoluteIndex(start, length);\n\t    var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n\t    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible\n\t    var Constructor, result, n;\n\t    if (isArray(O)) {\n\t      Constructor = O.constructor;\n\t      // cross-realm fallback\n\t      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {\n\t        Constructor = undefined;\n\t      } else if (isObject(Constructor)) {\n\t        Constructor = Constructor[SPECIES$1];\n\t        if (Constructor === null) Constructor = undefined;\n\t      }\n\t      if (Constructor === Array || Constructor === undefined) {\n\t        return nativeSlice.call(O, k, fin);\n\t      }\n\t    }\n\t    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));\n\t    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);\n\t    result.length = n;\n\t    return result;\n\t  }\n\t});\n\n\tvar defineProperty = objectDefineProperty.f;\n\n\tvar FunctionPrototype = Function.prototype;\n\tvar FunctionPrototypeToString = FunctionPrototype.toString;\n\tvar nameRE = /^\\s*function ([^ (]*)/;\n\tvar NAME = 'name';\n\n\t// Function instances `.name` property\n\t// https://tc39.github.io/ecma262/#sec-function-instances-name\n\tif (descriptors && !(NAME in FunctionPrototype)) {\n\t  defineProperty(FunctionPrototype, NAME, {\n\t    configurable: true,\n\t    get: function () {\n\t      try {\n\t        return FunctionPrototypeToString.call(this).match(nameRE)[1];\n\t      } catch (error) {\n\t        return '';\n\t      }\n\t    }\n\t  });\n\t}\n\n\tvar nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;\n\n\tvar toString$1 = {}.toString;\n\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\n\tvar getWindowNames = function (it) {\n\t  try {\n\t    return nativeGetOwnPropertyNames(it);\n\t  } catch (error) {\n\t    return windowNames.slice();\n\t  }\n\t};\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar f$5 = function getOwnPropertyNames(it) {\n\t  return windowNames && toString$1.call(it) == '[object Window]'\n\t    ? getWindowNames(it)\n\t    : nativeGetOwnPropertyNames(toIndexedObject(it));\n\t};\n\n\tvar objectGetOwnPropertyNamesExternal = {\n\t\tf: f$5\n\t};\n\n\tvar nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;\n\n\tvar FAILS_ON_PRIMITIVES = fails(function () { return !Object.getOwnPropertyNames(1); });\n\n\t// `Object.getOwnPropertyNames` method\n\t// https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n\t_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {\n\t  getOwnPropertyNames: nativeGetOwnPropertyNames$1\n\t});\n\n\tfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\n\tfunction _typeof(obj) {\n\t  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n\t    _typeof = function _typeof(obj) {\n\t      return _typeof2(obj);\n\t    };\n\t  } else {\n\t    _typeof = function _typeof(obj) {\n\t      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n\t    };\n\t  }\n\n\t  return _typeof(obj);\n\t}\n\n\t// `Object.defineProperties` method\n\t// https://tc39.github.io/ecma262/#sec-object.defineproperties\n\tvar objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n\t  anObject(O);\n\t  var keys = objectKeys(Properties);\n\t  var length = keys.length;\n\t  var index = 0;\n\t  var key;\n\t  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);\n\t  return O;\n\t};\n\n\tvar html = getBuiltIn('document', 'documentElement');\n\n\tvar IE_PROTO = sharedKey('IE_PROTO');\n\n\tvar PROTOTYPE = 'prototype';\n\tvar Empty = function () { /* empty */ };\n\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar createDict = function () {\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = documentCreateElement('iframe');\n\t  var length = enumBugKeys.length;\n\t  var lt = '<';\n\t  var script = 'script';\n\t  var gt = '>';\n\t  var js = 'java' + script + ':';\n\t  var iframeDocument;\n\t  iframe.style.display = 'none';\n\t  html.appendChild(iframe);\n\t  iframe.src = String(js);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);\n\t  iframeDocument.close();\n\t  createDict = iframeDocument.F;\n\t  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];\n\t  return createDict();\n\t};\n\n\t// `Object.create` method\n\t// https://tc39.github.io/ecma262/#sec-object.create\n\tvar objectCreate = Object.create || function create(O, Properties) {\n\t  var result;\n\t  if (O !== null) {\n\t    Empty[PROTOTYPE] = anObject(O);\n\t    result = new Empty();\n\t    Empty[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = createDict();\n\t  return Properties === undefined ? result : objectDefineProperties(result, Properties);\n\t};\n\n\thiddenKeys[IE_PROTO] = true;\n\n\tvar f$6 = wellKnownSymbol;\n\n\tvar wrappedWellKnownSymbol = {\n\t\tf: f$6\n\t};\n\n\tvar defineProperty$1 = objectDefineProperty.f;\n\n\tvar defineWellKnownSymbol = function (NAME) {\n\t  var Symbol = path.Symbol || (path.Symbol = {});\n\t  if (!has(Symbol, NAME)) defineProperty$1(Symbol, NAME, {\n\t    value: wrappedWellKnownSymbol.f(NAME)\n\t  });\n\t};\n\n\tvar defineProperty$2 = objectDefineProperty.f;\n\n\n\n\tvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\n\tvar setToStringTag = function (it, TAG, STATIC) {\n\t  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n\t    defineProperty$2(it, TO_STRING_TAG, { configurable: true, value: TAG });\n\t  }\n\t};\n\n\tvar aFunction$1 = function (it) {\n\t  if (typeof it != 'function') {\n\t    throw TypeError(String(it) + ' is not a function');\n\t  } return it;\n\t};\n\n\t// optional / simple context binding\n\tvar bindContext = function (fn, that, length) {\n\t  aFunction$1(fn);\n\t  if (that === undefined) return fn;\n\t  switch (length) {\n\t    case 0: return function () {\n\t      return fn.call(that);\n\t    };\n\t    case 1: return function (a) {\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function (a, b) {\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function (a, b, c) {\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\tvar SPECIES$2 = wellKnownSymbol('species');\n\n\t// `ArraySpeciesCreate` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-arrayspeciescreate\n\tvar arraySpeciesCreate = function (originalArray, length) {\n\t  var C;\n\t  if (isArray(originalArray)) {\n\t    C = originalArray.constructor;\n\t    // cross-realm fallback\n\t    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n\t    else if (isObject(C)) {\n\t      C = C[SPECIES$2];\n\t      if (C === null) C = undefined;\n\t    }\n\t  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n\t};\n\n\tvar push = [].push;\n\n\t// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation\n\tvar createMethod$1 = function (TYPE) {\n\t  var IS_MAP = TYPE == 1;\n\t  var IS_FILTER = TYPE == 2;\n\t  var IS_SOME = TYPE == 3;\n\t  var IS_EVERY = TYPE == 4;\n\t  var IS_FIND_INDEX = TYPE == 6;\n\t  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n\t  return function ($this, callbackfn, that, specificCreate) {\n\t    var O = toObject($this);\n\t    var self = indexedObject(O);\n\t    var boundFunction = bindContext(callbackfn, that, 3);\n\t    var length = toLength(self.length);\n\t    var index = 0;\n\t    var create = specificCreate || arraySpeciesCreate;\n\t    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n\t    var value, result;\n\t    for (;length > index; index++) if (NO_HOLES || index in self) {\n\t      value = self[index];\n\t      result = boundFunction(value, index, O);\n\t      if (TYPE) {\n\t        if (IS_MAP) target[index] = result; // map\n\t        else if (result) switch (TYPE) {\n\t          case 3: return true;              // some\n\t          case 5: return value;             // find\n\t          case 6: return index;             // findIndex\n\t          case 2: push.call(target, value); // filter\n\t        } else if (IS_EVERY) return false;  // every\n\t      }\n\t    }\n\t    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n\t  };\n\t};\n\n\tvar arrayIteration = {\n\t  // `Array.prototype.forEach` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n\t  forEach: createMethod$1(0),\n\t  // `Array.prototype.map` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.map\n\t  map: createMethod$1(1),\n\t  // `Array.prototype.filter` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.filter\n\t  filter: createMethod$1(2),\n\t  // `Array.prototype.some` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.some\n\t  some: createMethod$1(3),\n\t  // `Array.prototype.every` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.every\n\t  every: createMethod$1(4),\n\t  // `Array.prototype.find` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.find\n\t  find: createMethod$1(5),\n\t  // `Array.prototype.findIndex` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex\n\t  findIndex: createMethod$1(6)\n\t};\n\n\tvar $forEach = arrayIteration.forEach;\n\n\tvar HIDDEN = sharedKey('hidden');\n\tvar SYMBOL = 'Symbol';\n\tvar PROTOTYPE$1 = 'prototype';\n\tvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\tvar setInternalState = internalState.set;\n\tvar getInternalState = internalState.getterFor(SYMBOL);\n\tvar ObjectPrototype = Object[PROTOTYPE$1];\n\tvar $Symbol = global_1.Symbol;\n\tvar JSON$1 = global_1.JSON;\n\tvar nativeJSONStringify = JSON$1 && JSON$1.stringify;\n\tvar nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\tvar nativeDefineProperty$1 = objectDefineProperty.f;\n\tvar nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;\n\tvar nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;\n\tvar AllSymbols = shared('symbols');\n\tvar ObjectPrototypeSymbols = shared('op-symbols');\n\tvar StringToSymbolRegistry = shared('string-to-symbol-registry');\n\tvar SymbolToStringRegistry = shared('symbol-to-string-registry');\n\tvar WellKnownSymbolsStore = shared('wks');\n\tvar QObject = global_1.QObject;\n\t// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\tvar USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;\n\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDescriptor = descriptors && fails(function () {\n\t  return objectCreate(nativeDefineProperty$1({}, 'a', {\n\t    get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }\n\t  })).a != 7;\n\t}) ? function (O, P, Attributes) {\n\t  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);\n\t  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];\n\t  nativeDefineProperty$1(O, P, Attributes);\n\t  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {\n\t    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);\n\t  }\n\t} : nativeDefineProperty$1;\n\n\tvar wrap = function (tag, description) {\n\t  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);\n\t  setInternalState(symbol, {\n\t    type: SYMBOL,\n\t    tag: tag,\n\t    description: description\n\t  });\n\t  if (!descriptors) symbol.description = description;\n\t  return symbol;\n\t};\n\n\tvar isSymbol = nativeSymbol && typeof $Symbol.iterator == 'symbol' ? function (it) {\n\t  return typeof it == 'symbol';\n\t} : function (it) {\n\t  return Object(it) instanceof $Symbol;\n\t};\n\n\tvar $defineProperty = function defineProperty(O, P, Attributes) {\n\t  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n\t  anObject(O);\n\t  var key = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if (has(AllSymbols, key)) {\n\t    if (!Attributes.enumerable) {\n\t      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));\n\t      O[HIDDEN][key] = true;\n\t    } else {\n\t      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n\t      Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });\n\t    } return setSymbolDescriptor(O, key, Attributes);\n\t  } return nativeDefineProperty$1(O, key, Attributes);\n\t};\n\n\tvar $defineProperties = function defineProperties(O, Properties) {\n\t  anObject(O);\n\t  var properties = toIndexedObject(Properties);\n\t  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n\t  $forEach(keys, function (key) {\n\t    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);\n\t  });\n\t  return O;\n\t};\n\n\tvar $create = function create(O, Properties) {\n\t  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);\n\t};\n\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(V) {\n\t  var P = toPrimitive(V, true);\n\t  var enumerable = nativePropertyIsEnumerable$1.call(this, P);\n\t  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;\n\t  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n\t};\n\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n\t  var it = toIndexedObject(O);\n\t  var key = toPrimitive(P, true);\n\t  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;\n\t  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);\n\t  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {\n\t    descriptor.enumerable = true;\n\t  }\n\t  return descriptor;\n\t};\n\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(O) {\n\t  var names = nativeGetOwnPropertyNames$2(toIndexedObject(O));\n\t  var result = [];\n\t  $forEach(names, function (key) {\n\t    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);\n\t  });\n\t  return result;\n\t};\n\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n\t  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;\n\t  var names = nativeGetOwnPropertyNames$2(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));\n\t  var result = [];\n\t  $forEach(names, function (key) {\n\t    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {\n\t      result.push(AllSymbols[key]);\n\t    }\n\t  });\n\t  return result;\n\t};\n\n\t// `Symbol` constructor\n\t// https://tc39.github.io/ecma262/#sec-symbol-constructor\n\tif (!nativeSymbol) {\n\t  $Symbol = function Symbol() {\n\t    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');\n\t    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);\n\t    var tag = uid(description);\n\t    var setter = function (value) {\n\t      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);\n\t      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n\t      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n\t    };\n\t    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });\n\t    return wrap(tag, description);\n\t  };\n\n\t  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {\n\t    return getInternalState(this).tag;\n\t  });\n\n\t  objectPropertyIsEnumerable.f = $propertyIsEnumerable;\n\t  objectDefineProperty.f = $defineProperty;\n\t  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;\n\t  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n\t  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;\n\n\t  if (descriptors) {\n\t    // https://github.com/tc39/proposal-Symbol-description\n\t    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {\n\t      configurable: true,\n\t      get: function description() {\n\t        return getInternalState(this).description;\n\t      }\n\t    });\n\t    {\n\t      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });\n\t    }\n\t  }\n\n\t  wrappedWellKnownSymbol.f = function (name) {\n\t    return wrap(wellKnownSymbol(name), name);\n\t  };\n\t}\n\n\t_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {\n\t  Symbol: $Symbol\n\t});\n\n\t$forEach(objectKeys(WellKnownSymbolsStore), function (name) {\n\t  defineWellKnownSymbol(name);\n\t});\n\n\t_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {\n\t  // `Symbol.for` method\n\t  // https://tc39.github.io/ecma262/#sec-symbol.for\n\t  'for': function (key) {\n\t    var string = String(key);\n\t    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n\t    var symbol = $Symbol(string);\n\t    StringToSymbolRegistry[string] = symbol;\n\t    SymbolToStringRegistry[symbol] = string;\n\t    return symbol;\n\t  },\n\t  // `Symbol.keyFor` method\n\t  // https://tc39.github.io/ecma262/#sec-symbol.keyfor\n\t  keyFor: function keyFor(sym) {\n\t    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');\n\t    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n\t  },\n\t  useSetter: function () { USE_SETTER = true; },\n\t  useSimple: function () { USE_SETTER = false; }\n\t});\n\n\t_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {\n\t  // `Object.create` method\n\t  // https://tc39.github.io/ecma262/#sec-object.create\n\t  create: $create,\n\t  // `Object.defineProperty` method\n\t  // https://tc39.github.io/ecma262/#sec-object.defineproperty\n\t  defineProperty: $defineProperty,\n\t  // `Object.defineProperties` method\n\t  // https://tc39.github.io/ecma262/#sec-object.defineproperties\n\t  defineProperties: $defineProperties,\n\t  // `Object.getOwnPropertyDescriptor` method\n\t  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n\t});\n\n\t_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {\n\t  // `Object.getOwnPropertyNames` method\n\t  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // `Object.getOwnPropertySymbols` method\n\t  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\n\t// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n\t// https://bugs.chromium.org/p/v8/issues/detail?id=3443\n\t_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {\n\t  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n\t    return objectGetOwnPropertySymbols.f(toObject(it));\n\t  }\n\t});\n\n\t// `JSON.stringify` method behavior with symbols\n\t// https://tc39.github.io/ecma262/#sec-json.stringify\n\tJSON$1 && _export({ target: 'JSON', stat: true, forced: !nativeSymbol || fails(function () {\n\t  var symbol = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  return nativeJSONStringify([symbol]) != '[null]'\n\t    // WebKit converts symbol values to JSON as null\n\t    || nativeJSONStringify({ a: symbol }) != '{}'\n\t    // V8 throws on boxed symbols\n\t    || nativeJSONStringify(Object(symbol)) != '{}';\n\t}) }, {\n\t  stringify: function stringify(it) {\n\t    var args = [it];\n\t    var index = 1;\n\t    var replacer, $replacer;\n\t    while (arguments.length > index) args.push(arguments[index++]);\n\t    $replacer = replacer = args[1];\n\t    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n\t    if (!isArray(replacer)) replacer = function (key, value) {\n\t      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n\t      if (!isSymbol(value)) return value;\n\t    };\n\t    args[1] = replacer;\n\t    return nativeJSONStringify.apply(JSON$1, args);\n\t  }\n\t});\n\n\t// `Symbol.prototype[@@toPrimitive]` method\n\t// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive\n\tif (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {\n\t  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);\n\t}\n\t// `Symbol.prototype[@@toStringTag]` property\n\t// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag\n\tsetToStringTag($Symbol, SYMBOL);\n\n\thiddenKeys[HIDDEN] = true;\n\n\tvar defineProperty$3 = objectDefineProperty.f;\n\n\n\tvar NativeSymbol = global_1.Symbol;\n\n\tif (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||\n\t  // Safari 12 bug\n\t  NativeSymbol().description !== undefined\n\t)) {\n\t  var EmptyStringDescriptionStore = {};\n\t  // wrap Symbol constructor for correct work with undefined description\n\t  var SymbolWrapper = function Symbol() {\n\t    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);\n\t    var result = this instanceof SymbolWrapper\n\t      ? new NativeSymbol(description)\n\t      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'\n\t      : description === undefined ? NativeSymbol() : NativeSymbol(description);\n\t    if (description === '') EmptyStringDescriptionStore[result] = true;\n\t    return result;\n\t  };\n\t  copyConstructorProperties(SymbolWrapper, NativeSymbol);\n\t  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;\n\t  symbolPrototype.constructor = SymbolWrapper;\n\n\t  var symbolToString = symbolPrototype.toString;\n\t  var native = String(NativeSymbol('test')) == 'Symbol(test)';\n\t  var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n\t  defineProperty$3(symbolPrototype, 'description', {\n\t    configurable: true,\n\t    get: function description() {\n\t      var symbol = isObject(this) ? this.valueOf() : this;\n\t      var string = symbolToString.call(symbol);\n\t      if (has(EmptyStringDescriptionStore, symbol)) return '';\n\t      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');\n\t      return desc === '' ? undefined : desc;\n\t    }\n\t  });\n\n\t  _export({ global: true, forced: true }, {\n\t    Symbol: SymbolWrapper\n\t  });\n\t}\n\n\t// `Symbol.iterator` well-known symbol\n\t// https://tc39.github.io/ecma262/#sec-symbol.iterator\n\tdefineWellKnownSymbol('iterator');\n\n\tvar UNSCOPABLES = wellKnownSymbol('unscopables');\n\tvar ArrayPrototype = Array.prototype;\n\n\t// Array.prototype[@@unscopables]\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\tif (ArrayPrototype[UNSCOPABLES] == undefined) {\n\t  createNonEnumerableProperty(ArrayPrototype, UNSCOPABLES, objectCreate(null));\n\t}\n\n\t// add a key to Array.prototype[@@unscopables]\n\tvar addToUnscopables = function (key) {\n\t  ArrayPrototype[UNSCOPABLES][key] = true;\n\t};\n\n\tvar iterators = {};\n\n\tvar correctPrototypeGetter = !fails(function () {\n\t  function F() { /* empty */ }\n\t  F.prototype.constructor = null;\n\t  return Object.getPrototypeOf(new F()) !== F.prototype;\n\t});\n\n\tvar IE_PROTO$1 = sharedKey('IE_PROTO');\n\tvar ObjectPrototype$1 = Object.prototype;\n\n\t// `Object.getPrototypeOf` method\n\t// https://tc39.github.io/ecma262/#sec-object.getprototypeof\n\tvar objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {\n\t  O = toObject(O);\n\t  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];\n\t  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectPrototype$1 : null;\n\t};\n\n\tvar ITERATOR = wellKnownSymbol('iterator');\n\tvar BUGGY_SAFARI_ITERATORS = false;\n\n\tvar returnThis = function () { return this; };\n\n\t// `%IteratorPrototype%` object\n\t// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\n\tvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n\tif ([].keys) {\n\t  arrayIterator = [].keys();\n\t  // Safari 8 has buggy iterators w/o `next`\n\t  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n\t  else {\n\t    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n\t    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n\t  }\n\t}\n\n\tif (IteratorPrototype == undefined) IteratorPrototype = {};\n\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\tif ( !has(IteratorPrototype, ITERATOR)) {\n\t  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n\t}\n\n\tvar iteratorsCore = {\n\t  IteratorPrototype: IteratorPrototype,\n\t  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n\t};\n\n\tvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n\n\n\n\n\n\tvar returnThis$1 = function () { return this; };\n\n\tvar createIteratorConstructor = function (IteratorConstructor, NAME, next) {\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });\n\t  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);\n\t  iterators[TO_STRING_TAG] = returnThis$1;\n\t  return IteratorConstructor;\n\t};\n\n\tvar aPossiblePrototype = function (it) {\n\t  if (!isObject(it) && it !== null) {\n\t    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n\t  } return it;\n\t};\n\n\t// `Object.setPrototypeOf` method\n\t// https://tc39.github.io/ecma262/#sec-object.setprototypeof\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n\t  var CORRECT_SETTER = false;\n\t  var test = {};\n\t  var setter;\n\t  try {\n\t    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n\t    setter.call(test, []);\n\t    CORRECT_SETTER = test instanceof Array;\n\t  } catch (error) { /* empty */ }\n\t  return function setPrototypeOf(O, proto) {\n\t    anObject(O);\n\t    aPossiblePrototype(proto);\n\t    if (CORRECT_SETTER) setter.call(O, proto);\n\t    else O.__proto__ = proto;\n\t    return O;\n\t  };\n\t}() : undefined);\n\n\tvar IteratorPrototype$2 = iteratorsCore.IteratorPrototype;\n\tvar BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\tvar ITERATOR$1 = wellKnownSymbol('iterator');\n\tvar KEYS = 'keys';\n\tvar VALUES = 'values';\n\tvar ENTRIES = 'entries';\n\n\tvar returnThis$2 = function () { return this; };\n\n\tvar defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n\t  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n\t  var getIterationMethod = function (KIND) {\n\t    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n\t    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];\n\t    switch (KIND) {\n\t      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n\t      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n\t      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n\t    } return function () { return new IteratorConstructor(this); };\n\t  };\n\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  var INCORRECT_VALUES_NAME = false;\n\t  var IterablePrototype = Iterable.prototype;\n\t  var nativeIterator = IterablePrototype[ITERATOR$1]\n\t    || IterablePrototype['@@iterator']\n\t    || DEFAULT && IterablePrototype[DEFAULT];\n\t  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);\n\t  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n\t  var CurrentIteratorPrototype, methods, KEY;\n\n\t  // fix native\n\t  if (anyNativeIterator) {\n\t    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n\t    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {\n\t      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {\n\t        if (objectSetPrototypeOf) {\n\t          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);\n\t        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {\n\t          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);\n\t        }\n\t      }\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);\n\t    }\n\t  }\n\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n\t    INCORRECT_VALUES_NAME = true;\n\t    defaultIterator = function values() { return nativeIterator.call(this); };\n\t  }\n\n\t  // define iterator\n\t  if ( IterablePrototype[ITERATOR$1] !== defaultIterator) {\n\t    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);\n\t  }\n\t  iterators[NAME] = defaultIterator;\n\n\t  // export additional methods\n\t  if (DEFAULT) {\n\t    methods = {\n\t      values: getIterationMethod(VALUES),\n\t      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n\t      entries: getIterationMethod(ENTRIES)\n\t    };\n\t    if (FORCED) for (KEY in methods) {\n\t      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n\t        redefine(IterablePrototype, KEY, methods[KEY]);\n\t      }\n\t    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);\n\t  }\n\n\t  return methods;\n\t};\n\n\tvar ARRAY_ITERATOR = 'Array Iterator';\n\tvar setInternalState$1 = internalState.set;\n\tvar getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);\n\n\t// `Array.prototype.entries` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.entries\n\t// `Array.prototype.keys` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.keys\n\t// `Array.prototype.values` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.values\n\t// `Array.prototype[@@iterator]` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator\n\t// `CreateArrayIterator` internal method\n\t// https://tc39.github.io/ecma262/#sec-createarrayiterator\n\tvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n\t  setInternalState$1(this, {\n\t    type: ARRAY_ITERATOR,\n\t    target: toIndexedObject(iterated), // target\n\t    index: 0,                          // next index\n\t    kind: kind                         // kind\n\t  });\n\t// `%ArrayIteratorPrototype%.next` method\n\t// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next\n\t}, function () {\n\t  var state = getInternalState$1(this);\n\t  var target = state.target;\n\t  var kind = state.kind;\n\t  var index = state.index++;\n\t  if (!target || index >= target.length) {\n\t    state.target = undefined;\n\t    return { value: undefined, done: true };\n\t  }\n\t  if (kind == 'keys') return { value: index, done: false };\n\t  if (kind == 'values') return { value: target[index], done: false };\n\t  return { value: [index, target[index]], done: false };\n\t}, 'values');\n\n\t// argumentsList[@@iterator] is %ArrayProto_values%\n\t// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject\n\t// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject\n\titerators.Arguments = iterators.Array;\n\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n\tvar TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');\n\t// ES3 wrong here\n\tvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function (it, key) {\n\t  try {\n\t    return it[key];\n\t  } catch (error) { /* empty */ }\n\t};\n\n\t// getting tag from ES6+ `Object.prototype.toString`\n\tvar classof = function (it) {\n\t  var O, tag, result;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag\n\t    // builtinTag case\n\t    : CORRECT_ARGUMENTS ? classofRaw(O)\n\t    // ES3 arguments fallback\n\t    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n\t};\n\n\tvar TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');\n\tvar test = {};\n\n\ttest[TO_STRING_TAG$2] = 'z';\n\n\t// `Object.prototype.toString` method implementation\n\t// https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n\tvar objectToString = String(test) !== '[object z]' ? function toString() {\n\t  return '[object ' + classof(this) + ']';\n\t} : test.toString;\n\n\tvar ObjectPrototype$2 = Object.prototype;\n\n\t// `Object.prototype.toString` method\n\t// https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n\tif (objectToString !== ObjectPrototype$2.toString) {\n\t  redefine(ObjectPrototype$2, 'toString', objectToString, { unsafe: true });\n\t}\n\n\tvar freezing = !fails(function () {\n\t  return Object.isExtensible(Object.preventExtensions({}));\n\t});\n\n\tvar internalMetadata = createCommonjsModule(function (module) {\n\tvar defineProperty = objectDefineProperty.f;\n\n\n\n\tvar METADATA = uid('meta');\n\tvar id = 0;\n\n\tvar isExtensible = Object.isExtensible || function () {\n\t  return true;\n\t};\n\n\tvar setMetadata = function (it) {\n\t  defineProperty(it, METADATA, { value: {\n\t    objectID: 'O' + ++id, // object ID\n\t    weakData: {}          // weak collections IDs\n\t  } });\n\t};\n\n\tvar fastKey = function (it, create) {\n\t  // return a primitive with prefix\n\t  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if (!has(it, METADATA)) {\n\t    // can't set metadata to uncaught frozen object\n\t    if (!isExtensible(it)) return 'F';\n\t    // not necessary to add metadata\n\t    if (!create) return 'E';\n\t    // add missing metadata\n\t    setMetadata(it);\n\t  // return object ID\n\t  } return it[METADATA].objectID;\n\t};\n\n\tvar getWeakData = function (it, create) {\n\t  if (!has(it, METADATA)) {\n\t    // can't set metadata to uncaught frozen object\n\t    if (!isExtensible(it)) return true;\n\t    // not necessary to add metadata\n\t    if (!create) return false;\n\t    // add missing metadata\n\t    setMetadata(it);\n\t  // return the store of weak collections IDs\n\t  } return it[METADATA].weakData;\n\t};\n\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function (it) {\n\t  if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);\n\t  return it;\n\t};\n\n\tvar meta = module.exports = {\n\t  REQUIRED: false,\n\t  fastKey: fastKey,\n\t  getWeakData: getWeakData,\n\t  onFreeze: onFreeze\n\t};\n\n\thiddenKeys[METADATA] = true;\n\t});\n\n\tvar ITERATOR$2 = wellKnownSymbol('iterator');\n\tvar ArrayPrototype$1 = Array.prototype;\n\n\t// check on default Array iterator\n\tvar isArrayIteratorMethod = function (it) {\n\t  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$2] === it);\n\t};\n\n\tvar ITERATOR$3 = wellKnownSymbol('iterator');\n\n\tvar getIteratorMethod = function (it) {\n\t  if (it != undefined) return it[ITERATOR$3]\n\t    || it['@@iterator']\n\t    || iterators[classof(it)];\n\t};\n\n\t// call something on iterator step with safe closing on error\n\tvar callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {\n\t  try {\n\t    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch (error) {\n\t    var returnMethod = iterator['return'];\n\t    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));\n\t    throw error;\n\t  }\n\t};\n\n\tvar iterate_1 = createCommonjsModule(function (module) {\n\tvar Result = function (stopped, result) {\n\t  this.stopped = stopped;\n\t  this.result = result;\n\t};\n\n\tvar iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {\n\t  var boundFunction = bindContext(fn, that, AS_ENTRIES ? 2 : 1);\n\t  var iterator, iterFn, index, length, result, next, step;\n\n\t  if (IS_ITERATOR) {\n\t    iterator = iterable;\n\t  } else {\n\t    iterFn = getIteratorMethod(iterable);\n\t    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');\n\t    // optimisation for array iterators\n\t    if (isArrayIteratorMethod(iterFn)) {\n\t      for (index = 0, length = toLength(iterable.length); length > index; index++) {\n\t        result = AS_ENTRIES\n\t          ? boundFunction(anObject(step = iterable[index])[0], step[1])\n\t          : boundFunction(iterable[index]);\n\t        if (result && result instanceof Result) return result;\n\t      } return new Result(false);\n\t    }\n\t    iterator = iterFn.call(iterable);\n\t  }\n\n\t  next = iterator.next;\n\t  while (!(step = next.call(iterator)).done) {\n\t    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);\n\t    if (typeof result == 'object' && result && result instanceof Result) return result;\n\t  } return new Result(false);\n\t};\n\n\titerate.stop = function (result) {\n\t  return new Result(true, result);\n\t};\n\t});\n\n\tvar anInstance = function (it, Constructor, name) {\n\t  if (!(it instanceof Constructor)) {\n\t    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\n\t  } return it;\n\t};\n\n\tvar ITERATOR$4 = wellKnownSymbol('iterator');\n\tvar SAFE_CLOSING = false;\n\n\ttry {\n\t  var called = 0;\n\t  var iteratorWithReturn = {\n\t    next: function () {\n\t      return { done: !!called++ };\n\t    },\n\t    'return': function () {\n\t      SAFE_CLOSING = true;\n\t    }\n\t  };\n\t  iteratorWithReturn[ITERATOR$4] = function () {\n\t    return this;\n\t  };\n\t  // eslint-disable-next-line no-throw-literal\n\t  Array.from(iteratorWithReturn, function () { throw 2; });\n\t} catch (error) { /* empty */ }\n\n\tvar checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {\n\t  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n\t  var ITERATION_SUPPORT = false;\n\t  try {\n\t    var object = {};\n\t    object[ITERATOR$4] = function () {\n\t      return {\n\t        next: function () {\n\t          return { done: ITERATION_SUPPORT = true };\n\t        }\n\t      };\n\t    };\n\t    exec(object);\n\t  } catch (error) { /* empty */ }\n\t  return ITERATION_SUPPORT;\n\t};\n\n\t// makes subclassing work correct for wrapped built-ins\n\tvar inheritIfRequired = function ($this, dummy, Wrapper) {\n\t  var NewTarget, NewTargetPrototype;\n\t  if (\n\t    // it can work only with native `setPrototypeOf`\n\t    objectSetPrototypeOf &&\n\t    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n\t    typeof (NewTarget = dummy.constructor) == 'function' &&\n\t    NewTarget !== Wrapper &&\n\t    isObject(NewTargetPrototype = NewTarget.prototype) &&\n\t    NewTargetPrototype !== Wrapper.prototype\n\t  ) objectSetPrototypeOf($this, NewTargetPrototype);\n\t  return $this;\n\t};\n\n\tvar collection = function (CONSTRUCTOR_NAME, wrapper, common, IS_MAP, IS_WEAK) {\n\t  var NativeConstructor = global_1[CONSTRUCTOR_NAME];\n\t  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n\t  var Constructor = NativeConstructor;\n\t  var ADDER = IS_MAP ? 'set' : 'add';\n\t  var exported = {};\n\n\t  var fixMethod = function (KEY) {\n\t    var nativeMethod = NativePrototype[KEY];\n\t    redefine(NativePrototype, KEY,\n\t      KEY == 'add' ? function add(value) {\n\t        nativeMethod.call(this, value === 0 ? 0 : value);\n\t        return this;\n\t      } : KEY == 'delete' ? function (key) {\n\t        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n\t      } : KEY == 'get' ? function get(key) {\n\t        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);\n\t      } : KEY == 'has' ? function has(key) {\n\t        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n\t      } : function set(key, value) {\n\t        nativeMethod.call(this, key === 0 ? 0 : key, value);\n\t        return this;\n\t      }\n\t    );\n\t  };\n\n\t  // eslint-disable-next-line max-len\n\t  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n\t    new NativeConstructor().entries().next();\n\t  })))) {\n\t    // create collection constructor\n\t    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n\t    internalMetadata.REQUIRED = true;\n\t  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {\n\t    var instance = new Constructor();\n\t    // early implementations not supports chaining\n\t    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n\t    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false\n\t    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n\t    // most early implementations doesn't supports iterables, most modern - not close it correctly\n\t    // eslint-disable-next-line no-new\n\t    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });\n\t    // for early implementations -0 and +0 not the same\n\t    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n\t      // V8 ~ Chromium 42- fails only with 5+ elements\n\t      var $instance = new NativeConstructor();\n\t      var index = 5;\n\t      while (index--) $instance[ADDER](index, index);\n\t      return !$instance.has(-0);\n\t    });\n\n\t    if (!ACCEPT_ITERABLES) {\n\t      Constructor = wrapper(function (dummy, iterable) {\n\t        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);\n\t        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);\n\t        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);\n\t        return that;\n\t      });\n\t      Constructor.prototype = NativePrototype;\n\t      NativePrototype.constructor = Constructor;\n\t    }\n\n\t    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n\t      fixMethod('delete');\n\t      fixMethod('has');\n\t      IS_MAP && fixMethod('get');\n\t    }\n\n\t    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n\n\t    // weak collections should not contains .clear method\n\t    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;\n\t  }\n\n\t  exported[CONSTRUCTOR_NAME] = Constructor;\n\t  _export({ global: true, forced: Constructor != NativeConstructor }, exported);\n\n\t  setToStringTag(Constructor, CONSTRUCTOR_NAME);\n\n\t  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n\n\t  return Constructor;\n\t};\n\n\tvar redefineAll = function (target, src, options) {\n\t  for (var key in src) redefine(target, key, src[key], options);\n\t  return target;\n\t};\n\n\tvar SPECIES$3 = wellKnownSymbol('species');\n\n\tvar setSpecies = function (CONSTRUCTOR_NAME) {\n\t  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n\t  var defineProperty = objectDefineProperty.f;\n\n\t  if (descriptors && Constructor && !Constructor[SPECIES$3]) {\n\t    defineProperty(Constructor, SPECIES$3, {\n\t      configurable: true,\n\t      get: function () { return this; }\n\t    });\n\t  }\n\t};\n\n\tvar defineProperty$4 = objectDefineProperty.f;\n\n\n\n\n\n\n\n\n\tvar fastKey = internalMetadata.fastKey;\n\n\n\tvar setInternalState$2 = internalState.set;\n\tvar internalStateGetterFor = internalState.getterFor;\n\n\tvar collectionStrong = {\n\t  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n\t    var C = wrapper(function (that, iterable) {\n\t      anInstance(that, C, CONSTRUCTOR_NAME);\n\t      setInternalState$2(that, {\n\t        type: CONSTRUCTOR_NAME,\n\t        index: objectCreate(null),\n\t        first: undefined,\n\t        last: undefined,\n\t        size: 0\n\t      });\n\t      if (!descriptors) that.size = 0;\n\t      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);\n\t    });\n\n\t    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n\t    var define = function (that, key, value) {\n\t      var state = getInternalState(that);\n\t      var entry = getEntry(that, key);\n\t      var previous, index;\n\t      // change existing entry\n\t      if (entry) {\n\t        entry.value = value;\n\t      // create new entry\n\t      } else {\n\t        state.last = entry = {\n\t          index: index = fastKey(key, true),\n\t          key: key,\n\t          value: value,\n\t          previous: previous = state.last,\n\t          next: undefined,\n\t          removed: false\n\t        };\n\t        if (!state.first) state.first = entry;\n\t        if (previous) previous.next = entry;\n\t        if (descriptors) state.size++;\n\t        else that.size++;\n\t        // add to index\n\t        if (index !== 'F') state.index[index] = entry;\n\t      } return that;\n\t    };\n\n\t    var getEntry = function (that, key) {\n\t      var state = getInternalState(that);\n\t      // fast case\n\t      var index = fastKey(key);\n\t      var entry;\n\t      if (index !== 'F') return state.index[index];\n\t      // frozen object case\n\t      for (entry = state.first; entry; entry = entry.next) {\n\t        if (entry.key == key) return entry;\n\t      }\n\t    };\n\n\t    redefineAll(C.prototype, {\n\t      // 23.1.3.1 Map.prototype.clear()\n\t      // 23.2.3.2 Set.prototype.clear()\n\t      clear: function clear() {\n\t        var that = this;\n\t        var state = getInternalState(that);\n\t        var data = state.index;\n\t        var entry = state.first;\n\t        while (entry) {\n\t          entry.removed = true;\n\t          if (entry.previous) entry.previous = entry.previous.next = undefined;\n\t          delete data[entry.index];\n\t          entry = entry.next;\n\t        }\n\t        state.first = state.last = undefined;\n\t        if (descriptors) state.size = 0;\n\t        else that.size = 0;\n\t      },\n\t      // 23.1.3.3 Map.prototype.delete(key)\n\t      // 23.2.3.4 Set.prototype.delete(value)\n\t      'delete': function (key) {\n\t        var that = this;\n\t        var state = getInternalState(that);\n\t        var entry = getEntry(that, key);\n\t        if (entry) {\n\t          var next = entry.next;\n\t          var prev = entry.previous;\n\t          delete state.index[entry.index];\n\t          entry.removed = true;\n\t          if (prev) prev.next = next;\n\t          if (next) next.previous = prev;\n\t          if (state.first == entry) state.first = next;\n\t          if (state.last == entry) state.last = prev;\n\t          if (descriptors) state.size--;\n\t          else that.size--;\n\t        } return !!entry;\n\t      },\n\t      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n\t      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n\t      forEach: function forEach(callbackfn /* , that = undefined */) {\n\t        var state = getInternalState(this);\n\t        var boundFunction = bindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n\t        var entry;\n\t        while (entry = entry ? entry.next : state.first) {\n\t          boundFunction(entry.value, entry.key, this);\n\t          // revert to the last existing entry\n\t          while (entry && entry.removed) entry = entry.previous;\n\t        }\n\t      },\n\t      // 23.1.3.7 Map.prototype.has(key)\n\t      // 23.2.3.7 Set.prototype.has(value)\n\t      has: function has(key) {\n\t        return !!getEntry(this, key);\n\t      }\n\t    });\n\n\t    redefineAll(C.prototype, IS_MAP ? {\n\t      // 23.1.3.6 Map.prototype.get(key)\n\t      get: function get(key) {\n\t        var entry = getEntry(this, key);\n\t        return entry && entry.value;\n\t      },\n\t      // 23.1.3.9 Map.prototype.set(key, value)\n\t      set: function set(key, value) {\n\t        return define(this, key === 0 ? 0 : key, value);\n\t      }\n\t    } : {\n\t      // 23.2.3.1 Set.prototype.add(value)\n\t      add: function add(value) {\n\t        return define(this, value = value === 0 ? 0 : value, value);\n\t      }\n\t    });\n\t    if (descriptors) defineProperty$4(C.prototype, 'size', {\n\t      get: function () {\n\t        return getInternalState(this).size;\n\t      }\n\t    });\n\t    return C;\n\t  },\n\t  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {\n\t    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';\n\t    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\t    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);\n\t    // add .keys, .values, .entries, [@@iterator]\n\t    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n\t    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {\n\t      setInternalState$2(this, {\n\t        type: ITERATOR_NAME,\n\t        target: iterated,\n\t        state: getInternalCollectionState(iterated),\n\t        kind: kind,\n\t        last: undefined\n\t      });\n\t    }, function () {\n\t      var state = getInternalIteratorState(this);\n\t      var kind = state.kind;\n\t      var entry = state.last;\n\t      // revert to the last existing entry\n\t      while (entry && entry.removed) entry = entry.previous;\n\t      // get next entry\n\t      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n\t        // or finish the iteration\n\t        state.target = undefined;\n\t        return { value: undefined, done: true };\n\t      }\n\t      // return step by kind\n\t      if (kind == 'keys') return { value: entry.key, done: false };\n\t      if (kind == 'values') return { value: entry.value, done: false };\n\t      return { value: [entry.key, entry.value], done: false };\n\t    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n\t    // add [@@species], 23.1.2.2, 23.2.2.2\n\t    setSpecies(CONSTRUCTOR_NAME);\n\t  }\n\t};\n\n\t// `Set` constructor\n\t// https://tc39.github.io/ecma262/#sec-set-objects\n\tvar es_set = collection('Set', function (get) {\n\t  return function Set() { return get(this, arguments.length ? arguments[0] : undefined); };\n\t}, collectionStrong);\n\n\t// `String.prototype.{ codePointAt, at }` methods implementation\n\tvar createMethod$2 = function (CONVERT_TO_STRING) {\n\t  return function ($this, pos) {\n\t    var S = String(requireObjectCoercible($this));\n\t    var position = toInteger(pos);\n\t    var size = S.length;\n\t    var first, second;\n\t    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n\t    first = S.charCodeAt(position);\n\t    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n\t      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n\t        ? CONVERT_TO_STRING ? S.charAt(position) : first\n\t        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n\t  };\n\t};\n\n\tvar stringMultibyte = {\n\t  // `String.prototype.codePointAt` method\n\t  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat\n\t  codeAt: createMethod$2(false),\n\t  // `String.prototype.at` method\n\t  // https://github.com/mathiasbynens/String.prototype.at\n\t  charAt: createMethod$2(true)\n\t};\n\n\tvar charAt = stringMultibyte.charAt;\n\n\n\n\tvar STRING_ITERATOR = 'String Iterator';\n\tvar setInternalState$3 = internalState.set;\n\tvar getInternalState$2 = internalState.getterFor(STRING_ITERATOR);\n\n\t// `String.prototype[@@iterator]` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator\n\tdefineIterator(String, 'String', function (iterated) {\n\t  setInternalState$3(this, {\n\t    type: STRING_ITERATOR,\n\t    string: String(iterated),\n\t    index: 0\n\t  });\n\t// `%StringIteratorPrototype%.next` method\n\t// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next\n\t}, function next() {\n\t  var state = getInternalState$2(this);\n\t  var string = state.string;\n\t  var index = state.index;\n\t  var point;\n\t  if (index >= string.length) return { value: undefined, done: true };\n\t  point = charAt(string, index);\n\t  state.index += point.length;\n\t  return { value: point, done: false };\n\t});\n\n\t// iterable DOM collections\n\t// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\n\tvar domIterables = {\n\t  CSSRuleList: 0,\n\t  CSSStyleDeclaration: 0,\n\t  CSSValueList: 0,\n\t  ClientRectList: 0,\n\t  DOMRectList: 0,\n\t  DOMStringList: 0,\n\t  DOMTokenList: 1,\n\t  DataTransferItemList: 0,\n\t  FileList: 0,\n\t  HTMLAllCollection: 0,\n\t  HTMLCollection: 0,\n\t  HTMLFormElement: 0,\n\t  HTMLSelectElement: 0,\n\t  MediaList: 0,\n\t  MimeTypeArray: 0,\n\t  NamedNodeMap: 0,\n\t  NodeList: 1,\n\t  PaintRequestList: 0,\n\t  Plugin: 0,\n\t  PluginArray: 0,\n\t  SVGLengthList: 0,\n\t  SVGNumberList: 0,\n\t  SVGPathSegList: 0,\n\t  SVGPointList: 0,\n\t  SVGStringList: 0,\n\t  SVGTransformList: 0,\n\t  SourceBufferList: 0,\n\t  StyleSheetList: 0,\n\t  TextTrackCueList: 0,\n\t  TextTrackList: 0,\n\t  TouchList: 0\n\t};\n\n\tvar ITERATOR$5 = wellKnownSymbol('iterator');\n\tvar TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');\n\tvar ArrayValues = es_array_iterator.values;\n\n\tfor (var COLLECTION_NAME in domIterables) {\n\t  var Collection = global_1[COLLECTION_NAME];\n\t  var CollectionPrototype = Collection && Collection.prototype;\n\t  if (CollectionPrototype) {\n\t    // some Chrome versions have non-configurable methods on DOMTokenList\n\t    if (CollectionPrototype[ITERATOR$5] !== ArrayValues) try {\n\t      createNonEnumerableProperty(CollectionPrototype, ITERATOR$5, ArrayValues);\n\t    } catch (error) {\n\t      CollectionPrototype[ITERATOR$5] = ArrayValues;\n\t    }\n\t    if (!CollectionPrototype[TO_STRING_TAG$3]) {\n\t      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);\n\t    }\n\t    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {\n\t      // some Chrome versions have non-configurable methods on DOMTokenList\n\t      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {\n\t        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);\n\t      } catch (error) {\n\t        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction _arrayWithoutHoles(arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n\t      arr2[i] = arr[i];\n\t    }\n\n\t    return arr2;\n\t  }\n\t}\n\n\tfunction _iterableToArray(iter) {\n\t  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n\t}\n\n\tfunction _nonIterableSpread() {\n\t  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n\t}\n\n\tfunction _toConsumableArray(arr) {\n\t  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n\t}\n\n\tvar methods = {};\n\tvar names = [];\n\tfunction registerMethods(name, m) {\n\t  if (Array.isArray(name)) {\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\n\t    try {\n\t      for (var _iterator = name[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t        var _name = _step.value;\n\t        registerMethods(_name, m);\n\t      }\n\t    } catch (err) {\n\t      _didIteratorError = true;\n\t      _iteratorError = err;\n\t    } finally {\n\t      try {\n\t        if (!_iteratorNormalCompletion && _iterator.return != null) {\n\t          _iterator.return();\n\t        }\n\t      } finally {\n\t        if (_didIteratorError) {\n\t          throw _iteratorError;\n\t        }\n\t      }\n\t    }\n\n\t    return;\n\t  }\n\n\t  if (_typeof(name) === 'object') {\n\t    for (var _name2 in name) {\n\t      registerMethods(_name2, name[_name2]);\n\t    }\n\n\t    return;\n\t  }\n\n\t  addMethodNames(Object.getOwnPropertyNames(m));\n\t  methods[name] = Object.assign(methods[name] || {}, m);\n\t}\n\tfunction getMethodsFor(name) {\n\t  return methods[name] || {};\n\t}\n\tfunction getMethodNames() {\n\t  return _toConsumableArray(new Set(names));\n\t}\n\tfunction addMethodNames(_names) {\n\t  names.push.apply(names, _toConsumableArray(_names));\n\t}\n\n\tvar $includes = arrayIncludes.includes;\n\n\n\t// `Array.prototype.includes` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.includes\n\t_export({ target: 'Array', proto: true }, {\n\t  includes: function includes(el /* , fromIndex = 0 */) {\n\t    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('includes');\n\n\t// `RegExp.prototype.flags` getter implementation\n\t// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags\n\tvar regexpFlags = function () {\n\t  var that = anObject(this);\n\t  var result = '';\n\t  if (that.global) result += 'g';\n\t  if (that.ignoreCase) result += 'i';\n\t  if (that.multiline) result += 'm';\n\t  if (that.dotAll) result += 's';\n\t  if (that.unicode) result += 'u';\n\t  if (that.sticky) result += 'y';\n\t  return result;\n\t};\n\n\tvar nativeExec = RegExp.prototype.exec;\n\t// This always refers to the native implementation, because the\n\t// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\n\t// which loads this file before patching the method.\n\tvar nativeReplace = String.prototype.replace;\n\n\tvar patchedExec = nativeExec;\n\n\tvar UPDATES_LAST_INDEX_WRONG = (function () {\n\t  var re1 = /a/;\n\t  var re2 = /b*/g;\n\t  nativeExec.call(re1, 'a');\n\t  nativeExec.call(re2, 'a');\n\t  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n\t})();\n\n\t// nonparticipating capturing group, copied from es5-shim's String#split patch.\n\tvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\n\tvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;\n\n\tif (PATCH) {\n\t  patchedExec = function exec(str) {\n\t    var re = this;\n\t    var lastIndex, reCopy, match, i;\n\n\t    if (NPCG_INCLUDED) {\n\t      reCopy = new RegExp('^' + re.source + '$(?!\\\\s)', regexpFlags.call(re));\n\t    }\n\t    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n\t    match = nativeExec.call(re, str);\n\n\t    if (UPDATES_LAST_INDEX_WRONG && match) {\n\t      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n\t    }\n\t    if (NPCG_INCLUDED && match && match.length > 1) {\n\t      // Fix browsers whose `exec` methods don't consistently return `undefined`\n\t      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n\t      nativeReplace.call(match[0], reCopy, function () {\n\t        for (i = 1; i < arguments.length - 2; i++) {\n\t          if (arguments[i] === undefined) match[i] = undefined;\n\t        }\n\t      });\n\t    }\n\n\t    return match;\n\t  };\n\t}\n\n\tvar regexpExec = patchedExec;\n\n\t_export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {\n\t  exec: regexpExec\n\t});\n\n\tvar MATCH = wellKnownSymbol('match');\n\n\t// `IsRegExp` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-isregexp\n\tvar isRegexp = function (it) {\n\t  var isRegExp;\n\t  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');\n\t};\n\n\tvar notARegexp = function (it) {\n\t  if (isRegexp(it)) {\n\t    throw TypeError(\"The method doesn't accept regular expressions\");\n\t  } return it;\n\t};\n\n\tvar MATCH$1 = wellKnownSymbol('match');\n\n\tvar correctIsRegexpLogic = function (METHOD_NAME) {\n\t  var regexp = /./;\n\t  try {\n\t    '/./'[METHOD_NAME](regexp);\n\t  } catch (e) {\n\t    try {\n\t      regexp[MATCH$1] = false;\n\t      return '/./'[METHOD_NAME](regexp);\n\t    } catch (f) { /* empty */ }\n\t  } return false;\n\t};\n\n\t// `String.prototype.includes` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.includes\n\t_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {\n\t  includes: function includes(searchString /* , position = 0 */) {\n\t    return !!~String(requireObjectCoercible(this))\n\t      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar SPECIES$4 = wellKnownSymbol('species');\n\n\tvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n\t  // #replace needs built-in support for named groups.\n\t  // #match works fine because it just return the exec results, even if it has\n\t  // a \"grops\" property.\n\t  var re = /./;\n\t  re.exec = function () {\n\t    var result = [];\n\t    result.groups = { a: '7' };\n\t    return result;\n\t  };\n\t  return ''.replace(re, '$<a>') !== '7';\n\t});\n\n\t// Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n\t// Weex JS has frozen built-in prototypes, so use try / catch wrapper\n\tvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\n\t  var re = /(?:)/;\n\t  var originalExec = re.exec;\n\t  re.exec = function () { return originalExec.apply(this, arguments); };\n\t  var result = 'ab'.split(re);\n\t  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\n\t});\n\n\tvar fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {\n\t  var SYMBOL = wellKnownSymbol(KEY);\n\n\t  var DELEGATES_TO_SYMBOL = !fails(function () {\n\t    // String methods call symbol-named RegEp methods\n\t    var O = {};\n\t    O[SYMBOL] = function () { return 7; };\n\t    return ''[KEY](O) != 7;\n\t  });\n\n\t  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {\n\t    // Symbol-named RegExp methods call .exec\n\t    var execCalled = false;\n\t    var re = /a/;\n\n\t    if (KEY === 'split') {\n\t      // We can't use real regex here since it causes deoptimization\n\t      // and serious performance degradation in V8\n\t      // https://github.com/zloirock/core-js/issues/306\n\t      re = {};\n\t      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n\t      // a new one. We need to return the patched regex when creating the new one.\n\t      re.constructor = {};\n\t      re.constructor[SPECIES$4] = function () { return re; };\n\t      re.flags = '';\n\t      re[SYMBOL] = /./[SYMBOL];\n\t    }\n\n\t    re.exec = function () { execCalled = true; return null; };\n\n\t    re[SYMBOL]('');\n\t    return !execCalled;\n\t  });\n\n\t  if (\n\t    !DELEGATES_TO_SYMBOL ||\n\t    !DELEGATES_TO_EXEC ||\n\t    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||\n\t    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\n\t  ) {\n\t    var nativeRegExpMethod = /./[SYMBOL];\n\t    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n\t      if (regexp.exec === regexpExec) {\n\t        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n\t          // The native String method already delegates to @@method (this\n\t          // polyfilled function), leasing to infinite recursion.\n\t          // We avoid it by directly calling the native @@method method.\n\t          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\n\t        }\n\t        return { done: true, value: nativeMethod.call(str, regexp, arg2) };\n\t      }\n\t      return { done: false };\n\t    });\n\t    var stringMethod = methods[0];\n\t    var regexMethod = methods[1];\n\n\t    redefine(String.prototype, KEY, stringMethod);\n\t    redefine(RegExp.prototype, SYMBOL, length == 2\n\t      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n\t      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n\t      ? function (string, arg) { return regexMethod.call(string, this, arg); }\n\t      // 21.2.5.6 RegExp.prototype[@@match](string)\n\t      // 21.2.5.9 RegExp.prototype[@@search](string)\n\t      : function (string) { return regexMethod.call(string, this); }\n\t    );\n\t    if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);\n\t  }\n\t};\n\n\tvar charAt$1 = stringMultibyte.charAt;\n\n\t// `AdvanceStringIndex` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-advancestringindex\n\tvar advanceStringIndex = function (S, index, unicode) {\n\t  return index + (unicode ? charAt$1(S, index).length : 1);\n\t};\n\n\t// `RegExpExec` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-regexpexec\n\tvar regexpExecAbstract = function (R, S) {\n\t  var exec = R.exec;\n\t  if (typeof exec === 'function') {\n\t    var result = exec.call(R, S);\n\t    if (typeof result !== 'object') {\n\t      throw TypeError('RegExp exec method returned something other than an Object or null');\n\t    }\n\t    return result;\n\t  }\n\n\t  if (classofRaw(R) !== 'RegExp') {\n\t    throw TypeError('RegExp#exec called on incompatible receiver');\n\t  }\n\n\t  return regexpExec.call(R, S);\n\t};\n\n\tvar max$2 = Math.max;\n\tvar min$2 = Math.min;\n\tvar floor$1 = Math.floor;\n\tvar SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d\\d?|<[^>]*>)/g;\n\tvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d\\d?)/g;\n\n\tvar maybeToString = function (it) {\n\t  return it === undefined ? it : String(it);\n\t};\n\n\t// @@replace logic\n\tfixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative) {\n\t  return [\n\t    // `String.prototype.replace` method\n\t    // https://tc39.github.io/ecma262/#sec-string.prototype.replace\n\t    function replace(searchValue, replaceValue) {\n\t      var O = requireObjectCoercible(this);\n\t      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];\n\t      return replacer !== undefined\n\t        ? replacer.call(searchValue, O, replaceValue)\n\t        : nativeReplace.call(String(O), searchValue, replaceValue);\n\t    },\n\t    // `RegExp.prototype[@@replace]` method\n\t    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace\n\t    function (regexp, replaceValue) {\n\t      var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);\n\t      if (res.done) return res.value;\n\n\t      var rx = anObject(regexp);\n\t      var S = String(this);\n\n\t      var functionalReplace = typeof replaceValue === 'function';\n\t      if (!functionalReplace) replaceValue = String(replaceValue);\n\n\t      var global = rx.global;\n\t      if (global) {\n\t        var fullUnicode = rx.unicode;\n\t        rx.lastIndex = 0;\n\t      }\n\t      var results = [];\n\t      while (true) {\n\t        var result = regexpExecAbstract(rx, S);\n\t        if (result === null) break;\n\n\t        results.push(result);\n\t        if (!global) break;\n\n\t        var matchStr = String(result[0]);\n\t        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n\t      }\n\n\t      var accumulatedResult = '';\n\t      var nextSourcePosition = 0;\n\t      for (var i = 0; i < results.length; i++) {\n\t        result = results[i];\n\n\t        var matched = String(result[0]);\n\t        var position = max$2(min$2(toInteger(result.index), S.length), 0);\n\t        var captures = [];\n\t        // NOTE: This is equivalent to\n\t        //   captures = result.slice(1).map(maybeToString)\n\t        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n\t        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n\t        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n\t        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));\n\t        var namedCaptures = result.groups;\n\t        if (functionalReplace) {\n\t          var replacerArgs = [matched].concat(captures, position, S);\n\t          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);\n\t          var replacement = String(replaceValue.apply(undefined, replacerArgs));\n\t        } else {\n\t          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n\t        }\n\t        if (position >= nextSourcePosition) {\n\t          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;\n\t          nextSourcePosition = position + matched.length;\n\t        }\n\t      }\n\t      return accumulatedResult + S.slice(nextSourcePosition);\n\t    }\n\t  ];\n\n\t  // https://tc39.github.io/ecma262/#sec-getsubstitution\n\t  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {\n\t    var tailPos = position + matched.length;\n\t    var m = captures.length;\n\t    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n\t    if (namedCaptures !== undefined) {\n\t      namedCaptures = toObject(namedCaptures);\n\t      symbols = SUBSTITUTION_SYMBOLS;\n\t    }\n\t    return nativeReplace.call(replacement, symbols, function (match, ch) {\n\t      var capture;\n\t      switch (ch.charAt(0)) {\n\t        case '$': return '$';\n\t        case '&': return matched;\n\t        case '`': return str.slice(0, position);\n\t        case \"'\": return str.slice(tailPos);\n\t        case '<':\n\t          capture = namedCaptures[ch.slice(1, -1)];\n\t          break;\n\t        default: // \\d\\d?\n\t          var n = +ch;\n\t          if (n === 0) return match;\n\t          if (n > m) {\n\t            var f = floor$1(n / 10);\n\t            if (f === 0) return match;\n\t            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\n\t            return match;\n\t          }\n\t          capture = captures[n - 1];\n\t      }\n\t      return capture === undefined ? '' : capture;\n\t    });\n\t  }\n\t});\n\n\t// a string of all valid unicode whitespaces\n\t// eslint-disable-next-line max-len\n\tvar whitespaces = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\n\tvar whitespace = '[' + whitespaces + ']';\n\tvar ltrim = RegExp('^' + whitespace + whitespace + '*');\n\tvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n\t// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\n\tvar createMethod$3 = function (TYPE) {\n\t  return function ($this) {\n\t    var string = String(requireObjectCoercible($this));\n\t    if (TYPE & 1) string = string.replace(ltrim, '');\n\t    if (TYPE & 2) string = string.replace(rtrim, '');\n\t    return string;\n\t  };\n\t};\n\n\tvar stringTrim = {\n\t  // `String.prototype.{ trimLeft, trimStart }` methods\n\t  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart\n\t  start: createMethod$3(1),\n\t  // `String.prototype.{ trimRight, trimEnd }` methods\n\t  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend\n\t  end: createMethod$3(2),\n\t  // `String.prototype.trim` method\n\t  // https://tc39.github.io/ecma262/#sec-string.prototype.trim\n\t  trim: createMethod$3(3)\n\t};\n\n\tvar non = '\\u200B\\u0085\\u180E';\n\n\t// check that a method works with the correct list\n\t// of whitespaces and has a correct name\n\tvar forcedStringTrimMethod = function (METHOD_NAME) {\n\t  return fails(function () {\n\t    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;\n\t  });\n\t};\n\n\tvar $trim = stringTrim.trim;\n\n\n\t// `String.prototype.trim` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.trim\n\t_export({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n\t  trim: function trim() {\n\t    return $trim(this);\n\t  }\n\t});\n\n\t// Map function\n\tfunction map(array, block) {\n\t  var i;\n\t  var il = array.length;\n\t  var result = [];\n\n\t  for (i = 0; i < il; i++) {\n\t    result.push(block(array[i]));\n\t  }\n\n\t  return result;\n\t} // Filter function\n\n\tfunction filter(array, block) {\n\t  var i;\n\t  var il = array.length;\n\t  var result = [];\n\n\t  for (i = 0; i < il; i++) {\n\t    if (block(array[i])) {\n\t      result.push(array[i]);\n\t    }\n\t  }\n\n\t  return result;\n\t} // Degrees to radians\n\n\tfunction radians(d) {\n\t  return d % 360 * Math.PI / 180;\n\t} // Radians to degrees\n\n\tfunction degrees(r) {\n\t  return r * 180 / Math.PI % 360;\n\t} // Convert dash-separated-string to camelCase\n\n\tfunction camelCase(s) {\n\t  return s.toLowerCase().replace(/-(.)/g, function (m, g) {\n\t    return g.toUpperCase();\n\t  });\n\t} // Convert camel cased string to string seperated\n\n\tfunction unCamelCase(s) {\n\t  return s.replace(/([A-Z])/g, function (m, g) {\n\t    return '-' + g.toLowerCase();\n\t  });\n\t} // Capitalize first letter of a string\n\n\tfunction capitalize(s) {\n\t  return s.charAt(0).toUpperCase() + s.slice(1);\n\t} // Calculate proportional width and height values when necessary\n\n\tfunction proportionalSize(element, width, height, box) {\n\t  if (width == null || height == null) {\n\t    box = box || element.bbox();\n\n\t    if (width == null) {\n\t      width = box.width / box.height * height;\n\t    } else if (height == null) {\n\t      height = box.height / box.width * width;\n\t    }\n\t  }\n\n\t  return {\n\t    width: width,\n\t    height: height\n\t  };\n\t}\n\tfunction getOrigin(o, element) {\n\t  // Allow origin or around as the names\n\t  var origin = o.origin; // o.around == null ? o.origin : o.around\n\n\t  var ox, oy; // Allow the user to pass a string to rotate around a given point\n\n\t  if (typeof origin === 'string' || origin == null) {\n\t    // Get the bounding box of the element with no transformations applied\n\t    var string = (origin || 'center').toLowerCase().trim();\n\n\t    var _element$bbox = element.bbox(),\n\t        height = _element$bbox.height,\n\t        width = _element$bbox.width,\n\t        x = _element$bbox.x,\n\t        y = _element$bbox.y; // Calculate the transformed x and y coordinates\n\n\n\t    var bx = string.includes('left') ? x : string.includes('right') ? x + width : x + width / 2;\n\t    var by = string.includes('top') ? y : string.includes('bottom') ? y + height : y + height / 2; // Set the bounds eg : \"bottom-left\", \"Top right\", \"middle\" etc...\n\n\t    ox = o.ox != null ? o.ox : bx;\n\t    oy = o.oy != null ? o.oy : by;\n\t  } else {\n\t    ox = origin[0];\n\t    oy = origin[1];\n\t  } // Return the origin as it is if it wasn't a string\n\n\n\t  return [ox, oy];\n\t}\n\n\tvar utils = ({\n\t\t__proto__: null,\n\t\tmap: map,\n\t\tfilter: filter,\n\t\tradians: radians,\n\t\tdegrees: degrees,\n\t\tcamelCase: camelCase,\n\t\tunCamelCase: unCamelCase,\n\t\tcapitalize: capitalize,\n\t\tproportionalSize: proportionalSize,\n\t\tgetOrigin: getOrigin\n\t});\n\n\t// Default namespaces\n\tvar ns = 'http://www.w3.org/2000/svg';\n\tvar xmlns = 'http://www.w3.org/2000/xmlns/';\n\tvar xlink = 'http://www.w3.org/1999/xlink';\n\tvar svgjs = 'http://svgjs.com/svgjs';\n\n\tvar namespaces = ({\n\t\t__proto__: null,\n\t\tns: ns,\n\t\txmlns: xmlns,\n\t\txlink: xlink,\n\t\tsvgjs: svgjs\n\t});\n\n\tvar globals = {\n\t  window: typeof window === 'undefined' ? null : window,\n\t  document: typeof document === 'undefined' ? null : document\n\t};\n\tfunction registerWindow() {\n\t  var win = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t  var doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t  globals.window = win;\n\t  globals.document = doc;\n\t}\n\n\tfunction _classCallCheck(instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t}\n\n\tvar Base = function Base() {\n\t  _classCallCheck(this, Base);\n\t};\n\n\tvar elements = {};\n\tvar root = '___SYMBOL___ROOT___'; // Method for element creation\n\n\tfunction create(name) {\n\t  // create element\n\t  return globals.document.createElementNS(ns, name);\n\t}\n\tfunction makeInstance(element) {\n\t  if (element instanceof Base) return element;\n\n\t  if (_typeof(element) === 'object') {\n\t    return adopter(element);\n\t  }\n\n\t  if (element == null) {\n\t    return new elements[root]();\n\t  }\n\n\t  if (typeof element === 'string' && element.charAt(0) !== '<') {\n\t    return adopter(globals.document.querySelector(element));\n\t  }\n\n\t  var node = create('svg');\n\t  node.innerHTML = element; // We can use firstChild here because we know,\n\t  // that the first char is < and thus an element\n\n\t  element = adopter(node.firstChild);\n\t  return element;\n\t}\n\tfunction nodeOrNew(name, node) {\n\t  return node instanceof globals.window.Node ? node : create(name);\n\t} // Adopt existing svg elements\n\n\tfunction adopt(node) {\n\t  // check for presence of node\n\t  if (!node) return null; // make sure a node isn't already adopted\n\n\t  if (node.instance instanceof Base) return node.instance; // initialize variables\n\n\t  var className = capitalize(node.nodeName || 'Dom'); // Make sure that gradients are adopted correctly\n\n\t  if (className === 'LinearGradient' || className === 'RadialGradient') {\n\t    className = 'Gradient'; // Fallback to Dom if element is not known\n\t  } else if (!elements[className]) {\n\t    className = 'Dom';\n\t  }\n\n\t  return new elements[className](node);\n\t}\n\tvar adopter = adopt;\n\tfunction mockAdopt() {\n\t  var mock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : adopt;\n\t  adopter = mock;\n\t}\n\tfunction register(element) {\n\t  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : element.name;\n\t  var asRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t  elements[name] = element;\n\t  if (asRoot) elements[root] = element;\n\t  addMethodNames(Object.getOwnPropertyNames(element.prototype));\n\t  return element;\n\t}\n\tfunction getClass(name) {\n\t  return elements[name];\n\t} // Element id sequence\n\n\tvar did = 1000; // Get next named element id\n\n\tfunction eid(name) {\n\t  return 'Svgjs' + capitalize(name) + did++;\n\t} // Deep new id assignment\n\n\tfunction assignNewId(node) {\n\t  // do the same for SVG child nodes as well\n\t  for (var i = node.children.length - 1; i >= 0; i--) {\n\t    assignNewId(node.children[i]);\n\t  }\n\n\t  if (node.id) {\n\t    return adopt(node).id(eid(node.nodeName));\n\t  }\n\n\t  return adopt(node);\n\t} // Method for extending objects\n\n\tfunction extend(modules, methods, attrCheck) {\n\t  var key, i;\n\t  modules = Array.isArray(modules) ? modules : [modules];\n\n\t  for (i = modules.length - 1; i >= 0; i--) {\n\t    for (key in methods) {\n\t      var method = methods[key];\n\n\t      if (attrCheck) {\n\t        method = wrapWithAttrCheck(methods[key]);\n\t      }\n\n\t      modules[i].prototype[key] = method;\n\t    }\n\t  }\n\t} // export function extendWithAttrCheck (...args) {\n\t//   extend(...args, true)\n\t// }\n\n\tfunction wrapWithAttrCheck(fn) {\n\t  return function () {\n\t    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\n\t    var o = args[args.length - 1];\n\n\t    if (o && o.constructor === Object && !(o instanceof Array)) {\n\t      return fn.apply(this, args.slice(0, -1)).attr(o);\n\t    } else {\n\t      return fn.apply(this, args);\n\t    }\n\t  };\n\t}\n\tfunction invent(config) {\n\t  // Create element initializer\n\t  var initializer = typeof config.create === 'function' ? config.create : function (node) {\n\t    this.constructor(node || create(config.create));\n\t  }; // Inherit prototype\n\n\t  if (config.inherit) {\n\t    /* eslint new-cap: off */\n\t    initializer.prototype = new config.inherit();\n\t    initializer.prototype.constructor = initializer;\n\t  } // Extend with methods\n\n\n\t  if (config.extend) {\n\t    extend(initializer, config.extend);\n\t  } // Attach construct method to parent\n\n\n\t  if (config.construct) {\n\t    extend(config.parent || elements.Container, config.construct);\n\t  }\n\n\t  return initializer;\n\t}\n\n\tfunction siblings() {\n\t  return this.parent().children();\n\t} // Get the curent position siblings\n\n\tfunction position() {\n\t  return this.parent().index(this);\n\t} // Get the next element (will return null if there is none)\n\n\tfunction next() {\n\t  return this.siblings()[this.position() + 1];\n\t} // Get the next element (will return null if there is none)\n\n\tfunction prev() {\n\t  return this.siblings()[this.position() - 1];\n\t} // Send given element one step forward\n\n\tfunction forward() {\n\t  var i = this.position() + 1;\n\t  var p = this.parent(); // move node one step forward\n\n\t  p.removeElement(this).add(this, i); // make sure defs node is always at the top\n\n\t  if (typeof p.isRoot === 'function' && p.isRoot()) {\n\t    p.node.appendChild(p.defs().node);\n\t  }\n\n\t  return this;\n\t} // Send given element one step backward\n\n\tfunction backward() {\n\t  var i = this.position();\n\n\t  if (i > 0) {\n\t    this.parent().removeElement(this).add(this, i - 1);\n\t  }\n\n\t  return this;\n\t} // Send given element all the way to the front\n\n\tfunction front() {\n\t  var p = this.parent(); // Move node forward\n\n\t  p.node.appendChild(this.node); // Make sure defs node is always at the top\n\n\t  if (typeof p.isRoot === 'function' && p.isRoot()) {\n\t    p.node.appendChild(p.defs().node);\n\t  }\n\n\t  return this;\n\t} // Send given element all the way to the back\n\n\tfunction back() {\n\t  if (this.position() > 0) {\n\t    this.parent().removeElement(this).add(this, 0);\n\t  }\n\n\t  return this;\n\t} // Inserts a given element before the targeted element\n\n\tfunction before(element) {\n\t  element = makeInstance(element);\n\t  element.remove();\n\t  var i = this.position();\n\t  this.parent().add(element, i);\n\t  return this;\n\t} // Inserts a given element after the targeted element\n\n\tfunction after(element) {\n\t  element = makeInstance(element);\n\t  element.remove();\n\t  var i = this.position();\n\t  this.parent().add(element, i + 1);\n\t  return this;\n\t}\n\tfunction insertBefore(element) {\n\t  element = makeInstance(element);\n\t  element.before(this);\n\t  return this;\n\t}\n\tfunction insertAfter(element) {\n\t  element = makeInstance(element);\n\t  element.after(this);\n\t  return this;\n\t}\n\tregisterMethods('Dom', {\n\t  siblings: siblings,\n\t  position: position,\n\t  next: next,\n\t  prev: prev,\n\t  forward: forward,\n\t  backward: backward,\n\t  front: front,\n\t  back: back,\n\t  before: before,\n\t  after: after,\n\t  insertBefore: insertBefore,\n\t  insertAfter: insertAfter\n\t});\n\n\tvar $filter = arrayIteration.filter;\n\n\n\t// `Array.prototype.filter` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.filter\n\t// with adding support of @@species\n\t_export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('filter') }, {\n\t  filter: function filter(callbackfn /* , thisArg */) {\n\t    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar sloppyArrayMethod = function (METHOD_NAME, argument) {\n\t  var method = [][METHOD_NAME];\n\t  return !method || !fails(function () {\n\t    // eslint-disable-next-line no-useless-call,no-throw-literal\n\t    method.call(null, argument || function () { throw 1; }, 1);\n\t  });\n\t};\n\n\tvar $indexOf = arrayIncludes.indexOf;\n\n\n\tvar nativeIndexOf = [].indexOf;\n\n\tvar NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;\n\tvar SLOPPY_METHOD = sloppyArrayMethod('indexOf');\n\n\t// `Array.prototype.indexOf` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n\t_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || SLOPPY_METHOD }, {\n\t  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {\n\t    return NEGATIVE_ZERO\n\t      // convert -0 to +0\n\t      ? nativeIndexOf.apply(this, arguments) || 0\n\t      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar nativeJoin = [].join;\n\n\tvar ES3_STRINGS = indexedObject != Object;\n\tvar SLOPPY_METHOD$1 = sloppyArrayMethod('join', ',');\n\n\t// `Array.prototype.join` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.join\n\t_export({ target: 'Array', proto: true, forced: ES3_STRINGS || SLOPPY_METHOD$1 }, {\n\t  join: function join(separator) {\n\t    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);\n\t  }\n\t});\n\n\tvar SPECIES$5 = wellKnownSymbol('species');\n\n\t// `SpeciesConstructor` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-speciesconstructor\n\tvar speciesConstructor = function (O, defaultConstructor) {\n\t  var C = anObject(O).constructor;\n\t  var S;\n\t  return C === undefined || (S = anObject(C)[SPECIES$5]) == undefined ? defaultConstructor : aFunction$1(S);\n\t};\n\n\tvar arrayPush = [].push;\n\tvar min$3 = Math.min;\n\tvar MAX_UINT32 = 0xFFFFFFFF;\n\n\t// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError\n\tvar SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });\n\n\t// @@split logic\n\tfixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {\n\t  var internalSplit;\n\t  if (\n\t    'abbc'.split(/(b)*/)[1] == 'c' ||\n\t    'test'.split(/(?:)/, -1).length != 4 ||\n\t    'ab'.split(/(?:ab)*/).length != 2 ||\n\t    '.'.split(/(.?)(.?)/).length != 4 ||\n\t    '.'.split(/()()/).length > 1 ||\n\t    ''.split(/.?/).length\n\t  ) {\n\t    // based on es5-shim implementation, need to rework it\n\t    internalSplit = function (separator, limit) {\n\t      var string = String(requireObjectCoercible(this));\n\t      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n\t      if (lim === 0) return [];\n\t      if (separator === undefined) return [string];\n\t      // If `separator` is not a regex, use native split\n\t      if (!isRegexp(separator)) {\n\t        return nativeSplit.call(string, separator, lim);\n\t      }\n\t      var output = [];\n\t      var flags = (separator.ignoreCase ? 'i' : '') +\n\t                  (separator.multiline ? 'm' : '') +\n\t                  (separator.unicode ? 'u' : '') +\n\t                  (separator.sticky ? 'y' : '');\n\t      var lastLastIndex = 0;\n\t      // Make `global` and avoid `lastIndex` issues by working with a copy\n\t      var separatorCopy = new RegExp(separator.source, flags + 'g');\n\t      var match, lastIndex, lastLength;\n\t      while (match = regexpExec.call(separatorCopy, string)) {\n\t        lastIndex = separatorCopy.lastIndex;\n\t        if (lastIndex > lastLastIndex) {\n\t          output.push(string.slice(lastLastIndex, match.index));\n\t          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));\n\t          lastLength = match[0].length;\n\t          lastLastIndex = lastIndex;\n\t          if (output.length >= lim) break;\n\t        }\n\t        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop\n\t      }\n\t      if (lastLastIndex === string.length) {\n\t        if (lastLength || !separatorCopy.test('')) output.push('');\n\t      } else output.push(string.slice(lastLastIndex));\n\t      return output.length > lim ? output.slice(0, lim) : output;\n\t    };\n\t  // Chakra, V8\n\t  } else if ('0'.split(undefined, 0).length) {\n\t    internalSplit = function (separator, limit) {\n\t      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);\n\t    };\n\t  } else internalSplit = nativeSplit;\n\n\t  return [\n\t    // `String.prototype.split` method\n\t    // https://tc39.github.io/ecma262/#sec-string.prototype.split\n\t    function split(separator, limit) {\n\t      var O = requireObjectCoercible(this);\n\t      var splitter = separator == undefined ? undefined : separator[SPLIT];\n\t      return splitter !== undefined\n\t        ? splitter.call(separator, O, limit)\n\t        : internalSplit.call(String(O), separator, limit);\n\t    },\n\t    // `RegExp.prototype[@@split]` method\n\t    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split\n\t    //\n\t    // NOTE: This cannot be properly polyfilled in engines that don't support\n\t    // the 'y' flag.\n\t    function (regexp, limit) {\n\t      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);\n\t      if (res.done) return res.value;\n\n\t      var rx = anObject(regexp);\n\t      var S = String(this);\n\t      var C = speciesConstructor(rx, RegExp);\n\n\t      var unicodeMatching = rx.unicode;\n\t      var flags = (rx.ignoreCase ? 'i' : '') +\n\t                  (rx.multiline ? 'm' : '') +\n\t                  (rx.unicode ? 'u' : '') +\n\t                  (SUPPORTS_Y ? 'y' : 'g');\n\n\t      // ^(? + rx + ) is needed, in combination with some S slicing, to\n\t      // simulate the 'y' flag.\n\t      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);\n\t      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n\t      if (lim === 0) return [];\n\t      if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];\n\t      var p = 0;\n\t      var q = 0;\n\t      var A = [];\n\t      while (q < S.length) {\n\t        splitter.lastIndex = SUPPORTS_Y ? q : 0;\n\t        var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));\n\t        var e;\n\t        if (\n\t          z === null ||\n\t          (e = min$3(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p\n\t        ) {\n\t          q = advanceStringIndex(S, q, unicodeMatching);\n\t        } else {\n\t          A.push(S.slice(p, q));\n\t          if (A.length === lim) return A;\n\t          for (var i = 1; i <= z.length - 1; i++) {\n\t            A.push(z[i]);\n\t            if (A.length === lim) return A;\n\t          }\n\t          q = p = e;\n\t        }\n\t      }\n\t      A.push(S.slice(p));\n\t      return A;\n\t    }\n\t  ];\n\t}, !SUPPORTS_Y);\n\n\t// Parse unit value\n\tvar numberAndUnit = /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i; // Parse hex value\n\n\tvar hex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i; // Parse rgb value\n\n\tvar rgb = /rgb\\((\\d+),(\\d+),(\\d+)\\)/; // Parse reference id\n\n\tvar reference = /(#[a-z0-9\\-_]+)/i; // splits a transformation chain\n\n\tvar transforms = /\\)\\s*,?\\s*/; // Whitespace\n\n\tvar whitespace$1 = /\\s/g; // Test hex value\n\n\tvar isHex = /^#[a-f0-9]{3,6}$/i; // Test rgb value\n\n\tvar isRgb = /^rgb\\(/; // Test css declaration\n\n\tvar isCss = /[^:]+:[^;]+;?/; // Test for blank string\n\n\tvar isBlank = /^(\\s+)?$/; // Test for numeric string\n\n\tvar isNumber = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i; // Test for percent value\n\n\tvar isPercent = /^-?[\\d.]+%$/; // Test for image url\n\n\tvar isImage = /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i; // split at whitespace and comma\n\n\tvar delimiter = /[\\s,]+/; // The following regex are used to parse the d attribute of a path\n\t// Matches all hyphens which are not after an exponent\n\n\tvar hyphen = /([^e])-/gi; // Replaces and tests for all path letters\n\n\tvar pathLetters = /[MLHVCSQTAZ]/gi; // yes we need this one, too\n\n\tvar isPathLetter = /[MLHVCSQTAZ]/i; // matches 0.154.23.45\n\n\tvar numbersWithDots = /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi; // matches .\n\n\tvar dots = /\\./g;\n\n\tvar regex = ({\n\t\t__proto__: null,\n\t\tnumberAndUnit: numberAndUnit,\n\t\thex: hex,\n\t\trgb: rgb,\n\t\treference: reference,\n\t\ttransforms: transforms,\n\t\twhitespace: whitespace$1,\n\t\tisHex: isHex,\n\t\tisRgb: isRgb,\n\t\tisCss: isCss,\n\t\tisBlank: isBlank,\n\t\tisNumber: isNumber,\n\t\tisPercent: isPercent,\n\t\tisImage: isImage,\n\t\tdelimiter: delimiter,\n\t\thyphen: hyphen,\n\t\tpathLetters: pathLetters,\n\t\tisPathLetter: isPathLetter,\n\t\tnumbersWithDots: numbersWithDots,\n\t\tdots: dots\n\t});\n\n\tfunction classes() {\n\t  var attr = this.attr('class');\n\t  return attr == null ? [] : attr.trim().split(delimiter);\n\t} // Return true if class exists on the node, false otherwise\n\n\tfunction hasClass(name) {\n\t  return this.classes().indexOf(name) !== -1;\n\t} // Add class to the node\n\n\tfunction addClass(name) {\n\t  if (!this.hasClass(name)) {\n\t    var array = this.classes();\n\t    array.push(name);\n\t    this.attr('class', array.join(' '));\n\t  }\n\n\t  return this;\n\t} // Remove class from the node\n\n\tfunction removeClass(name) {\n\t  if (this.hasClass(name)) {\n\t    this.attr('class', this.classes().filter(function (c) {\n\t      return c !== name;\n\t    }).join(' '));\n\t  }\n\n\t  return this;\n\t} // Toggle the presence of a class on the node\n\n\tfunction toggleClass(name) {\n\t  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);\n\t}\n\tregisterMethods('Dom', {\n\t  classes: classes,\n\t  hasClass: hasClass,\n\t  addClass: addClass,\n\t  removeClass: removeClass,\n\t  toggleClass: toggleClass\n\t});\n\n\tvar $forEach$1 = arrayIteration.forEach;\n\n\n\t// `Array.prototype.forEach` method implementation\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n\tvar arrayForEach = sloppyArrayMethod('forEach') ? function forEach(callbackfn /* , thisArg */) {\n\t  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t} : [].forEach;\n\n\t// `Array.prototype.forEach` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n\t_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {\n\t  forEach: arrayForEach\n\t});\n\n\tfor (var COLLECTION_NAME$1 in domIterables) {\n\t  var Collection$1 = global_1[COLLECTION_NAME$1];\n\t  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;\n\t  // some Chrome versions have non-configurable methods on DOMTokenList\n\t  if (CollectionPrototype$1 && CollectionPrototype$1.forEach !== arrayForEach) try {\n\t    createNonEnumerableProperty(CollectionPrototype$1, 'forEach', arrayForEach);\n\t  } catch (error) {\n\t    CollectionPrototype$1.forEach = arrayForEach;\n\t  }\n\t}\n\n\tfunction css(style, val) {\n\t  var ret = {};\n\n\t  if (arguments.length === 0) {\n\t    // get full style as object\n\t    this.node.style.cssText.split(/\\s*;\\s*/).filter(function (el) {\n\t      return !!el.length;\n\t    }).forEach(function (el) {\n\t      var t = el.split(/\\s*:\\s*/);\n\t      ret[t[0]] = t[1];\n\t    });\n\t    return ret;\n\t  }\n\n\t  if (arguments.length < 2) {\n\t    // get style properties in the array\n\t    if (Array.isArray(style)) {\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\n\t      try {\n\t        for (var _iterator = style[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var name = _step.value;\n\t          var cased = camelCase(name);\n\t          ret[cased] = this.node.style[cased];\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return != null) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\n\t      return ret;\n\t    } // get style for property\n\n\n\t    if (typeof style === 'string') {\n\t      return this.node.style[camelCase(style)];\n\t    } // set styles in object\n\n\n\t    if (_typeof(style) === 'object') {\n\t      for (var _name in style) {\n\t        // set empty string if null/undefined/'' was given\n\t        this.node.style[camelCase(_name)] = style[_name] == null || isBlank.test(style[_name]) ? '' : style[_name];\n\t      }\n\t    }\n\t  } // set style for property\n\n\n\t  if (arguments.length === 2) {\n\t    this.node.style[camelCase(style)] = val == null || isBlank.test(val) ? '' : val;\n\t  }\n\n\t  return this;\n\t} // Show element\n\n\tfunction show() {\n\t  return this.css('display', '');\n\t} // Hide element\n\n\tfunction hide() {\n\t  return this.css('display', 'none');\n\t} // Is element visible?\n\n\tfunction visible() {\n\t  return this.css('display') !== 'none';\n\t}\n\tregisterMethods('Dom', {\n\t  css: css,\n\t  show: show,\n\t  hide: hide,\n\t  visible: visible\n\t});\n\n\tfunction data$1(a, v, r) {\n\t  if (_typeof(a) === 'object') {\n\t    for (v in a) {\n\t      this.data(v, a[v]);\n\t    }\n\t  } else if (arguments.length < 2) {\n\t    try {\n\t      return JSON.parse(this.attr('data-' + a));\n\t    } catch (e) {\n\t      return this.attr('data-' + a);\n\t    }\n\t  } else {\n\t    this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));\n\t  }\n\n\t  return this;\n\t}\n\tregisterMethods('Dom', {\n\t  data: data$1\n\t});\n\n\tfunction remember(k, v) {\n\t  // remember every item in an object individually\n\t  if (_typeof(arguments[0]) === 'object') {\n\t    for (var key in k) {\n\t      this.remember(key, k[key]);\n\t    }\n\t  } else if (arguments.length === 1) {\n\t    // retrieve memory\n\t    return this.memory()[k];\n\t  } else {\n\t    // store memory\n\t    this.memory()[k] = v;\n\t  }\n\n\t  return this;\n\t} // Erase a given memory\n\n\tfunction forget() {\n\t  if (arguments.length === 0) {\n\t    this._memory = {};\n\t  } else {\n\t    for (var i = arguments.length - 1; i >= 0; i--) {\n\t      delete this.memory()[arguments[i]];\n\t    }\n\t  }\n\n\t  return this;\n\t} // This triggers creation of a new hidden class which is not performant\n\t// However, this function is not rarely used so it will not happen frequently\n\t// Return local memory object\n\n\tfunction memory() {\n\t  return this._memory = this._memory || {};\n\t}\n\tregisterMethods('Dom', {\n\t  remember: remember,\n\t  forget: forget,\n\t  memory: memory\n\t});\n\n\t// `Array.prototype.{ reduce, reduceRight }` methods implementation\n\tvar createMethod$4 = function (IS_RIGHT) {\n\t  return function (that, callbackfn, argumentsLength, memo) {\n\t    aFunction$1(callbackfn);\n\t    var O = toObject(that);\n\t    var self = indexedObject(O);\n\t    var length = toLength(O.length);\n\t    var index = IS_RIGHT ? length - 1 : 0;\n\t    var i = IS_RIGHT ? -1 : 1;\n\t    if (argumentsLength < 2) while (true) {\n\t      if (index in self) {\n\t        memo = self[index];\n\t        index += i;\n\t        break;\n\t      }\n\t      index += i;\n\t      if (IS_RIGHT ? index < 0 : length <= index) {\n\t        throw TypeError('Reduce of empty array with no initial value');\n\t      }\n\t    }\n\t    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n\t      memo = callbackfn(memo, self[index], index, O);\n\t    }\n\t    return memo;\n\t  };\n\t};\n\n\tvar arrayReduce = {\n\t  // `Array.prototype.reduce` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n\t  left: createMethod$4(false),\n\t  // `Array.prototype.reduceRight` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright\n\t  right: createMethod$4(true)\n\t};\n\n\tvar $reduce = arrayReduce.left;\n\n\n\t// `Array.prototype.reduce` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n\t_export({ target: 'Array', proto: true, forced: sloppyArrayMethod('reduce') }, {\n\t  reduce: function reduce(callbackfn /* , initialValue */) {\n\t    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar listenerId = 0;\n\tvar windowEvents = {};\n\n\tfunction getEvents(instance) {\n\t  var n = instance.getEventHolder(); // We dont want to save events in global space\n\n\t  if (n === globals.window) n = windowEvents;\n\t  if (!n.events) n.events = {};\n\t  return n.events;\n\t}\n\n\tfunction getEventTarget(instance) {\n\t  return instance.getEventTarget();\n\t}\n\n\tfunction clearEvents(instance) {\n\t  var n = instance.getEventHolder();\n\t  if (n.events) n.events = {};\n\t} // Add event binder in the SVG namespace\n\n\n\tfunction on(node, events, listener, binding, options) {\n\t  var l = listener.bind(binding || node);\n\t  var instance = makeInstance(node);\n\t  var bag = getEvents(instance);\n\t  var n = getEventTarget(instance); // events can be an array of events or a string of events\n\n\t  events = Array.isArray(events) ? events : events.split(delimiter); // add id to listener\n\n\t  if (!listener._svgjsListenerId) {\n\t    listener._svgjsListenerId = ++listenerId;\n\t  }\n\n\t  events.forEach(function (event) {\n\t    var ev = event.split('.')[0];\n\t    var ns = event.split('.')[1] || '*'; // ensure valid object\n\n\t    bag[ev] = bag[ev] || {};\n\t    bag[ev][ns] = bag[ev][ns] || {}; // reference listener\n\n\t    bag[ev][ns][listener._svgjsListenerId] = l; // add listener\n\n\t    n.addEventListener(ev, l, options || false);\n\t  });\n\t} // Add event unbinder in the SVG namespace\n\n\tfunction off(node, events, listener, options) {\n\t  var instance = makeInstance(node);\n\t  var bag = getEvents(instance);\n\t  var n = getEventTarget(instance); // listener can be a function or a number\n\n\t  if (typeof listener === 'function') {\n\t    listener = listener._svgjsListenerId;\n\t    if (!listener) return;\n\t  } // events can be an array of events or a string or undefined\n\n\n\t  events = Array.isArray(events) ? events : (events || '').split(delimiter);\n\t  events.forEach(function (event) {\n\t    var ev = event && event.split('.')[0];\n\t    var ns = event && event.split('.')[1];\n\t    var namespace, l;\n\n\t    if (listener) {\n\t      // remove listener reference\n\t      if (bag[ev] && bag[ev][ns || '*']) {\n\t        // removeListener\n\t        n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);\n\t        delete bag[ev][ns || '*'][listener];\n\t      }\n\t    } else if (ev && ns) {\n\t      // remove all listeners for a namespaced event\n\t      if (bag[ev] && bag[ev][ns]) {\n\t        for (l in bag[ev][ns]) {\n\t          off(n, [ev, ns].join('.'), l);\n\t        }\n\n\t        delete bag[ev][ns];\n\t      }\n\t    } else if (ns) {\n\t      // remove all listeners for a specific namespace\n\t      for (event in bag) {\n\t        for (namespace in bag[event]) {\n\t          if (ns === namespace) {\n\t            off(n, [event, ns].join('.'));\n\t          }\n\t        }\n\t      }\n\t    } else if (ev) {\n\t      // remove all listeners for the event\n\t      if (bag[ev]) {\n\t        for (namespace in bag[ev]) {\n\t          off(n, [ev, namespace].join('.'));\n\t        }\n\n\t        delete bag[ev];\n\t      }\n\t    } else {\n\t      // remove all listeners on a given node\n\t      for (event in bag) {\n\t        off(n, event);\n\t      }\n\n\t      clearEvents(instance);\n\t    }\n\t  });\n\t}\n\tfunction dispatch(node, event, data) {\n\t  var n = getEventTarget(node); // Dispatch event\n\n\t  if (event instanceof globals.window.Event) {\n\t    n.dispatchEvent(event);\n\t  } else {\n\t    event = new globals.window.CustomEvent(event, {\n\t      detail: data,\n\t      cancelable: true\n\t    });\n\t    n.dispatchEvent(event);\n\t  }\n\n\t  return event;\n\t}\n\n\tvar IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');\n\tvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\n\tvar MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';\n\n\t// We can't use this feature detection in V8 since it causes\n\t// deoptimization and serious performance degradation\n\t// https://github.com/zloirock/core-js/issues/679\n\tvar IS_CONCAT_SPREADABLE_SUPPORT = v8Version >= 51 || !fails(function () {\n\t  var array = [];\n\t  array[IS_CONCAT_SPREADABLE] = false;\n\t  return array.concat()[0] !== array;\n\t});\n\n\tvar SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');\n\n\tvar isConcatSpreadable = function (O) {\n\t  if (!isObject(O)) return false;\n\t  var spreadable = O[IS_CONCAT_SPREADABLE];\n\t  return spreadable !== undefined ? !!spreadable : isArray(O);\n\t};\n\n\tvar FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;\n\n\t// `Array.prototype.concat` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.concat\n\t// with adding support of @@isConcatSpreadable and @@species\n\t_export({ target: 'Array', proto: true, forced: FORCED }, {\n\t  concat: function concat(arg) { // eslint-disable-line no-unused-vars\n\t    var O = toObject(this);\n\t    var A = arraySpeciesCreate(O, 0);\n\t    var n = 0;\n\t    var i, k, length, len, E;\n\t    for (i = -1, length = arguments.length; i < length; i++) {\n\t      E = i === -1 ? O : arguments[i];\n\t      if (isConcatSpreadable(E)) {\n\t        len = toLength(E.length);\n\t        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n\t        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);\n\t      } else {\n\t        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n\t        createProperty(A, n++, E);\n\t      }\n\t    }\n\t    A.length = n;\n\t    return A;\n\t  }\n\t});\n\n\tvar $map = arrayIteration.map;\n\n\n\t// `Array.prototype.map` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.map\n\t// with adding support of @@species\n\t_export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('map') }, {\n\t  map: function map(callbackfn /* , thisArg */) {\n\t    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar DatePrototype = Date.prototype;\n\tvar INVALID_DATE = 'Invalid Date';\n\tvar TO_STRING = 'toString';\n\tvar nativeDateToString = DatePrototype[TO_STRING];\n\tvar getTime = DatePrototype.getTime;\n\n\t// `Date.prototype.toString` method\n\t// https://tc39.github.io/ecma262/#sec-date.prototype.tostring\n\tif (new Date(NaN) + '' != INVALID_DATE) {\n\t  redefine(DatePrototype, TO_STRING, function toString() {\n\t    var value = getTime.call(this);\n\t    // eslint-disable-next-line no-self-compare\n\t    return value === value ? nativeDateToString.call(this) : INVALID_DATE;\n\t  });\n\t}\n\n\tvar trim = stringTrim.trim;\n\n\n\tvar nativeParseInt = global_1.parseInt;\n\tvar hex$1 = /^[+-]?0[Xx]/;\n\tvar FORCED$1 = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22;\n\n\t// `parseInt` method\n\t// https://tc39.github.io/ecma262/#sec-parseint-string-radix\n\tvar _parseInt = FORCED$1 ? function parseInt(string, radix) {\n\t  var S = trim(String(string));\n\t  return nativeParseInt(S, (radix >>> 0) || (hex$1.test(S) ? 16 : 10));\n\t} : nativeParseInt;\n\n\t// `parseInt` method\n\t// https://tc39.github.io/ecma262/#sec-parseint-string-radix\n\t_export({ global: true, forced: parseInt != _parseInt }, {\n\t  parseInt: _parseInt\n\t});\n\n\tvar TO_STRING$1 = 'toString';\n\tvar RegExpPrototype = RegExp.prototype;\n\tvar nativeToString = RegExpPrototype[TO_STRING$1];\n\n\tvar NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n\t// FF44- RegExp#toString has a wrong name\n\tvar INCORRECT_NAME = nativeToString.name != TO_STRING$1;\n\n\t// `RegExp.prototype.toString` method\n\t// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring\n\tif (NOT_GENERIC || INCORRECT_NAME) {\n\t  redefine(RegExp.prototype, TO_STRING$1, function toString() {\n\t    var R = anObject(this);\n\t    var p = String(R.source);\n\t    var rf = R.flags;\n\t    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? regexpFlags.call(R) : rf);\n\t    return '/' + p + '/' + f;\n\t  }, { unsafe: true });\n\t}\n\n\tfunction _arrayWithHoles(arr) {\n\t  if (Array.isArray(arr)) return arr;\n\t}\n\n\tfunction _iterableToArrayLimit(arr, i) {\n\t  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n\t    return;\n\t  }\n\n\t  var _arr = [];\n\t  var _n = true;\n\t  var _d = false;\n\t  var _e = undefined;\n\n\t  try {\n\t    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n\t      _arr.push(_s.value);\n\n\t      if (i && _arr.length === i) break;\n\t    }\n\t  } catch (err) {\n\t    _d = true;\n\t    _e = err;\n\t  } finally {\n\t    try {\n\t      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n\t    } finally {\n\t      if (_d) throw _e;\n\t    }\n\t  }\n\n\t  return _arr;\n\t}\n\n\tfunction _nonIterableRest() {\n\t  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t}\n\n\tfunction _slicedToArray(arr, i) {\n\t  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n\t}\n\n\tfunction _defineProperties(target, props) {\n\t  for (var i = 0; i < props.length; i++) {\n\t    var descriptor = props[i];\n\t    descriptor.enumerable = descriptor.enumerable || false;\n\t    descriptor.configurable = true;\n\t    if (\"value\" in descriptor) descriptor.writable = true;\n\t    Object.defineProperty(target, descriptor.key, descriptor);\n\t  }\n\t}\n\n\tfunction _createClass(Constructor, protoProps, staticProps) {\n\t  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n\t  if (staticProps) _defineProperties(Constructor, staticProps);\n\t  return Constructor;\n\t}\n\n\tfunction sixDigitHex(hex) {\n\t  return hex.length === 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;\n\t}\n\n\tfunction componentHex(component) {\n\t  var integer = Math.round(component);\n\t  var bounded = Math.max(0, Math.min(255, integer));\n\t  var hex = bounded.toString(16);\n\t  return hex.length === 1 ? '0' + hex : hex;\n\t}\n\n\tfunction is(object, space) {\n\t  for (var i = space.length; i--;) {\n\t    if (object[space[i]] == null) {\n\t      return false;\n\t    }\n\t  }\n\n\t  return true;\n\t}\n\n\tfunction getParameters(a, b) {\n\t  var params = is(a, 'rgb') ? {\n\t    _a: a.r,\n\t    _b: a.g,\n\t    _c: a.b,\n\t    space: 'rgb'\n\t  } : is(a, 'xyz') ? {\n\t    _a: a.x,\n\t    _b: a.y,\n\t    _c: a.z,\n\t    _d: 0,\n\t    space: 'xyz'\n\t  } : is(a, 'hsl') ? {\n\t    _a: a.h,\n\t    _b: a.s,\n\t    _c: a.l,\n\t    _d: 0,\n\t    space: 'hsl'\n\t  } : is(a, 'lab') ? {\n\t    _a: a.l,\n\t    _b: a.a,\n\t    _c: a.b,\n\t    _d: 0,\n\t    space: 'lab'\n\t  } : is(a, 'lch') ? {\n\t    _a: a.l,\n\t    _b: a.c,\n\t    _c: a.h,\n\t    _d: 0,\n\t    space: 'lch'\n\t  } : is(a, 'cmyk') ? {\n\t    _a: a.c,\n\t    _b: a.m,\n\t    _c: a.y,\n\t    _d: a.k,\n\t    space: 'cmyk'\n\t  } : {\n\t    _a: 0,\n\t    _b: 0,\n\t    _c: 0,\n\t    space: 'rgb'\n\t  };\n\t  params.space = b || params.space;\n\t  return params;\n\t}\n\n\tfunction cieSpace(space) {\n\t  if (space === 'lab' || space === 'xyz' || space === 'lch') {\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\n\tfunction hueToRgb(p, q, t) {\n\t  if (t < 0) t += 1;\n\t  if (t > 1) t -= 1;\n\t  if (t < 1 / 6) return p + (q - p) * 6 * t;\n\t  if (t < 1 / 2) return q;\n\t  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n\t  return p;\n\t}\n\n\tvar Color =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function Color() {\n\t    _classCallCheck(this, Color);\n\n\t    this.init.apply(this, arguments);\n\t  }\n\n\t  _createClass(Color, [{\n\t    key: \"init\",\n\t    value: function init() {\n\t      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t      var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\t      var space = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'rgb';\n\t      // This catches the case when a falsy value is passed like ''\n\t      a = !a ? 0 : a; // Reset all values in case the init function is rerun with new color space\n\n\t      if (this.space) {\n\t        for (var component in this.space) {\n\t          delete this[this.space[component]];\n\t        }\n\t      }\n\n\t      if (typeof a === 'number') {\n\t        // Allow for the case that we don't need d...\n\t        space = typeof d === 'string' ? d : space;\n\t        d = typeof d === 'string' ? 0 : d; // Assign the values straight to the color\n\n\t        Object.assign(this, {\n\t          _a: a,\n\t          _b: b,\n\t          _c: c,\n\t          _d: d,\n\t          space: space\n\t        }); // If the user gave us an array, make the color from it\n\t      } else if (a instanceof Array) {\n\t        this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';\n\t        Object.assign(this, {\n\t          _a: a[0],\n\t          _b: a[1],\n\t          _c: a[2],\n\t          _d: a[3] || 0\n\t        });\n\t      } else if (a instanceof Object) {\n\t        // Set the object up and assign its values directly\n\t        var values = getParameters(a, b);\n\t        Object.assign(this, values);\n\t      } else if (typeof a === 'string') {\n\t        if (isRgb.test(a)) {\n\t          var noWhitespace = a.replace(whitespace$1, '');\n\n\t          var _rgb$exec$slice$map = rgb.exec(noWhitespace).slice(1, 4).map(function (v) {\n\t            return parseInt(v);\n\t          }),\n\t              _rgb$exec$slice$map2 = _slicedToArray(_rgb$exec$slice$map, 3),\n\t              _a2 = _rgb$exec$slice$map2[0],\n\t              _b2 = _rgb$exec$slice$map2[1],\n\t              _c2 = _rgb$exec$slice$map2[2];\n\n\t          Object.assign(this, {\n\t            _a: _a2,\n\t            _b: _b2,\n\t            _c: _c2,\n\t            _d: 0,\n\t            space: 'rgb'\n\t          });\n\t        } else if (isHex.test(a)) {\n\t          var hexParse = function hexParse(v) {\n\t            return parseInt(v, 16);\n\t          };\n\n\t          var _hex$exec$map = hex.exec(sixDigitHex(a)).map(hexParse),\n\t              _hex$exec$map2 = _slicedToArray(_hex$exec$map, 4),\n\t              _a3 = _hex$exec$map2[1],\n\t              _b3 = _hex$exec$map2[2],\n\t              _c3 = _hex$exec$map2[3];\n\n\t          Object.assign(this, {\n\t            _a: _a3,\n\t            _b: _b3,\n\t            _c: _c3,\n\t            _d: 0,\n\t            space: 'rgb'\n\t          });\n\t        } else throw Error('Unsupported string format, can\\'t construct Color');\n\t      } // Now add the components as a convenience\n\n\n\t      var _a = this._a,\n\t          _b = this._b,\n\t          _c = this._c,\n\t          _d = this._d;\n\t      var components = this.space === 'rgb' ? {\n\t        r: _a,\n\t        g: _b,\n\t        b: _c\n\t      } : this.space === 'xyz' ? {\n\t        x: _a,\n\t        y: _b,\n\t        z: _c\n\t      } : this.space === 'hsl' ? {\n\t        h: _a,\n\t        s: _b,\n\t        l: _c\n\t      } : this.space === 'lab' ? {\n\t        l: _a,\n\t        a: _b,\n\t        b: _c\n\t      } : this.space === 'lch' ? {\n\t        l: _a,\n\t        c: _b,\n\t        h: _c\n\t      } : this.space === 'cmyk' ? {\n\t        c: _a,\n\t        m: _b,\n\t        y: _c,\n\t        k: _d\n\t      } : {};\n\t      Object.assign(this, components);\n\t    }\n\t    /*\n\t    Conversion Methods\n\t    */\n\n\t  }, {\n\t    key: \"rgb\",\n\t    value: function rgb() {\n\t      if (this.space === 'rgb') {\n\t        return this;\n\t      } else if (cieSpace(this.space)) {\n\t        // Convert to the xyz color space\n\t        var x = this.x,\n\t            y = this.y,\n\t            z = this.z;\n\n\t        if (this.space === 'lab' || this.space === 'lch') {\n\t          // Get the values in the lab space\n\t          var l = this.l,\n\t              a = this.a,\n\t              _b4 = this.b;\n\n\t          if (this.space === 'lch') {\n\t            var c = this.c,\n\t                h = this.h;\n\t            var dToR = Math.PI / 180;\n\t            a = c * Math.cos(dToR * h);\n\t            _b4 = c * Math.sin(dToR * h);\n\t          } // Undo the nonlinear function\n\n\n\t          var yL = (l + 16) / 116;\n\t          var xL = a / 500 + yL;\n\t          var zL = yL - _b4 / 200; // Get the xyz values\n\n\t          var ct = 16 / 116;\n\t          var mx = 0.008856;\n\t          var nm = 7.787;\n\t          x = 0.95047 * (Math.pow(xL, 3) > mx ? Math.pow(xL, 3) : (xL - ct) / nm);\n\t          y = 1.00000 * (Math.pow(yL, 3) > mx ? Math.pow(yL, 3) : (yL - ct) / nm);\n\t          z = 1.08883 * (Math.pow(zL, 3) > mx ? Math.pow(zL, 3) : (zL - ct) / nm);\n\t        } // Convert xyz to unbounded rgb values\n\n\n\t        var rU = x * 3.2406 + y * -1.5372 + z * -0.4986;\n\t        var gU = x * -0.9689 + y * 1.8758 + z * 0.0415;\n\t        var bU = x * 0.0557 + y * -0.2040 + z * 1.0570; // Convert the values to true rgb values\n\n\t        var pow = Math.pow;\n\t        var bd = 0.0031308;\n\t        var r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;\n\t        var g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;\n\t        var b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU; // Make and return the color\n\n\t        var color = new Color(255 * r, 255 * g, 255 * b);\n\t        return color;\n\t      } else if (this.space === 'hsl') {\n\t        // https://bgrins.github.io/TinyColor/docs/tinycolor.html\n\t        // Get the current hsl values\n\t        var _h = this.h,\n\t            s = this.s,\n\t            _l = this.l;\n\t        _h /= 360;\n\t        s /= 100;\n\t        _l /= 100; // If we are grey, then just make the color directly\n\n\t        if (s === 0) {\n\t          _l *= 255;\n\n\t          var _color2 = new Color(_l, _l, _l);\n\n\t          return _color2;\n\t        } // TODO I have no idea what this does :D If you figure it out, tell me!\n\n\n\t        var q = _l < 0.5 ? _l * (1 + s) : _l + s - _l * s;\n\t        var p = 2 * _l - q; // Get the rgb values\n\n\t        var _r = 255 * hueToRgb(p, q, _h + 1 / 3);\n\n\t        var _g = 255 * hueToRgb(p, q, _h);\n\n\t        var _b5 = 255 * hueToRgb(p, q, _h - 1 / 3); // Make a new color\n\n\n\t        var _color = new Color(_r, _g, _b5);\n\n\t        return _color;\n\t      } else if (this.space === 'cmyk') {\n\t        // https://gist.github.com/felipesabino/5066336\n\t        // Get the normalised cmyk values\n\t        var _c4 = this.c,\n\t            m = this.m,\n\t            _y = this.y,\n\t            k = this.k; // Get the rgb values\n\n\t        var _r2 = 255 * (1 - Math.min(1, _c4 * (1 - k) + k));\n\n\t        var _g2 = 255 * (1 - Math.min(1, m * (1 - k) + k));\n\n\t        var _b6 = 255 * (1 - Math.min(1, _y * (1 - k) + k)); // Form the color and return it\n\n\n\t        var _color3 = new Color(_r2, _g2, _b6);\n\n\t        return _color3;\n\t      } else {\n\t        return this;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"lab\",\n\t    value: function lab() {\n\t      // Get the xyz color\n\t      var _this$xyz = this.xyz(),\n\t          x = _this$xyz.x,\n\t          y = _this$xyz.y,\n\t          z = _this$xyz.z; // Get the lab components\n\n\n\t      var l = 116 * y - 16;\n\t      var a = 500 * (x - y);\n\t      var b = 200 * (y - z); // Construct and return a new color\n\n\t      var color = new Color(l, a, b, 'lab');\n\t      return color;\n\t    }\n\t  }, {\n\t    key: \"xyz\",\n\t    value: function xyz() {\n\t      // Normalise the red, green and blue values\n\t      var _this$rgb = this.rgb(),\n\t          r255 = _this$rgb._a,\n\t          g255 = _this$rgb._b,\n\t          b255 = _this$rgb._c;\n\n\t      var _map = [r255, g255, b255].map(function (v) {\n\t        return v / 255;\n\t      }),\n\t          _map2 = _slicedToArray(_map, 3),\n\t          r = _map2[0],\n\t          g = _map2[1],\n\t          b = _map2[2]; // Convert to the lab rgb space\n\n\n\t      var rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n\t      var gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n\t      var bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92; // Convert to the xyz color space without bounding the values\n\n\t      var xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;\n\t      var yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.00000;\n\t      var zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883; // Get the proper xyz values by applying the bounding\n\n\t      var x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;\n\t      var y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;\n\t      var z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116; // Make and return the color\n\n\t      var color = new Color(x, y, z, 'xyz');\n\t      return color;\n\t    }\n\t  }, {\n\t    key: \"lch\",\n\t    value: function lch() {\n\t      // Get the lab color directly\n\t      var _this$lab = this.lab(),\n\t          l = _this$lab.l,\n\t          a = _this$lab.a,\n\t          b = _this$lab.b; // Get the chromaticity and the hue using polar coordinates\n\n\n\t      var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n\t      var h = 180 * Math.atan2(b, a) / Math.PI;\n\n\t      if (h < 0) {\n\t        h *= -1;\n\t        h = 360 - h;\n\t      } // Make a new color and return it\n\n\n\t      var color = new Color(l, c, h, 'lch');\n\t      return color;\n\t    }\n\t  }, {\n\t    key: \"hsl\",\n\t    value: function hsl() {\n\t      // Get the rgb values\n\t      var _this$rgb2 = this.rgb(),\n\t          _a = _this$rgb2._a,\n\t          _b = _this$rgb2._b,\n\t          _c = _this$rgb2._c;\n\n\t      var _map3 = [_a, _b, _c].map(function (v) {\n\t        return v / 255;\n\t      }),\n\t          _map4 = _slicedToArray(_map3, 3),\n\t          r = _map4[0],\n\t          g = _map4[1],\n\t          b = _map4[2]; // Find the maximum and minimum values to get the lightness\n\n\n\t      var max = Math.max(r, g, b);\n\t      var min = Math.min(r, g, b);\n\t      var l = (max + min) / 2; // If the r, g, v values are identical then we are grey\n\n\t      var isGrey = max === min; // Calculate the hue and saturation\n\n\t      var delta = max - min;\n\t      var s = isGrey ? 0 : l > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n\t      var h = isGrey ? 0 : max === r ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max === g ? ((b - r) / delta + 2) / 6 : max === b ? ((r - g) / delta + 4) / 6 : 0; // Construct and return the new color\n\n\t      var color = new Color(360 * h, 100 * s, 100 * l, 'hsl');\n\t      return color;\n\t    }\n\t  }, {\n\t    key: \"cmyk\",\n\t    value: function cmyk() {\n\t      // Get the rgb values for the current color\n\t      var _this$rgb3 = this.rgb(),\n\t          _a = _this$rgb3._a,\n\t          _b = _this$rgb3._b,\n\t          _c = _this$rgb3._c;\n\n\t      var _map5 = [_a, _b, _c].map(function (v) {\n\t        return v / 255;\n\t      }),\n\t          _map6 = _slicedToArray(_map5, 3),\n\t          r = _map6[0],\n\t          g = _map6[1],\n\t          b = _map6[2]; // Get the cmyk values in an unbounded format\n\n\n\t      var k = Math.min(1 - r, 1 - g, 1 - b);\n\n\t      if (k === 1) {\n\t        // Catch the black case\n\t        return new Color(0, 0, 0, 1, 'cmyk');\n\t      }\n\n\t      var c = (1 - r - k) / (1 - k);\n\t      var m = (1 - g - k) / (1 - k);\n\t      var y = (1 - b - k) / (1 - k); // Construct the new color\n\n\t      var color = new Color(c, m, y, k, 'cmyk');\n\t      return color;\n\t    }\n\t    /*\n\t    Input and Output methods\n\t    */\n\n\t  }, {\n\t    key: \"_clamped\",\n\t    value: function _clamped() {\n\t      var _this$rgb4 = this.rgb(),\n\t          _a = _this$rgb4._a,\n\t          _b = _this$rgb4._b,\n\t          _c = _this$rgb4._c;\n\n\t      var max = Math.max,\n\t          min = Math.min,\n\t          round = Math.round;\n\n\t      var format = function format(v) {\n\t        return max(0, min(round(v), 255));\n\t      };\n\n\t      return [_a, _b, _c].map(format);\n\t    }\n\t  }, {\n\t    key: \"toHex\",\n\t    value: function toHex() {\n\t      var _this$_clamped$map = this._clamped().map(componentHex),\n\t          _this$_clamped$map2 = _slicedToArray(_this$_clamped$map, 3),\n\t          r = _this$_clamped$map2[0],\n\t          g = _this$_clamped$map2[1],\n\t          b = _this$_clamped$map2[2];\n\n\t      return \"#\".concat(r).concat(g).concat(b);\n\t    }\n\t  }, {\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      return this.toHex();\n\t    }\n\t  }, {\n\t    key: \"toRgb\",\n\t    value: function toRgb() {\n\t      var _this$_clamped = this._clamped(),\n\t          _this$_clamped2 = _slicedToArray(_this$_clamped, 3),\n\t          rV = _this$_clamped2[0],\n\t          gV = _this$_clamped2[1],\n\t          bV = _this$_clamped2[2];\n\n\t      var string = \"rgb(\".concat(rV, \",\").concat(gV, \",\").concat(bV, \")\");\n\t      return string;\n\t    }\n\t  }, {\n\t    key: \"toArray\",\n\t    value: function toArray() {\n\t      var _a = this._a,\n\t          _b = this._b,\n\t          _c = this._c,\n\t          _d = this._d,\n\t          space = this.space;\n\t      return [_a, _b, _c, _d, space];\n\t    }\n\t    /*\n\t    Generating random colors\n\t    */\n\n\t  }], [{\n\t    key: \"random\",\n\t    value: function random() {\n\t      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'vibrant';\n\t      var t = arguments.length > 1 ? arguments[1] : undefined;\n\t      // Get the math modules\n\t      var random = Math.random,\n\t          round = Math.round,\n\t          sin = Math.sin,\n\t          pi = Math.PI; // Run the correct generator\n\n\t      if (mode === 'vibrant') {\n\t        var l = (81 - 57) * random() + 57;\n\t        var c = (83 - 45) * random() + 45;\n\t        var h = 360 * random();\n\t        var color = new Color(l, c, h, 'lch');\n\t        return color;\n\t      } else if (mode === 'sine') {\n\t        t = t == null ? random() : t;\n\t        var r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);\n\t        var g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);\n\t        var b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);\n\n\t        var _color4 = new Color(r, g, b);\n\n\t        return _color4;\n\t      } else if (mode === 'pastel') {\n\t        var _l2 = (94 - 86) * random() + 86;\n\n\t        var _c5 = (26 - 9) * random() + 9;\n\n\t        var _h2 = 360 * random();\n\n\t        var _color5 = new Color(_l2, _c5, _h2, 'lch');\n\n\t        return _color5;\n\t      } else if (mode === 'dark') {\n\t        var _l3 = 10 + 10 * random();\n\n\t        var _c6 = (125 - 75) * random() + 86;\n\n\t        var _h3 = 360 * random();\n\n\t        var _color6 = new Color(_l3, _c6, _h3, 'lch');\n\n\t        return _color6;\n\t      } else if (mode === 'rgb') {\n\t        var _r3 = 255 * random();\n\n\t        var _g3 = 255 * random();\n\n\t        var _b7 = 255 * random();\n\n\t        var _color7 = new Color(_r3, _g3, _b7);\n\n\t        return _color7;\n\t      } else if (mode === 'lab') {\n\t        var _l4 = 100 * random();\n\n\t        var a = 256 * random() - 128;\n\n\t        var _b8 = 256 * random() - 128;\n\n\t        var _color8 = new Color(_l4, a, _b8, 'lab');\n\n\t        return _color8;\n\t      } else if (mode === 'grey') {\n\t        var grey = 255 * random();\n\n\t        var _color9 = new Color(grey, grey, grey);\n\n\t        return _color9;\n\t      }\n\t    }\n\t    /*\n\t    Constructing colors\n\t    */\n\t    // Test if given value is a color string\n\n\t  }, {\n\t    key: \"test\",\n\t    value: function test(color) {\n\t      return typeof color === 'string' && (isHex.test(color) || isRgb.test(color));\n\t    } // Test if given value is an rgb object\n\n\t  }, {\n\t    key: \"isRgb\",\n\t    value: function isRgb(color) {\n\t      return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';\n\t    } // Test if given value is a color\n\n\t  }, {\n\t    key: \"isColor\",\n\t    value: function isColor(color) {\n\t      return color && (color instanceof Color || this.isRgb(color) || this.test(color));\n\t    }\n\t  }]);\n\n\t  return Color;\n\t}();\n\n\tvar FAILS_ON_PRIMITIVES$1 = fails(function () { objectKeys(1); });\n\n\t// `Object.keys` method\n\t// https://tc39.github.io/ecma262/#sec-object.keys\n\t_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$1 }, {\n\t  keys: function keys(it) {\n\t    return objectKeys(toObject(it));\n\t  }\n\t});\n\n\t// @@match logic\n\tfixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {\n\t  return [\n\t    // `String.prototype.match` method\n\t    // https://tc39.github.io/ecma262/#sec-string.prototype.match\n\t    function match(regexp) {\n\t      var O = requireObjectCoercible(this);\n\t      var matcher = regexp == undefined ? undefined : regexp[MATCH];\n\t      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n\t    },\n\t    // `RegExp.prototype[@@match]` method\n\t    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match\n\t    function (regexp) {\n\t      var res = maybeCallNative(nativeMatch, regexp, this);\n\t      if (res.done) return res.value;\n\n\t      var rx = anObject(regexp);\n\t      var S = String(this);\n\n\t      if (!rx.global) return regexpExecAbstract(rx, S);\n\n\t      var fullUnicode = rx.unicode;\n\t      rx.lastIndex = 0;\n\t      var A = [];\n\t      var n = 0;\n\t      var result;\n\t      while ((result = regexpExecAbstract(rx, S)) !== null) {\n\t        var matchStr = String(result[0]);\n\t        A[n] = matchStr;\n\t        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n\t        n++;\n\t      }\n\t      return n === 0 ? null : A;\n\t    }\n\t  ];\n\t});\n\n\tfunction _assertThisInitialized(self) {\n\t  if (self === void 0) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\n\t  return self;\n\t}\n\n\tfunction _possibleConstructorReturn(self, call) {\n\t  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n\t    return call;\n\t  }\n\n\t  return _assertThisInitialized(self);\n\t}\n\n\tfunction _getPrototypeOf(o) {\n\t  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n\t    return o.__proto__ || Object.getPrototypeOf(o);\n\t  };\n\t  return _getPrototypeOf(o);\n\t}\n\n\tfunction _superPropBase(object, property) {\n\t  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n\t    object = _getPrototypeOf(object);\n\t    if (object === null) break;\n\t  }\n\n\t  return object;\n\t}\n\n\tfunction _get(target, property, receiver) {\n\t  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n\t    _get = Reflect.get;\n\t  } else {\n\t    _get = function _get(target, property, receiver) {\n\t      var base = _superPropBase(target, property);\n\t      if (!base) return;\n\t      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n\t      if (desc.get) {\n\t        return desc.get.call(receiver);\n\t      }\n\n\t      return desc.value;\n\t    };\n\t  }\n\n\t  return _get(target, property, receiver || target);\n\t}\n\n\tfunction _setPrototypeOf(o, p) {\n\t  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n\t    o.__proto__ = p;\n\t    return o;\n\t  };\n\n\t  return _setPrototypeOf(o, p);\n\t}\n\n\tfunction _inherits(subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function\");\n\t  }\n\n\t  subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) _setPrototypeOf(subClass, superClass);\n\t}\n\n\tvar getOwnPropertyNames = objectGetOwnPropertyNames.f;\n\tvar getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\n\tvar defineProperty$5 = objectDefineProperty.f;\n\tvar trim$1 = stringTrim.trim;\n\n\tvar NUMBER = 'Number';\n\tvar NativeNumber = global_1[NUMBER];\n\tvar NumberPrototype = NativeNumber.prototype;\n\n\t// Opera ~12 has broken Object#toString\n\tvar BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER;\n\n\t// `ToNumber` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-tonumber\n\tvar toNumber = function (argument) {\n\t  var it = toPrimitive(argument, false);\n\t  var first, third, radix, maxCode, digits, length, index, code;\n\t  if (typeof it == 'string' && it.length > 2) {\n\t    it = trim$1(it);\n\t    first = it.charCodeAt(0);\n\t    if (first === 43 || first === 45) {\n\t      third = it.charCodeAt(2);\n\t      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n\t    } else if (first === 48) {\n\t      switch (it.charCodeAt(1)) {\n\t        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i\n\t        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i\n\t        default: return +it;\n\t      }\n\t      digits = it.slice(2);\n\t      length = digits.length;\n\t      for (index = 0; index < length; index++) {\n\t        code = digits.charCodeAt(index);\n\t        // parseInt parses a string to a first unavailable symbol\n\t        // but ToNumber should return NaN if a string contains unavailable symbols\n\t        if (code < 48 || code > maxCode) return NaN;\n\t      } return parseInt(digits, radix);\n\t    }\n\t  } return +it;\n\t};\n\n\t// `Number` constructor\n\t// https://tc39.github.io/ecma262/#sec-number-constructor\n\tif (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {\n\t  var NumberWrapper = function Number(value) {\n\t    var it = arguments.length < 1 ? 0 : value;\n\t    var dummy = this;\n\t    return dummy instanceof NumberWrapper\n\t      // check on 1..constructor(foo) case\n\t      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classofRaw(dummy) != NUMBER)\n\t        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);\n\t  };\n\t  for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : (\n\t    // ES3:\n\t    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n\t    // ES2015 (in case, if modules with ES2015 Number statics required before):\n\t    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n\t    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n\t  ).split(','), j = 0, key; keys$1.length > j; j++) {\n\t    if (has(NativeNumber, key = keys$1[j]) && !has(NumberWrapper, key)) {\n\t      defineProperty$5(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));\n\t    }\n\t  }\n\t  NumberWrapper.prototype = NumberPrototype;\n\t  NumberPrototype.constructor = NumberWrapper;\n\t  redefine(global_1, NUMBER, NumberWrapper);\n\t}\n\n\tvar trim$2 = stringTrim.trim;\n\n\n\tvar nativeParseFloat = global_1.parseFloat;\n\tvar FORCED$2 = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity;\n\n\t// `parseFloat` method\n\t// https://tc39.github.io/ecma262/#sec-parsefloat-string\n\tvar _parseFloat = FORCED$2 ? function parseFloat(string) {\n\t  var trimmedString = trim$2(String(string));\n\t  var result = nativeParseFloat(trimmedString);\n\t  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;\n\t} : nativeParseFloat;\n\n\t// `parseFloat` method\n\t// https://tc39.github.io/ecma262/#sec-parsefloat-string\n\t_export({ global: true, forced: parseFloat != _parseFloat }, {\n\t  parseFloat: _parseFloat\n\t});\n\n\tvar Point =\n\t/*#__PURE__*/\n\tfunction () {\n\t  // Initialize\n\t  function Point() {\n\t    _classCallCheck(this, Point);\n\n\t    this.init.apply(this, arguments);\n\t  }\n\n\t  _createClass(Point, [{\n\t    key: \"init\",\n\t    value: function init(x, y) {\n\t      var base = {\n\t        x: 0,\n\t        y: 0\n\t      }; // ensure source as object\n\n\t      var source = Array.isArray(x) ? {\n\t        x: x[0],\n\t        y: x[1]\n\t      } : _typeof(x) === 'object' ? {\n\t        x: x.x,\n\t        y: x.y\n\t      } : {\n\t        x: x,\n\t        y: y\n\t      }; // merge source\n\n\t      this.x = source.x == null ? base.x : source.x;\n\t      this.y = source.y == null ? base.y : source.y;\n\t      return this;\n\t    } // Clone point\n\n\t  }, {\n\t    key: \"clone\",\n\t    value: function clone() {\n\t      return new Point(this);\n\t    }\n\t  }, {\n\t    key: \"transform\",\n\t    value: function transform(m) {\n\t      return this.clone().transformO(m);\n\t    } // Transform point with matrix\n\n\t  }, {\n\t    key: \"transformO\",\n\t    value: function transformO(m) {\n\t      if (!Matrix.isMatrixLike(m)) {\n\t        m = new Matrix(m);\n\t      }\n\n\t      var x = this.x,\n\t          y = this.y; // Perform the matrix multiplication\n\n\t      this.x = m.a * x + m.c * y + m.e;\n\t      this.y = m.b * x + m.d * y + m.f;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"toArray\",\n\t    value: function toArray() {\n\t      return [this.x, this.y];\n\t    }\n\t  }]);\n\n\t  return Point;\n\t}();\n\tfunction point(x, y) {\n\t  return new Point(x, y).transform(this.screenCTM().inverse());\n\t}\n\n\tfunction closeEnough(a, b, threshold) {\n\t  return Math.abs(b - a) < (threshold || 1e-6);\n\t}\n\n\tvar Matrix =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function Matrix() {\n\t    _classCallCheck(this, Matrix);\n\n\t    this.init.apply(this, arguments);\n\t  } // Initialize\n\n\n\t  _createClass(Matrix, [{\n\t    key: \"init\",\n\t    value: function init(source) {\n\t      var base = Matrix.fromArray([1, 0, 0, 1, 0, 0]); // ensure source as object\n\n\t      source = source instanceof Element ? source.matrixify() : typeof source === 'string' ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : _typeof(source) === 'object' && Matrix.isMatrixLike(source) ? source : _typeof(source) === 'object' ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base; // Merge the source matrix with the base matrix\n\n\t      this.a = source.a != null ? source.a : base.a;\n\t      this.b = source.b != null ? source.b : base.b;\n\t      this.c = source.c != null ? source.c : base.c;\n\t      this.d = source.d != null ? source.d : base.d;\n\t      this.e = source.e != null ? source.e : base.e;\n\t      this.f = source.f != null ? source.f : base.f;\n\t      return this;\n\t    } // Clones this matrix\n\n\t  }, {\n\t    key: \"clone\",\n\t    value: function clone() {\n\t      return new Matrix(this);\n\t    } // Transform a matrix into another matrix by manipulating the space\n\n\t  }, {\n\t    key: \"transform\",\n\t    value: function transform(o) {\n\t      // Check if o is a matrix and then left multiply it directly\n\t      if (Matrix.isMatrixLike(o)) {\n\t        var matrix = new Matrix(o);\n\t        return matrix.multiplyO(this);\n\t      } // Get the proposed transformations and the current transformations\n\n\n\t      var t = Matrix.formatTransforms(o);\n\t      var current = this;\n\n\t      var _transform = new Point(t.ox, t.oy).transform(current),\n\t          ox = _transform.x,\n\t          oy = _transform.y; // Construct the resulting matrix\n\n\n\t      var transformer = new Matrix().translateO(t.rx, t.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(ox, oy); // If we want the origin at a particular place, we force it there\n\n\t      if (isFinite(t.px) || isFinite(t.py)) {\n\t        var origin = new Point(ox, oy).transform(transformer); // TODO: Replace t.px with isFinite(t.px)\n\n\t        var dx = t.px ? t.px - origin.x : 0;\n\t        var dy = t.py ? t.py - origin.y : 0;\n\t        transformer.translateO(dx, dy);\n\t      } // Translate now after positioning\n\n\n\t      transformer.translateO(t.tx, t.ty);\n\t      return transformer;\n\t    } // Applies a matrix defined by its affine parameters\n\n\t  }, {\n\t    key: \"compose\",\n\t    value: function compose(o) {\n\t      if (o.origin) {\n\t        o.originX = o.origin[0];\n\t        o.originY = o.origin[1];\n\t      } // Get the parameters\n\n\n\t      var ox = o.originX || 0;\n\t      var oy = o.originY || 0;\n\t      var sx = o.scaleX || 1;\n\t      var sy = o.scaleY || 1;\n\t      var lam = o.shear || 0;\n\t      var theta = o.rotate || 0;\n\t      var tx = o.translateX || 0;\n\t      var ty = o.translateY || 0; // Apply the standard matrix\n\n\t      var result = new Matrix().translateO(-ox, -oy).scaleO(sx, sy).shearO(lam).rotateO(theta).translateO(tx, ty).lmultiplyO(this).translateO(ox, oy);\n\t      return result;\n\t    } // Decomposes this matrix into its affine parameters\n\n\t  }, {\n\t    key: \"decompose\",\n\t    value: function decompose() {\n\t      var cx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t      var cy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t      // Get the parameters from the matrix\n\t      var a = this.a;\n\t      var b = this.b;\n\t      var c = this.c;\n\t      var d = this.d;\n\t      var e = this.e;\n\t      var f = this.f; // Figure out if the winding direction is clockwise or counterclockwise\n\n\t      var determinant = a * d - b * c;\n\t      var ccw = determinant > 0 ? 1 : -1; // Since we only shear in x, we can use the x basis to get the x scale\n\t      // and the rotation of the resulting matrix\n\n\t      var sx = ccw * Math.sqrt(a * a + b * b);\n\t      var thetaRad = Math.atan2(ccw * b, ccw * a);\n\t      var theta = 180 / Math.PI * thetaRad;\n\t      var ct = Math.cos(thetaRad);\n\t      var st = Math.sin(thetaRad); // We can then solve the y basis vector simultaneously to get the other\n\t      // two affine parameters directly from these parameters\n\n\t      var lam = (a * c + b * d) / determinant;\n\t      var sy = c * sx / (lam * a - b) || d * sx / (lam * b + a); // Use the translations\n\n\t      var tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);\n\t      var ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy); // Construct the decomposition and return it\n\n\t      return {\n\t        // Return the affine parameters\n\t        scaleX: sx,\n\t        scaleY: sy,\n\t        shear: lam,\n\t        rotate: theta,\n\t        translateX: tx,\n\t        translateY: ty,\n\t        originX: cx,\n\t        originY: cy,\n\t        // Return the matrix parameters\n\t        a: this.a,\n\t        b: this.b,\n\t        c: this.c,\n\t        d: this.d,\n\t        e: this.e,\n\t        f: this.f\n\t      };\n\t    } // Left multiplies by the given matrix\n\n\t  }, {\n\t    key: \"multiply\",\n\t    value: function multiply(matrix) {\n\t      return this.clone().multiplyO(matrix);\n\t    }\n\t  }, {\n\t    key: \"multiplyO\",\n\t    value: function multiplyO(matrix) {\n\t      // Get the matrices\n\t      var l = this;\n\t      var r = matrix instanceof Matrix ? matrix : new Matrix(matrix);\n\t      return Matrix.matrixMultiply(l, r, this);\n\t    }\n\t  }, {\n\t    key: \"lmultiply\",\n\t    value: function lmultiply(matrix) {\n\t      return this.clone().lmultiplyO(matrix);\n\t    }\n\t  }, {\n\t    key: \"lmultiplyO\",\n\t    value: function lmultiplyO(matrix) {\n\t      var r = this;\n\t      var l = matrix instanceof Matrix ? matrix : new Matrix(matrix);\n\t      return Matrix.matrixMultiply(l, r, this);\n\t    } // Inverses matrix\n\n\t  }, {\n\t    key: \"inverseO\",\n\t    value: function inverseO() {\n\t      // Get the current parameters out of the matrix\n\t      var a = this.a;\n\t      var b = this.b;\n\t      var c = this.c;\n\t      var d = this.d;\n\t      var e = this.e;\n\t      var f = this.f; // Invert the 2x2 matrix in the top left\n\n\t      var det = a * d - b * c;\n\t      if (!det) throw new Error('Cannot invert ' + this); // Calculate the top 2x2 matrix\n\n\t      var na = d / det;\n\t      var nb = -b / det;\n\t      var nc = -c / det;\n\t      var nd = a / det; // Apply the inverted matrix to the top right\n\n\t      var ne = -(na * e + nc * f);\n\t      var nf = -(nb * e + nd * f); // Construct the inverted matrix\n\n\t      this.a = na;\n\t      this.b = nb;\n\t      this.c = nc;\n\t      this.d = nd;\n\t      this.e = ne;\n\t      this.f = nf;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"inverse\",\n\t    value: function inverse() {\n\t      return this.clone().inverseO();\n\t    } // Translate matrix\n\n\t  }, {\n\t    key: \"translate\",\n\t    value: function translate(x, y) {\n\t      return this.clone().translateO(x, y);\n\t    }\n\t  }, {\n\t    key: \"translateO\",\n\t    value: function translateO(x, y) {\n\t      this.e += x || 0;\n\t      this.f += y || 0;\n\t      return this;\n\t    } // Scale matrix\n\n\t  }, {\n\t    key: \"scale\",\n\t    value: function scale(x, y, cx, cy) {\n\t      var _this$clone;\n\n\t      return (_this$clone = this.clone()).scaleO.apply(_this$clone, arguments);\n\t    }\n\t  }, {\n\t    key: \"scaleO\",\n\t    value: function scaleO(x) {\n\t      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n\t      var cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t      var cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n\t      // Support uniform scaling\n\t      if (arguments.length === 3) {\n\t        cy = cx;\n\t        cx = y;\n\t        y = x;\n\t      }\n\n\t      var a = this.a,\n\t          b = this.b,\n\t          c = this.c,\n\t          d = this.d,\n\t          e = this.e,\n\t          f = this.f;\n\t      this.a = a * x;\n\t      this.b = b * y;\n\t      this.c = c * x;\n\t      this.d = d * y;\n\t      this.e = e * x - cx * x + cx;\n\t      this.f = f * y - cy * y + cy;\n\t      return this;\n\t    } // Rotate matrix\n\n\t  }, {\n\t    key: \"rotate\",\n\t    value: function rotate(r, cx, cy) {\n\t      return this.clone().rotateO(r, cx, cy);\n\t    }\n\t  }, {\n\t    key: \"rotateO\",\n\t    value: function rotateO(r) {\n\t      var cx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t      var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t      // Convert degrees to radians\n\t      r = radians(r);\n\t      var cos = Math.cos(r);\n\t      var sin = Math.sin(r);\n\t      var a = this.a,\n\t          b = this.b,\n\t          c = this.c,\n\t          d = this.d,\n\t          e = this.e,\n\t          f = this.f;\n\t      this.a = a * cos - b * sin;\n\t      this.b = b * cos + a * sin;\n\t      this.c = c * cos - d * sin;\n\t      this.d = d * cos + c * sin;\n\t      this.e = e * cos - f * sin + cy * sin - cx * cos + cx;\n\t      this.f = f * cos + e * sin - cx * sin - cy * cos + cy;\n\t      return this;\n\t    } // Flip matrix on x or y, at a given offset\n\n\t  }, {\n\t    key: \"flip\",\n\t    value: function flip(axis, around) {\n\t      return this.clone().flipO(axis, around);\n\t    }\n\t  }, {\n\t    key: \"flipO\",\n\t    value: function flipO(axis, around) {\n\t      return axis === 'x' ? this.scaleO(-1, 1, around, 0) : axis === 'y' ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis); // Define an x, y flip point\n\t    } // Shear matrix\n\n\t  }, {\n\t    key: \"shear\",\n\t    value: function shear(a, cx, cy) {\n\t      return this.clone().shearO(a, cx, cy);\n\t    }\n\t  }, {\n\t    key: \"shearO\",\n\t    value: function shearO(lx) {\n\t      var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t      var a = this.a,\n\t          b = this.b,\n\t          c = this.c,\n\t          d = this.d,\n\t          e = this.e,\n\t          f = this.f;\n\t      this.a = a + b * lx;\n\t      this.c = c + d * lx;\n\t      this.e = e + f * lx - cy * lx;\n\t      return this;\n\t    } // Skew Matrix\n\n\t  }, {\n\t    key: \"skew\",\n\t    value: function skew(x, y, cx, cy) {\n\t      var _this$clone2;\n\n\t      return (_this$clone2 = this.clone()).skewO.apply(_this$clone2, arguments);\n\t    }\n\t  }, {\n\t    key: \"skewO\",\n\t    value: function skewO(x) {\n\t      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n\t      var cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t      var cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n\t      // support uniformal skew\n\t      if (arguments.length === 3) {\n\t        cy = cx;\n\t        cx = y;\n\t        y = x;\n\t      } // Convert degrees to radians\n\n\n\t      x = radians(x);\n\t      y = radians(y);\n\t      var lx = Math.tan(x);\n\t      var ly = Math.tan(y);\n\t      var a = this.a,\n\t          b = this.b,\n\t          c = this.c,\n\t          d = this.d,\n\t          e = this.e,\n\t          f = this.f;\n\t      this.a = a + b * lx;\n\t      this.b = b + a * ly;\n\t      this.c = c + d * lx;\n\t      this.d = d + c * ly;\n\t      this.e = e + f * lx - cy * lx;\n\t      this.f = f + e * ly - cx * ly;\n\t      return this;\n\t    } // SkewX\n\n\t  }, {\n\t    key: \"skewX\",\n\t    value: function skewX(x, cx, cy) {\n\t      return this.skew(x, 0, cx, cy);\n\t    }\n\t  }, {\n\t    key: \"skewXO\",\n\t    value: function skewXO(x, cx, cy) {\n\t      return this.skewO(x, 0, cx, cy);\n\t    } // SkewY\n\n\t  }, {\n\t    key: \"skewY\",\n\t    value: function skewY(y, cx, cy) {\n\t      return this.skew(0, y, cx, cy);\n\t    }\n\t  }, {\n\t    key: \"skewYO\",\n\t    value: function skewYO(y, cx, cy) {\n\t      return this.skewO(0, y, cx, cy);\n\t    } // Transform around a center point\n\n\t  }, {\n\t    key: \"aroundO\",\n\t    value: function aroundO(cx, cy, matrix) {\n\t      var dx = cx || 0;\n\t      var dy = cy || 0;\n\t      return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy);\n\t    }\n\t  }, {\n\t    key: \"around\",\n\t    value: function around(cx, cy, matrix) {\n\t      return this.clone().aroundO(cx, cy, matrix);\n\t    } // Check if two matrices are equal\n\n\t  }, {\n\t    key: \"equals\",\n\t    value: function equals(other) {\n\t      var comp = new Matrix(other);\n\t      return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);\n\t    } // Convert matrix to string\n\n\t  }, {\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')';\n\t    }\n\t  }, {\n\t    key: \"toArray\",\n\t    value: function toArray() {\n\t      return [this.a, this.b, this.c, this.d, this.e, this.f];\n\t    }\n\t  }, {\n\t    key: \"valueOf\",\n\t    value: function valueOf() {\n\t      return {\n\t        a: this.a,\n\t        b: this.b,\n\t        c: this.c,\n\t        d: this.d,\n\t        e: this.e,\n\t        f: this.f\n\t      };\n\t    }\n\t  }], [{\n\t    key: \"fromArray\",\n\t    value: function fromArray(a) {\n\t      return {\n\t        a: a[0],\n\t        b: a[1],\n\t        c: a[2],\n\t        d: a[3],\n\t        e: a[4],\n\t        f: a[5]\n\t      };\n\t    }\n\t  }, {\n\t    key: \"isMatrixLike\",\n\t    value: function isMatrixLike(o) {\n\t      return o.a != null || o.b != null || o.c != null || o.d != null || o.e != null || o.f != null;\n\t    }\n\t  }, {\n\t    key: \"formatTransforms\",\n\t    value: function formatTransforms(o) {\n\t      // Get all of the parameters required to form the matrix\n\t      var flipBoth = o.flip === 'both' || o.flip === true;\n\t      var flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;\n\t      var flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;\n\t      var skewX = o.skew && o.skew.length ? o.skew[0] : isFinite(o.skew) ? o.skew : isFinite(o.skewX) ? o.skewX : 0;\n\t      var skewY = o.skew && o.skew.length ? o.skew[1] : isFinite(o.skew) ? o.skew : isFinite(o.skewY) ? o.skewY : 0;\n\t      var scaleX = o.scale && o.scale.length ? o.scale[0] * flipX : isFinite(o.scale) ? o.scale * flipX : isFinite(o.scaleX) ? o.scaleX * flipX : flipX;\n\t      var scaleY = o.scale && o.scale.length ? o.scale[1] * flipY : isFinite(o.scale) ? o.scale * flipY : isFinite(o.scaleY) ? o.scaleY * flipY : flipY;\n\t      var shear = o.shear || 0;\n\t      var theta = o.rotate || o.theta || 0;\n\t      var origin = new Point(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);\n\t      var ox = origin.x;\n\t      var oy = origin.y;\n\t      var position = new Point(o.position || o.px || o.positionX, o.py || o.positionY);\n\t      var px = position.x;\n\t      var py = position.y;\n\t      var translate = new Point(o.translate || o.tx || o.translateX, o.ty || o.translateY);\n\t      var tx = translate.x;\n\t      var ty = translate.y;\n\t      var relative = new Point(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);\n\t      var rx = relative.x;\n\t      var ry = relative.y; // Populate all of the values\n\n\t      return {\n\t        scaleX: scaleX,\n\t        scaleY: scaleY,\n\t        skewX: skewX,\n\t        skewY: skewY,\n\t        shear: shear,\n\t        theta: theta,\n\t        rx: rx,\n\t        ry: ry,\n\t        tx: tx,\n\t        ty: ty,\n\t        ox: ox,\n\t        oy: oy,\n\t        px: px,\n\t        py: py\n\t      };\n\t    } // left matrix, right matrix, target matrix which is overwritten\n\n\t  }, {\n\t    key: \"matrixMultiply\",\n\t    value: function matrixMultiply(l, r, o) {\n\t      // Work out the product directly\n\t      var a = l.a * r.a + l.c * r.b;\n\t      var b = l.b * r.a + l.d * r.b;\n\t      var c = l.a * r.c + l.c * r.d;\n\t      var d = l.b * r.c + l.d * r.d;\n\t      var e = l.e + l.a * r.e + l.c * r.f;\n\t      var f = l.f + l.b * r.e + l.d * r.f; // make sure to use local variables because l/r and o could be the same\n\n\t      o.a = a;\n\t      o.b = b;\n\t      o.c = c;\n\t      o.d = d;\n\t      o.e = e;\n\t      o.f = f;\n\t      return o;\n\t    }\n\t  }]);\n\n\t  return Matrix;\n\t}();\n\tfunction ctm() {\n\t  return new Matrix(this.node.getCTM());\n\t}\n\tfunction screenCTM() {\n\t  /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n\t     This is needed because FF does not return the transformation matrix\n\t     for the inner coordinate system when getScreenCTM() is called on nested svgs.\n\t     However all other Browsers do that */\n\t  if (typeof this.isRoot === 'function' && !this.isRoot()) {\n\t    var rect = this.rect(1, 1);\n\t    var m = rect.node.getScreenCTM();\n\t    rect.remove();\n\t    return new Matrix(m);\n\t  }\n\n\t  return new Matrix(this.node.getScreenCTM());\n\t}\n\tregister(Matrix, 'Matrix');\n\n\tfunction parser() {\n\t  // Reuse cached element if possible\n\t  if (!parser.nodes) {\n\t    var svg = makeInstance().size(2, 0);\n\t    svg.node.style.cssText = ['opacity: 0', 'position: absolute', 'left: -100%', 'top: -100%', 'overflow: hidden'].join(';');\n\t    svg.attr('focusable', 'false');\n\t    svg.attr('aria-hidden', 'true');\n\t    var path = svg.path().node;\n\t    parser.nodes = {\n\t      svg: svg,\n\t      path: path\n\t    };\n\t  }\n\n\t  if (!parser.nodes.svg.node.parentNode) {\n\t    var b = globals.document.body || globals.document.documentElement;\n\t    parser.nodes.svg.addTo(b);\n\t  }\n\n\t  return parser.nodes;\n\t}\n\n\tfunction isNulledBox(box) {\n\t  return !box.width && !box.height && !box.x && !box.y;\n\t}\n\n\tfunction domContains(node) {\n\t  return node === globals.document || (globals.document.documentElement.contains || function (node) {\n\t    // This is IE - it does not support contains() for top-level SVGs\n\t    while (node.parentNode) {\n\t      node = node.parentNode;\n\t    }\n\n\t    return node === globals.document;\n\t  }).call(globals.document.documentElement, node);\n\t}\n\n\tvar Box =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function Box() {\n\t    _classCallCheck(this, Box);\n\n\t    this.init.apply(this, arguments);\n\t  }\n\n\t  _createClass(Box, [{\n\t    key: \"init\",\n\t    value: function init(source) {\n\t      var base = [0, 0, 0, 0];\n\t      source = typeof source === 'string' ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : _typeof(source) === 'object' ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;\n\t      this.x = source[0] || 0;\n\t      this.y = source[1] || 0;\n\t      this.width = this.w = source[2] || 0;\n\t      this.height = this.h = source[3] || 0; // Add more bounding box properties\n\n\t      this.x2 = this.x + this.w;\n\t      this.y2 = this.y + this.h;\n\t      this.cx = this.x + this.w / 2;\n\t      this.cy = this.y + this.h / 2;\n\t      return this;\n\t    } // Merge rect box with another, return a new instance\n\n\t  }, {\n\t    key: \"merge\",\n\t    value: function merge(box) {\n\t      var x = Math.min(this.x, box.x);\n\t      var y = Math.min(this.y, box.y);\n\t      var width = Math.max(this.x + this.width, box.x + box.width) - x;\n\t      var height = Math.max(this.y + this.height, box.y + box.height) - y;\n\t      return new Box(x, y, width, height);\n\t    }\n\t  }, {\n\t    key: \"transform\",\n\t    value: function transform(m) {\n\t      if (!(m instanceof Matrix)) {\n\t        m = new Matrix(m);\n\t      }\n\n\t      var xMin = Infinity;\n\t      var xMax = -Infinity;\n\t      var yMin = Infinity;\n\t      var yMax = -Infinity;\n\t      var pts = [new Point(this.x, this.y), new Point(this.x2, this.y), new Point(this.x, this.y2), new Point(this.x2, this.y2)];\n\t      pts.forEach(function (p) {\n\t        p = p.transform(m);\n\t        xMin = Math.min(xMin, p.x);\n\t        xMax = Math.max(xMax, p.x);\n\t        yMin = Math.min(yMin, p.y);\n\t        yMax = Math.max(yMax, p.y);\n\t      });\n\t      return new Box(xMin, yMin, xMax - xMin, yMax - yMin);\n\t    }\n\t  }, {\n\t    key: \"addOffset\",\n\t    value: function addOffset() {\n\t      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n\t      this.x += globals.window.pageXOffset;\n\t      this.y += globals.window.pageYOffset;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;\n\t    }\n\t  }, {\n\t    key: \"toArray\",\n\t    value: function toArray() {\n\t      return [this.x, this.y, this.width, this.height];\n\t    }\n\t  }, {\n\t    key: \"isNulled\",\n\t    value: function isNulled() {\n\t      return isNulledBox(this);\n\t    }\n\t  }]);\n\n\t  return Box;\n\t}();\n\n\tfunction getBox(cb, retry) {\n\t  var box;\n\n\t  try {\n\t    box = cb(this.node);\n\n\t    if (isNulledBox(box) && !domContains(this.node)) {\n\t      throw new Error('Element not in the dom');\n\t    }\n\t  } catch (e) {\n\t    box = retry(this);\n\t  }\n\n\t  return box;\n\t}\n\n\tfunction bbox() {\n\t  return new Box(getBox.call(this, function (node) {\n\t    return node.getBBox();\n\t  }, function (el) {\n\t    try {\n\t      var clone = el.clone().addTo(parser().svg).show();\n\t      var box = clone.node.getBBox();\n\t      clone.remove();\n\t      return box;\n\t    } catch (e) {\n\t      throw new Error('Getting bbox of element \"' + el.node.nodeName + '\" is not possible. ' + e.toString());\n\t    }\n\t  }));\n\t}\n\tfunction rbox(el) {\n\t  var box = new Box(getBox.call(this, function (node) {\n\t    return node.getBoundingClientRect();\n\t  }, function (el) {\n\t    throw new Error('Getting rbox of element \"' + el.node.nodeName + '\" is not possible');\n\t  }));\n\t  if (el) return box.transform(el.screenCTM().inverse());\n\t  return box.addOffset();\n\t}\n\tregisterMethods({\n\t  viewbox: {\n\t    viewbox: function viewbox(x, y, width, height) {\n\t      // act as getter\n\t      if (x == null) return new Box(this.attr('viewBox')); // act as setter\n\n\t      return this.attr('viewBox', new Box(x, y, width, height));\n\t    },\n\t    zoom: function zoom(level, point) {\n\t      var width = this.node.clientWidth;\n\t      var height = this.node.clientHeight;\n\t      var v = this.viewbox(); // Firefox does not support clientHeight and returns 0\n\t      // https://bugzilla.mozilla.org/show_bug.cgi?id=874811\n\n\t      if (!width && !height) {\n\t        var style = window.getComputedStyle(this.node);\n\t        width = parseFloat(style.getPropertyValue('width'));\n\t        height = parseFloat(style.getPropertyValue('height'));\n\t      }\n\n\t      var zoomX = width / v.width;\n\t      var zoomY = height / v.height;\n\t      var zoom = Math.min(zoomX, zoomY);\n\n\t      if (level == null) {\n\t        return zoom;\n\t      }\n\n\t      var zoomAmount = zoom / level;\n\t      if (zoomAmount === Infinity) zoomAmount = Number.MIN_VALUE;\n\t      point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);\n\t      var box = new Box(v).transform(new Matrix({\n\t        scale: zoomAmount,\n\t        origin: point\n\t      }));\n\t      return this.viewbox(box);\n\t    }\n\t  }\n\t});\n\tregister(Box, 'Box');\n\n\t/* eslint no-new-func: \"off\" */\n\tvar subClassArray = function () {\n\t  try {\n\t    // try es6 subclassing\n\t    return Function('name', 'baseClass', '_constructor', ['baseClass = baseClass || Array', 'return {', '  [name]: class extends baseClass {', '    constructor (...args) {', '      super(...args)', '      _constructor && _constructor.apply(this, args)', '    }', '  }', '}[name]'].join('\\n'));\n\t  } catch (e) {\n\t    // Use es5 approach\n\t    return function (name) {\n\t      var baseClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Array;\n\n\t      var _constructor = arguments.length > 2 ? arguments[2] : undefined;\n\n\t      var Arr = function Arr() {\n\t        baseClass.apply(this, arguments);\n\t        _constructor && _constructor.apply(this, arguments);\n\t      };\n\n\t      Arr.prototype = Object.create(baseClass.prototype);\n\t      Arr.prototype.constructor = Arr;\n\n\t      Arr.prototype.map = function (fn) {\n\t        var arr = new Arr();\n\t        arr.push.apply(arr, Array.prototype.map.call(this, fn));\n\t        return arr;\n\t      };\n\n\t      return Arr;\n\t    };\n\t  }\n\t}();\n\n\tvar List = subClassArray('List', Array, function () {\n\t  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t  // This catches the case, that native map tries to create an array with new Array(1)\n\t  if (typeof arr === 'number') return this;\n\t  this.length = 0;\n\t  this.push.apply(this, _toConsumableArray(arr));\n\t});\n\textend(List, {\n\t  each: function each(fnOrMethodName) {\n\t    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\n\t    if (typeof fnOrMethodName === 'function') {\n\t      return this.map(function (el) {\n\t        return fnOrMethodName.call(el, el);\n\t      });\n\t    } else {\n\t      return this.map(function (el) {\n\t        return el[fnOrMethodName].apply(el, args);\n\t      });\n\t    }\n\t  },\n\t  toArray: function toArray() {\n\t    return Array.prototype.concat.apply([], this);\n\t  }\n\t});\n\tvar reserved = ['toArray', 'constructor', 'each'];\n\n\tList.extend = function (methods) {\n\t  methods = methods.reduce(function (obj, name) {\n\t    // Don't overwrite own methods\n\t    if (reserved.includes(name)) return obj; // Don't add private methods\n\n\t    if (name[0] === '_') return obj; // Relay every call to each()\n\n\t    obj[name] = function () {\n\t      for (var _len2 = arguments.length, attrs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t        attrs[_key2] = arguments[_key2];\n\t      }\n\n\t      return this.each.apply(this, [name].concat(attrs));\n\t    };\n\n\t    return obj;\n\t  }, {});\n\t  extend(List, methods);\n\t};\n\n\tfunction baseFind(query, parent) {\n\t  return new List(map((parent || globals.document).querySelectorAll(query), function (node) {\n\t    return adopt(node);\n\t  }));\n\t} // Scoped find method\n\n\tfunction find(query) {\n\t  return baseFind(query, this.node);\n\t}\n\tfunction findOne(query) {\n\t  return adopt(this.node.querySelector(query));\n\t}\n\n\tvar EventTarget =\n\t/*#__PURE__*/\n\tfunction (_Base) {\n\t  _inherits(EventTarget, _Base);\n\n\t  function EventTarget() {\n\t    var _this;\n\n\t    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t        _ref$events = _ref.events,\n\t        events = _ref$events === void 0 ? {} : _ref$events;\n\n\t    _classCallCheck(this, EventTarget);\n\n\t    _this = _possibleConstructorReturn(this, _getPrototypeOf(EventTarget).call(this));\n\t    _this.events = events;\n\t    return _this;\n\t  }\n\n\t  _createClass(EventTarget, [{\n\t    key: \"addEventListener\",\n\t    value: function addEventListener() {}\n\t  }, {\n\t    key: \"dispatch\",\n\t    value: function dispatch$1(event, data) {\n\t      return dispatch(this, event, data);\n\t    }\n\t  }, {\n\t    key: \"dispatchEvent\",\n\t    value: function dispatchEvent(event) {\n\t      var bag = this.getEventHolder().events;\n\t      if (!bag) return true;\n\t      var events = bag[event.type];\n\n\t      for (var i in events) {\n\t        for (var j in events[i]) {\n\t          events[i][j](event);\n\t        }\n\t      }\n\n\t      return !event.defaultPrevented;\n\t    } // Fire given event\n\n\t  }, {\n\t    key: \"fire\",\n\t    value: function fire(event, data) {\n\t      this.dispatch(event, data);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"getEventHolder\",\n\t    value: function getEventHolder() {\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"getEventTarget\",\n\t    value: function getEventTarget() {\n\t      return this;\n\t    } // Unbind event from listener\n\n\t  }, {\n\t    key: \"off\",\n\t    value: function off$1(event, listener) {\n\t      off(this, event, listener);\n\n\t      return this;\n\t    } // Bind given event to listener\n\n\t  }, {\n\t    key: \"on\",\n\t    value: function on$1(event, listener, binding, options) {\n\t      on(this, event, listener, binding, options);\n\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"removeEventListener\",\n\t    value: function removeEventListener() {}\n\t  }]);\n\n\t  return EventTarget;\n\t}(Base);\n\tregister(EventTarget, 'EventTarget');\n\n\tfunction noop() {} // Default animation values\n\n\tvar timeline = {\n\t  duration: 400,\n\t  ease: '>',\n\t  delay: 0\n\t}; // Default attribute values\n\n\tvar attrs = {\n\t  // fill and stroke\n\t  'fill-opacity': 1,\n\t  'stroke-opacity': 1,\n\t  'stroke-width': 0,\n\t  'stroke-linejoin': 'miter',\n\t  'stroke-linecap': 'butt',\n\t  fill: '#000000',\n\t  stroke: '#000000',\n\t  opacity: 1,\n\t  // position\n\t  x: 0,\n\t  y: 0,\n\t  cx: 0,\n\t  cy: 0,\n\t  // size\n\t  width: 0,\n\t  height: 0,\n\t  // radius\n\t  r: 0,\n\t  rx: 0,\n\t  ry: 0,\n\t  // gradient\n\t  offset: 0,\n\t  'stop-opacity': 1,\n\t  'stop-color': '#000000',\n\t  // text\n\t  'text-anchor': 'start'\n\t};\n\n\tvar defaults = ({\n\t\t__proto__: null,\n\t\tnoop: noop,\n\t\ttimeline: timeline,\n\t\tattrs: attrs\n\t});\n\n\tvar SVGArray = subClassArray('SVGArray', Array, function (arr) {\n\t  this.init(arr);\n\t});\n\textend(SVGArray, {\n\t  init: function init(arr) {\n\t    // This catches the case, that native map tries to create an array with new Array(1)\n\t    if (typeof arr === 'number') return this;\n\t    this.length = 0;\n\t    this.push.apply(this, _toConsumableArray(this.parse(arr)));\n\t    return this;\n\t  },\n\t  toArray: function toArray() {\n\t    return Array.prototype.concat.apply([], this);\n\t  },\n\t  toString: function toString() {\n\t    return this.join(' ');\n\t  },\n\t  // Flattens the array if needed\n\t  valueOf: function valueOf() {\n\t    var ret = [];\n\t    ret.push.apply(ret, _toConsumableArray(this));\n\t    return ret;\n\t  },\n\t  // Parse whitespace separated string\n\t  parse: function parse() {\n\t    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t    // If already is an array, no need to parse it\n\t    if (array instanceof Array) return array;\n\t    return array.trim().split(delimiter).map(parseFloat);\n\t  },\n\t  clone: function clone() {\n\t    return new this.constructor(this);\n\t  },\n\t  toSet: function toSet() {\n\t    return new Set(this);\n\t  }\n\t});\n\n\tvar SVGNumber =\n\t/*#__PURE__*/\n\tfunction () {\n\t  // Initialize\n\t  function SVGNumber() {\n\t    _classCallCheck(this, SVGNumber);\n\n\t    this.init.apply(this, arguments);\n\t  }\n\n\t  _createClass(SVGNumber, [{\n\t    key: \"init\",\n\t    value: function init(value, unit) {\n\t      unit = Array.isArray(value) ? value[1] : unit;\n\t      value = Array.isArray(value) ? value[0] : value; // initialize defaults\n\n\t      this.value = 0;\n\t      this.unit = unit || ''; // parse value\n\n\t      if (typeof value === 'number') {\n\t        // ensure a valid numeric value\n\t        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;\n\t      } else if (typeof value === 'string') {\n\t        unit = value.match(numberAndUnit);\n\n\t        if (unit) {\n\t          // make value numeric\n\t          this.value = parseFloat(unit[1]); // normalize\n\n\t          if (unit[5] === '%') {\n\t            this.value /= 100;\n\t          } else if (unit[5] === 's') {\n\t            this.value *= 1000;\n\t          } // store unit\n\n\n\t          this.unit = unit[5];\n\t        }\n\t      } else {\n\t        if (value instanceof SVGNumber) {\n\t          this.value = value.valueOf();\n\t          this.unit = value.unit;\n\t        }\n\t      }\n\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      return (this.unit === '%' ? ~~(this.value * 1e8) / 1e6 : this.unit === 's' ? this.value / 1e3 : this.value) + this.unit;\n\t    }\n\t  }, {\n\t    key: \"toJSON\",\n\t    value: function toJSON() {\n\t      return this.toString();\n\t    }\n\t  }, {\n\t    key: \"toArray\",\n\t    value: function toArray() {\n\t      return [this.value, this.unit];\n\t    }\n\t  }, {\n\t    key: \"valueOf\",\n\t    value: function valueOf() {\n\t      return this.value;\n\t    } // Add number\n\n\t  }, {\n\t    key: \"plus\",\n\t    value: function plus(number) {\n\t      number = new SVGNumber(number);\n\t      return new SVGNumber(this + number, this.unit || number.unit);\n\t    } // Subtract number\n\n\t  }, {\n\t    key: \"minus\",\n\t    value: function minus(number) {\n\t      number = new SVGNumber(number);\n\t      return new SVGNumber(this - number, this.unit || number.unit);\n\t    } // Multiply number\n\n\t  }, {\n\t    key: \"times\",\n\t    value: function times(number) {\n\t      number = new SVGNumber(number);\n\t      return new SVGNumber(this * number, this.unit || number.unit);\n\t    } // Divide number\n\n\t  }, {\n\t    key: \"divide\",\n\t    value: function divide(number) {\n\t      number = new SVGNumber(number);\n\t      return new SVGNumber(this / number, this.unit || number.unit);\n\t    }\n\t  }, {\n\t    key: \"convert\",\n\t    value: function convert(unit) {\n\t      return new SVGNumber(this.value, unit);\n\t    }\n\t  }]);\n\n\t  return SVGNumber;\n\t}();\n\n\tvar hooks = [];\n\tfunction registerAttrHook(fn) {\n\t  hooks.push(fn);\n\t} // Set svg element attribute\n\n\tfunction attr(attr, val, ns) {\n\t  var _this = this;\n\n\t  // act as full getter\n\t  if (attr == null) {\n\t    // get an object of attributes\n\t    attr = {};\n\t    val = this.node.attributes;\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\n\t    try {\n\t      for (var _iterator = val[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t        var node = _step.value;\n\t        attr[node.nodeName] = isNumber.test(node.nodeValue) ? parseFloat(node.nodeValue) : node.nodeValue;\n\t      }\n\t    } catch (err) {\n\t      _didIteratorError = true;\n\t      _iteratorError = err;\n\t    } finally {\n\t      try {\n\t        if (!_iteratorNormalCompletion && _iterator.return != null) {\n\t          _iterator.return();\n\t        }\n\t      } finally {\n\t        if (_didIteratorError) {\n\t          throw _iteratorError;\n\t        }\n\t      }\n\t    }\n\n\t    return attr;\n\t  } else if (attr instanceof Array) {\n\t    // loop through array and get all values\n\t    return attr.reduce(function (last, curr) {\n\t      last[curr] = _this.attr(curr);\n\t      return last;\n\t    }, {});\n\t  } else if (_typeof(attr) === 'object' && attr.constructor === Object) {\n\t    // apply every attribute individually if an object is passed\n\t    for (val in attr) {\n\t      this.attr(val, attr[val]);\n\t    }\n\t  } else if (val === null) {\n\t    // remove value\n\t    this.node.removeAttribute(attr);\n\t  } else if (val == null) {\n\t    // act as a getter if the first and only argument is not an object\n\t    val = this.node.getAttribute(attr);\n\t    return val == null ? attrs[attr] : isNumber.test(val) ? parseFloat(val) : val;\n\t  } else {\n\t    // Loop through hooks and execute them to convert value\n\t    val = hooks.reduce(function (_val, hook) {\n\t      return hook(attr, _val, _this);\n\t    }, val); // ensure correct numeric values (also accepts NaN and Infinity)\n\n\t    if (typeof val === 'number') {\n\t      val = new SVGNumber(val);\n\t    } else if (Color.isColor(val)) {\n\t      // ensure full hex color\n\t      val = new Color(val);\n\t    } else if (val.constructor === Array) {\n\t      // Check for plain arrays and parse array values\n\t      val = new SVGArray(val);\n\t    } // if the passed attribute is leading...\n\n\n\t    if (attr === 'leading') {\n\t      // ... call the leading method instead\n\t      if (this.leading) {\n\t        this.leading(val);\n\t      }\n\t    } else {\n\t      // set given attribute on node\n\t      typeof ns === 'string' ? this.node.setAttributeNS(ns, attr, val.toString()) : this.node.setAttribute(attr, val.toString());\n\t    } // rebuild if required\n\n\n\t    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {\n\t      this.rebuild();\n\t    }\n\t  }\n\n\t  return this;\n\t}\n\n\tvar Dom =\n\t/*#__PURE__*/\n\tfunction (_EventTarget) {\n\t  _inherits(Dom, _EventTarget);\n\n\t  function Dom(node, attrs) {\n\t    var _this2;\n\n\t    _classCallCheck(this, Dom);\n\n\t    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Dom).call(this, node));\n\t    _this2.node = node;\n\t    _this2.type = node.nodeName;\n\n\t    if (attrs && node !== attrs) {\n\t      _this2.attr(attrs);\n\t    }\n\n\t    return _this2;\n\t  } // Add given element at a position\n\n\n\t  _createClass(Dom, [{\n\t    key: \"add\",\n\t    value: function add(element, i) {\n\t      element = makeInstance(element);\n\n\t      if (i == null) {\n\t        this.node.appendChild(element.node);\n\t      } else if (element.node !== this.node.childNodes[i]) {\n\t        this.node.insertBefore(element.node, this.node.childNodes[i]);\n\t      }\n\n\t      return this;\n\t    } // Add element to given container and return self\n\n\t  }, {\n\t    key: \"addTo\",\n\t    value: function addTo(parent) {\n\t      return makeInstance(parent).put(this);\n\t    } // Returns all child elements\n\n\t  }, {\n\t    key: \"children\",\n\t    value: function children() {\n\t      return new List(map(this.node.children, function (node) {\n\t        return adopt(node);\n\t      }));\n\t    } // Remove all elements in this container\n\n\t  }, {\n\t    key: \"clear\",\n\t    value: function clear() {\n\t      // remove children\n\t      while (this.node.hasChildNodes()) {\n\t        this.node.removeChild(this.node.lastChild);\n\t      }\n\n\t      return this;\n\t    } // Clone element\n\n\t  }, {\n\t    key: \"clone\",\n\t    value: function clone() {\n\t      // write dom data to the dom so the clone can pickup the data\n\t      this.writeDataToDom(); // clone element and assign new id\n\n\t      return assignNewId(this.node.cloneNode(true));\n\t    } // Iterates over all children and invokes a given block\n\n\t  }, {\n\t    key: \"each\",\n\t    value: function each(block, deep) {\n\t      var children = this.children();\n\t      var i, il;\n\n\t      for (i = 0, il = children.length; i < il; i++) {\n\t        block.apply(children[i], [i, children]);\n\n\t        if (deep) {\n\t          children[i].each(block, deep);\n\t        }\n\t      }\n\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"element\",\n\t    value: function element(nodeName) {\n\t      return this.put(new Dom(create(nodeName)));\n\t    } // Get first child\n\n\t  }, {\n\t    key: \"first\",\n\t    value: function first() {\n\t      return adopt(this.node.firstChild);\n\t    } // Get a element at the given index\n\n\t  }, {\n\t    key: \"get\",\n\t    value: function get(i) {\n\t      return adopt(this.node.childNodes[i]);\n\t    }\n\t  }, {\n\t    key: \"getEventHolder\",\n\t    value: function getEventHolder() {\n\t      return this.node;\n\t    }\n\t  }, {\n\t    key: \"getEventTarget\",\n\t    value: function getEventTarget() {\n\t      return this.node;\n\t    } // Checks if the given element is a child\n\n\t  }, {\n\t    key: \"has\",\n\t    value: function has(element) {\n\t      return this.index(element) >= 0;\n\t    } // Get / set id\n\n\t  }, {\n\t    key: \"id\",\n\t    value: function id(_id) {\n\t      // generate new id if no id set\n\t      if (typeof _id === 'undefined' && !this.node.id) {\n\t        this.node.id = eid(this.type);\n\t      } // dont't set directly width this.node.id to make `null` work correctly\n\n\n\t      return this.attr('id', _id);\n\t    } // Gets index of given element\n\n\t  }, {\n\t    key: \"index\",\n\t    value: function index(element) {\n\t      return [].slice.call(this.node.childNodes).indexOf(element.node);\n\t    } // Get the last child\n\n\t  }, {\n\t    key: \"last\",\n\t    value: function last() {\n\t      return adopt(this.node.lastChild);\n\t    } // matches the element vs a css selector\n\n\t  }, {\n\t    key: \"matches\",\n\t    value: function matches(selector) {\n\t      var el = this.node;\n\t      return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\n\t    } // Returns the parent element instance\n\n\t  }, {\n\t    key: \"parent\",\n\t    value: function parent(type) {\n\t      var parent = this; // check for parent\n\n\t      if (!parent.node.parentNode) return null; // get parent element\n\n\t      parent = adopt(parent.node.parentNode);\n\t      if (!type) return parent; // loop trough ancestors if type is given\n\n\t      while (parent) {\n\t        if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;\n\t        if (!parent.node.parentNode || parent.node.parentNode.nodeName === '#document' || parent.node.parentNode.nodeName === '#document-fragment') return null; // #759, #720\n\n\t        parent = adopt(parent.node.parentNode);\n\t      }\n\t    } // Basically does the same as `add()` but returns the added element instead\n\n\t  }, {\n\t    key: \"put\",\n\t    value: function put(element, i) {\n\t      this.add(element, i);\n\t      return element;\n\t    } // Add element to given container and return container\n\n\t  }, {\n\t    key: \"putIn\",\n\t    value: function putIn(parent) {\n\t      return makeInstance(parent).add(this);\n\t    } // Remove element\n\n\t  }, {\n\t    key: \"remove\",\n\t    value: function remove() {\n\t      if (this.parent()) {\n\t        this.parent().removeElement(this);\n\t      }\n\n\t      return this;\n\t    } // Remove a given child\n\n\t  }, {\n\t    key: \"removeElement\",\n\t    value: function removeElement(element) {\n\t      this.node.removeChild(element.node);\n\t      return this;\n\t    } // Replace this with element\n\n\t  }, {\n\t    key: \"replace\",\n\t    value: function replace(element) {\n\t      element = makeInstance(element);\n\t      this.node.parentNode.replaceChild(element.node, this.node);\n\t      return element;\n\t    }\n\t  }, {\n\t    key: \"round\",\n\t    value: function round() {\n\t      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n\t      var map = arguments.length > 1 ? arguments[1] : undefined;\n\t      var factor = Math.pow(10, precision);\n\t      var attrs = this.attr(); // If we have no map, build one from attrs\n\n\t      if (!map) {\n\t        map = Object.keys(attrs);\n\t      } // Holds rounded attributes\n\n\n\t      var newAttrs = {};\n\t      map.forEach(function (key) {\n\t        newAttrs[key] = Math.round(attrs[key] * factor) / factor;\n\t      });\n\t      this.attr(newAttrs);\n\t      return this;\n\t    } // Return id on string conversion\n\n\t  }, {\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      return this.id();\n\t    } // Import raw svg\n\n\t  }, {\n\t    key: \"svg\",\n\t    value: function svg(svgOrFn, outerHTML) {\n\t      var well, len, fragment;\n\n\t      if (svgOrFn === false) {\n\t        outerHTML = false;\n\t        svgOrFn = null;\n\t      } // act as getter if no svg string is given\n\n\n\t      if (svgOrFn == null || typeof svgOrFn === 'function') {\n\t        // The default for exports is, that the outerNode is included\n\t        outerHTML = outerHTML == null ? true : outerHTML; // write svgjs data to the dom\n\n\t        this.writeDataToDom();\n\t        var current = this; // An export modifier was passed\n\n\t        if (svgOrFn != null) {\n\t          current = adopt(current.node.cloneNode(true)); // If the user wants outerHTML we need to process this node, too\n\n\t          if (outerHTML) {\n\t            var result = svgOrFn(current);\n\t            current = result || current; // The user does not want this node? Well, then he gets nothing\n\n\t            if (result === false) return '';\n\t          } // Deep loop through all children and apply modifier\n\n\n\t          current.each(function () {\n\t            var result = svgOrFn(this);\n\n\t            var _this = result || this; // If modifier returns false, discard node\n\n\n\t            if (result === false) {\n\t              this.remove(); // If modifier returns new node, use it\n\t            } else if (result && this !== _this) {\n\t              this.replace(_this);\n\t            }\n\t          }, true);\n\t        } // Return outer or inner content\n\n\n\t        return outerHTML ? current.node.outerHTML : current.node.innerHTML;\n\t      } // Act as setter if we got a string\n\t      // The default for import is, that the current node is not replaced\n\n\n\t      outerHTML = outerHTML == null ? false : outerHTML; // Create temporary holder\n\n\t      well = globals.document.createElementNS(ns, 'svg');\n\t      fragment = globals.document.createDocumentFragment(); // Dump raw svg\n\n\t      well.innerHTML = svgOrFn; // Transplant nodes into the fragment\n\n\t      for (len = well.children.length; len--;) {\n\t        fragment.appendChild(well.firstElementChild);\n\t      }\n\n\t      var parent = this.parent(); // Add the whole fragment at once\n\n\t      return outerHTML ? this.replace(fragment) && parent : this.add(fragment);\n\t    }\n\t  }, {\n\t    key: \"words\",\n\t    value: function words(text) {\n\t      // This is faster than removing all children and adding a new one\n\t      this.node.textContent = text;\n\t      return this;\n\t    } // write svgjs data to the dom\n\n\t  }, {\n\t    key: \"writeDataToDom\",\n\t    value: function writeDataToDom() {\n\t      // dump variables recursively\n\t      this.each(function () {\n\t        this.writeDataToDom();\n\t      });\n\t      return this;\n\t    }\n\t  }]);\n\n\t  return Dom;\n\t}(EventTarget);\n\textend(Dom, {\n\t  attr: attr,\n\t  find: find,\n\t  findOne: findOne\n\t});\n\tregister(Dom, 'Dom');\n\n\tvar Element =\n\t/*#__PURE__*/\n\tfunction (_Dom) {\n\t  _inherits(Element, _Dom);\n\n\t  function Element(node, attrs) {\n\t    var _this;\n\n\t    _classCallCheck(this, Element);\n\n\t    _this = _possibleConstructorReturn(this, _getPrototypeOf(Element).call(this, node, attrs)); // initialize data object\n\n\t    _this.dom = {}; // create circular reference\n\n\t    _this.node.instance = _assertThisInitialized(_this);\n\n\t    if (node.hasAttribute('svgjs:data')) {\n\t      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\n\t      _this.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});\n\t    }\n\n\t    return _this;\n\t  } // Move element by its center\n\n\n\t  _createClass(Element, [{\n\t    key: \"center\",\n\t    value: function center(x, y) {\n\t      return this.cx(x).cy(y);\n\t    } // Move by center over x-axis\n\n\t  }, {\n\t    key: \"cx\",\n\t    value: function cx(x) {\n\t      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);\n\t    } // Move by center over y-axis\n\n\t  }, {\n\t    key: \"cy\",\n\t    value: function cy(y) {\n\t      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);\n\t    } // Get defs\n\n\t  }, {\n\t    key: \"defs\",\n\t    value: function defs() {\n\t      return this.root().defs();\n\t    } // Relative move over x and y axes\n\n\t  }, {\n\t    key: \"dmove\",\n\t    value: function dmove(x, y) {\n\t      return this.dx(x).dy(y);\n\t    } // Relative move over x axis\n\n\t  }, {\n\t    key: \"dx\",\n\t    value: function dx() {\n\t      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t      return this.x(new SVGNumber(x).plus(this.x()));\n\t    } // Relative move over y axis\n\n\t  }, {\n\t    key: \"dy\",\n\t    value: function dy() {\n\t      var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t      return this.y(new SVGNumber(y).plus(this.y()));\n\t    } // Get parent document\n\n\t  }, {\n\t    key: \"root\",\n\t    value: function root$1() {\n\t      var p = this.parent(getClass(root));\n\t      return p && p.root();\n\t    }\n\t  }, {\n\t    key: \"getEventHolder\",\n\t    value: function getEventHolder() {\n\t      return this;\n\t    } // Set height of element\n\n\t  }, {\n\t    key: \"height\",\n\t    value: function height(_height) {\n\t      return this.attr('height', _height);\n\t    } // Checks whether the given point inside the bounding box of the element\n\n\t  }, {\n\t    key: \"inside\",\n\t    value: function inside(x, y) {\n\t      var box = this.bbox();\n\t      return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;\n\t    } // Move element to given x and y values\n\n\t  }, {\n\t    key: \"move\",\n\t    value: function move(x, y) {\n\t      return this.x(x).y(y);\n\t    } // return array of all ancestors of given type up to the root svg\n\n\t  }, {\n\t    key: \"parents\",\n\t    value: function parents() {\n\t      var until = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : globals.document;\n\t      until = makeInstance(until);\n\t      var parents = new List();\n\t      var parent = this;\n\n\t      while ((parent = parent.parent()) && parent.node !== until.node && parent.node !== globals.document) {\n\t        parents.push(parent);\n\t      }\n\n\t      return parents;\n\t    } // Get referenced element form attribute value\n\n\t  }, {\n\t    key: \"reference\",\n\t    value: function reference$1(attr) {\n\t      attr = this.attr(attr);\n\t      if (!attr) return null;\n\t      var m = attr.match(reference);\n\t      return m ? makeInstance(m[1]) : null;\n\t    } // set given data to the elements data property\n\n\t  }, {\n\t    key: \"setData\",\n\t    value: function setData(o) {\n\t      this.dom = o;\n\t      return this;\n\t    } // Set element size to given width and height\n\n\t  }, {\n\t    key: \"size\",\n\t    value: function size(width, height) {\n\t      var p = proportionalSize(this, width, height);\n\t      return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height));\n\t    } // Set width of element\n\n\t  }, {\n\t    key: \"width\",\n\t    value: function width(_width) {\n\t      return this.attr('width', _width);\n\t    } // write svgjs data to the dom\n\n\t  }, {\n\t    key: \"writeDataToDom\",\n\t    value: function writeDataToDom() {\n\t      // remove previously set data\n\t      this.node.removeAttribute('svgjs:data');\n\n\t      if (Object.keys(this.dom).length) {\n\t        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)); // see #428\n\t      }\n\n\t      return _get(_getPrototypeOf(Element.prototype), \"writeDataToDom\", this).call(this);\n\t    } // Move over x-axis\n\n\t  }, {\n\t    key: \"x\",\n\t    value: function x(_x) {\n\t      return this.attr('x', _x);\n\t    } // Move over y-axis\n\n\t  }, {\n\t    key: \"y\",\n\t    value: function y(_y) {\n\t      return this.attr('y', _y);\n\t    }\n\t  }]);\n\n\t  return Element;\n\t}(Dom);\n\textend(Element, {\n\t  bbox: bbox,\n\t  rbox: rbox,\n\t  point: point,\n\t  ctm: ctm,\n\t  screenCTM: screenCTM\n\t});\n\tregister(Element, 'Element');\n\n\tvar sugar = {\n\t  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],\n\t  fill: ['color', 'opacity', 'rule'],\n\t  prefix: function prefix(t, a) {\n\t    return a === 'color' ? t : t + '-' + a;\n\t  }\n\t} // Add sugar for fill and stroke\n\t;\n\t['fill', 'stroke'].forEach(function (m) {\n\t  var extension = {};\n\t  var i;\n\n\t  extension[m] = function (o) {\n\t    if (typeof o === 'undefined') {\n\t      return this.attr(m);\n\t    }\n\n\t    if (typeof o === 'string' || o instanceof Color || Color.isRgb(o) || o instanceof Element) {\n\t      this.attr(m, o);\n\t    } else {\n\t      // set all attributes from sugar.fill and sugar.stroke list\n\t      for (i = sugar[m].length - 1; i >= 0; i--) {\n\t        if (o[sugar[m][i]] != null) {\n\t          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);\n\t        }\n\t      }\n\t    }\n\n\t    return this;\n\t  };\n\n\t  registerMethods(['Element', 'Runner'], extension);\n\t});\n\tregisterMethods(['Element', 'Runner'], {\n\t  // Let the user set the matrix directly\n\t  matrix: function matrix(mat, b, c, d, e, f) {\n\t    // Act as a getter\n\t    if (mat == null) {\n\t      return new Matrix(this);\n\t    } // Act as a setter, the user can pass a matrix or a set of numbers\n\n\n\t    return this.attr('transform', new Matrix(mat, b, c, d, e, f));\n\t  },\n\t  // Map rotation to transform\n\t  rotate: function rotate(angle, cx, cy) {\n\t    return this.transform({\n\t      rotate: angle,\n\t      ox: cx,\n\t      oy: cy\n\t    }, true);\n\t  },\n\t  // Map skew to transform\n\t  skew: function skew(x, y, cx, cy) {\n\t    return arguments.length === 1 || arguments.length === 3 ? this.transform({\n\t      skew: x,\n\t      ox: y,\n\t      oy: cx\n\t    }, true) : this.transform({\n\t      skew: [x, y],\n\t      ox: cx,\n\t      oy: cy\n\t    }, true);\n\t  },\n\t  shear: function shear(lam, cx, cy) {\n\t    return this.transform({\n\t      shear: lam,\n\t      ox: cx,\n\t      oy: cy\n\t    }, true);\n\t  },\n\t  // Map scale to transform\n\t  scale: function scale(x, y, cx, cy) {\n\t    return arguments.length === 1 || arguments.length === 3 ? this.transform({\n\t      scale: x,\n\t      ox: y,\n\t      oy: cx\n\t    }, true) : this.transform({\n\t      scale: [x, y],\n\t      ox: cx,\n\t      oy: cy\n\t    }, true);\n\t  },\n\t  // Map translate to transform\n\t  translate: function translate(x, y) {\n\t    return this.transform({\n\t      translate: [x, y]\n\t    }, true);\n\t  },\n\t  // Map relative translations to transform\n\t  relative: function relative(x, y) {\n\t    return this.transform({\n\t      relative: [x, y]\n\t    }, true);\n\t  },\n\t  // Map flip to transform\n\t  flip: function flip(direction, around) {\n\t    var directionString = typeof direction === 'string' ? direction : isFinite(direction) ? 'both' : 'both';\n\t    var origin = direction === 'both' && isFinite(around) ? [around, around] : direction === 'x' ? [around, 0] : direction === 'y' ? [0, around] : isFinite(direction) ? [direction, direction] : [0, 0];\n\t    return this.transform({\n\t      flip: directionString,\n\t      origin: origin\n\t    }, true);\n\t  },\n\t  // Opacity\n\t  opacity: function opacity(value) {\n\t    return this.attr('opacity', value);\n\t  }\n\t});\n\tregisterMethods('radius', {\n\t  // Add x and y radius\n\t  radius: function radius(x, y) {\n\t    var type = (this._element || this).type;\n\t    return type === 'radialGradient' || type === 'radialGradient' ? this.attr('r', new SVGNumber(x)) : this.rx(x).ry(y == null ? x : y);\n\t  }\n\t});\n\tregisterMethods('Path', {\n\t  // Get path length\n\t  length: function length() {\n\t    return this.node.getTotalLength();\n\t  },\n\t  // Get point at length\n\t  pointAt: function pointAt(length) {\n\t    return new Point(this.node.getPointAtLength(length));\n\t  }\n\t});\n\tregisterMethods(['Element', 'Runner'], {\n\t  // Set font\n\t  font: function font(a, v) {\n\t    if (_typeof(a) === 'object') {\n\t      for (v in a) {\n\t        this.font(v, a[v]);\n\t      }\n\n\t      return this;\n\t    }\n\n\t    return a === 'leading' ? this.leading(v) : a === 'anchor' ? this.attr('text-anchor', v) : a === 'size' || a === 'family' || a === 'weight' || a === 'stretch' || a === 'variant' || a === 'style' ? this.attr('font-' + a, v) : this.attr(a, v);\n\t  }\n\t});\n\tregisterMethods('Text', {\n\t  ax: function ax(x) {\n\t    return this.attr('x', x);\n\t  },\n\t  ay: function ay(y) {\n\t    return this.attr('y', y);\n\t  },\n\t  amove: function amove(x, y) {\n\t    return this.ax(x).ay(y);\n\t  }\n\t}); // Add events to elements\n\n\tvar methods$1 = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'mouseenter', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].reduce(function (last, event) {\n\t  // add event to Element\n\t  var fn = function fn(f) {\n\t    if (f === null) {\n\t      off(this, event);\n\t    } else {\n\t      on(this, event, f);\n\t    }\n\n\t    return this;\n\t  };\n\n\t  last[event] = fn;\n\t  return last;\n\t}, {});\n\tregisterMethods('Element', methods$1);\n\n\tvar nativeReverse = [].reverse;\n\tvar test$1 = [1, 2];\n\n\t// `Array.prototype.reverse` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.reverse\n\t// fix for Safari 12.0 bug\n\t// https://bugs.webkit.org/show_bug.cgi?id=188794\n\t_export({ target: 'Array', proto: true, forced: String(test$1) === String(test$1.reverse()) }, {\n\t  reverse: function reverse() {\n\t    // eslint-disable-next-line no-self-assign\n\t    if (isArray(this)) this.length = this.length;\n\t    return nativeReverse.call(this);\n\t  }\n\t});\n\n\t// `Object.defineProperties` method\n\t// https://tc39.github.io/ecma262/#sec-object.defineproperties\n\t_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {\n\t  defineProperties: objectDefineProperties\n\t});\n\n\t// `Object.defineProperty` method\n\t// https://tc39.github.io/ecma262/#sec-object.defineproperty\n\t_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {\n\t  defineProperty: objectDefineProperty.f\n\t});\n\n\tvar nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\n\n\n\tvar FAILS_ON_PRIMITIVES$2 = fails(function () { nativeGetOwnPropertyDescriptor$2(1); });\n\tvar FORCED$3 = !descriptors || FAILS_ON_PRIMITIVES$2;\n\n\t// `Object.getOwnPropertyDescriptor` method\n\t// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\n\t_export({ target: 'Object', stat: true, forced: FORCED$3, sham: !descriptors }, {\n\t  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {\n\t    return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);\n\t  }\n\t});\n\n\t// `Object.getOwnPropertyDescriptors` method\n\t// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors\n\t_export({ target: 'Object', stat: true, sham: !descriptors }, {\n\t  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n\t    var O = toIndexedObject(object);\n\t    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\t    var keys = ownKeys(O);\n\t    var result = {};\n\t    var index = 0;\n\t    var key, descriptor;\n\t    while (keys.length > index) {\n\t      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);\n\t      if (descriptor !== undefined) createProperty(result, key, descriptor);\n\t    }\n\t    return result;\n\t  }\n\t});\n\n\tfunction _defineProperty(obj, key, value) {\n\t  if (key in obj) {\n\t    Object.defineProperty(obj, key, {\n\t      value: value,\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true\n\t    });\n\t  } else {\n\t    obj[key] = value;\n\t  }\n\n\t  return obj;\n\t}\n\n\tfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\n\tfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\tfunction untransform() {\n\t  return this.attr('transform', null);\n\t} // merge the whole transformation chain into one matrix and returns it\n\n\tfunction matrixify() {\n\t  var matrix = (this.attr('transform') || ''). // split transformations\n\t  split(transforms).slice(0, -1).map(function (str) {\n\t    // generate key => value pairs\n\t    var kv = str.trim().split('(');\n\t    return [kv[0], kv[1].split(delimiter).map(function (str) {\n\t      return parseFloat(str);\n\t    })];\n\t  }).reverse() // merge every transformation into one matrix\n\t  .reduce(function (matrix, transform) {\n\t    if (transform[0] === 'matrix') {\n\t      return matrix.lmultiply(Matrix.fromArray(transform[1]));\n\t    }\n\n\t    return matrix[transform[0]].apply(matrix, transform[1]);\n\t  }, new Matrix());\n\t  return matrix;\n\t} // add an element to another parent without changing the visual representation on the screen\n\n\tfunction toParent(parent) {\n\t  if (this === parent) return this;\n\t  var ctm = this.screenCTM();\n\t  var pCtm = parent.screenCTM().inverse();\n\t  this.addTo(parent).untransform().transform(pCtm.multiply(ctm));\n\t  return this;\n\t} // same as above with parent equals root-svg\n\n\tfunction toRoot() {\n\t  return this.toParent(this.root());\n\t} // Add transformations\n\n\tfunction transform(o, relative) {\n\t  // Act as a getter if no object was passed\n\t  if (o == null || typeof o === 'string') {\n\t    var decomposed = new Matrix(this).decompose();\n\t    return o == null ? decomposed : decomposed[o];\n\t  }\n\n\t  if (!Matrix.isMatrixLike(o)) {\n\t    // Set the origin according to the defined transform\n\t    o = _objectSpread({}, o, {\n\t      origin: getOrigin(o, this)\n\t    });\n\t  } // The user can pass a boolean, an Element or an Matrix or nothing\n\n\n\t  var cleanRelative = relative === true ? this : relative || false;\n\t  var result = new Matrix(cleanRelative).transform(o);\n\t  return this.attr('transform', result);\n\t}\n\tregisterMethods('Element', {\n\t  untransform: untransform,\n\t  matrixify: matrixify,\n\t  toParent: toParent,\n\t  toRoot: toRoot,\n\t  transform: transform\n\t});\n\n\tfunction rx(rx) {\n\t  return this.attr('rx', rx);\n\t} // Radius y value\n\n\tfunction ry(ry) {\n\t  return this.attr('ry', ry);\n\t} // Move over x-axis\n\n\tfunction x(x) {\n\t  return x == null ? this.cx() - this.rx() : this.cx(x + this.rx());\n\t} // Move over y-axis\n\n\tfunction y(y) {\n\t  return y == null ? this.cy() - this.ry() : this.cy(y + this.ry());\n\t} // Move by center over x-axis\n\n\tfunction cx(x) {\n\t  return x == null ? this.attr('cx') : this.attr('cx', x);\n\t} // Move by center over y-axis\n\n\tfunction cy(y) {\n\t  return y == null ? this.attr('cy') : this.attr('cy', y);\n\t} // Set width of element\n\n\tfunction width(width) {\n\t  return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2));\n\t} // Set height of element\n\n\tfunction height(height) {\n\t  return height == null ? this.ry() * 2 : this.ry(new SVGNumber(height).divide(2));\n\t}\n\n\tvar circled = ({\n\t\t__proto__: null,\n\t\trx: rx,\n\t\try: ry,\n\t\tx: x,\n\t\ty: y,\n\t\tcx: cx,\n\t\tcy: cy,\n\t\twidth: width,\n\t\theight: height\n\t});\n\n\tvar Shape =\n\t/*#__PURE__*/\n\tfunction (_Element) {\n\t  _inherits(Shape, _Element);\n\n\t  function Shape() {\n\t    _classCallCheck(this, Shape);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Shape).apply(this, arguments));\n\t  }\n\n\t  return Shape;\n\t}(Element);\n\tregister(Shape, 'Shape');\n\n\tvar Circle =\n\t/*#__PURE__*/\n\tfunction (_Shape) {\n\t  _inherits(Circle, _Shape);\n\n\t  function Circle(node) {\n\t    _classCallCheck(this, Circle);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, nodeOrNew('circle', node), node));\n\t  }\n\n\t  _createClass(Circle, [{\n\t    key: \"radius\",\n\t    value: function radius(r) {\n\t      return this.attr('r', r);\n\t    } // Radius x value\n\n\t  }, {\n\t    key: \"rx\",\n\t    value: function rx(_rx) {\n\t      return this.attr('r', _rx);\n\t    } // Alias radius x value\n\n\t  }, {\n\t    key: \"ry\",\n\t    value: function ry(_ry) {\n\t      return this.rx(_ry);\n\t    }\n\t  }, {\n\t    key: \"size\",\n\t    value: function size(_size) {\n\t      return this.radius(new SVGNumber(_size).divide(2));\n\t    }\n\t  }]);\n\n\t  return Circle;\n\t}(Shape);\n\textend(Circle, {\n\t  x: x,\n\t  y: y,\n\t  cx: cx,\n\t  cy: cy,\n\t  width: width,\n\t  height: height\n\t});\n\tregisterMethods({\n\t  Container: {\n\t    // Create circle element\n\t    circle: wrapWithAttrCheck(function (size) {\n\t      return this.put(new Circle()).size(size).move(0, 0);\n\t    })\n\t  }\n\t});\n\tregister(Circle, 'Circle');\n\n\tvar Container =\n\t/*#__PURE__*/\n\tfunction (_Element) {\n\t  _inherits(Container, _Element);\n\n\t  function Container() {\n\t    _classCallCheck(this, Container);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Container).apply(this, arguments));\n\t  }\n\n\t  _createClass(Container, [{\n\t    key: \"flatten\",\n\t    value: function flatten(parent) {\n\t      this.each(function () {\n\t        if (this instanceof Container) return this.flatten(parent).ungroup(parent);\n\t        return this.toParent(parent);\n\t      }); // we need this so that the root does not get removed\n\n\t      this.node.firstElementChild || this.remove();\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"ungroup\",\n\t    value: function ungroup(parent) {\n\t      parent = parent || this.parent();\n\t      this.each(function () {\n\t        return this.toParent(parent);\n\t      });\n\t      this.remove();\n\t      return this;\n\t    }\n\t  }]);\n\n\t  return Container;\n\t}(Element);\n\tregister(Container, 'Container');\n\n\tvar Defs =\n\t/*#__PURE__*/\n\tfunction (_Container) {\n\t  _inherits(Defs, _Container);\n\n\t  function Defs(node) {\n\t    _classCallCheck(this, Defs);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Defs).call(this, nodeOrNew('defs', node), node));\n\t  }\n\n\t  _createClass(Defs, [{\n\t    key: \"flatten\",\n\t    value: function flatten() {\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"ungroup\",\n\t    value: function ungroup() {\n\t      return this;\n\t    }\n\t  }]);\n\n\t  return Defs;\n\t}(Container);\n\tregister(Defs, 'Defs');\n\n\tvar Ellipse =\n\t/*#__PURE__*/\n\tfunction (_Shape) {\n\t  _inherits(Ellipse, _Shape);\n\n\t  function Ellipse(node) {\n\t    _classCallCheck(this, Ellipse);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Ellipse).call(this, nodeOrNew('ellipse', node), node));\n\t  }\n\n\t  _createClass(Ellipse, [{\n\t    key: \"size\",\n\t    value: function size(width, height) {\n\t      var p = proportionalSize(this, width, height);\n\t      return this.rx(new SVGNumber(p.width).divide(2)).ry(new SVGNumber(p.height).divide(2));\n\t    }\n\t  }]);\n\n\t  return Ellipse;\n\t}(Shape);\n\textend(Ellipse, circled);\n\tregisterMethods('Container', {\n\t  // Create an ellipse\n\t  ellipse: wrapWithAttrCheck(function () {\n\t    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n\t    return this.put(new Ellipse()).size(width, height).move(0, 0);\n\t  })\n\t});\n\tregister(Ellipse, 'Ellipse');\n\n\tvar Stop =\n\t/*#__PURE__*/\n\tfunction (_Element) {\n\t  _inherits(Stop, _Element);\n\n\t  function Stop(node) {\n\t    _classCallCheck(this, Stop);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Stop).call(this, nodeOrNew('stop', node), node));\n\t  } // add color stops\n\n\n\t  _createClass(Stop, [{\n\t    key: \"update\",\n\t    value: function update(o) {\n\t      if (typeof o === 'number' || o instanceof SVGNumber) {\n\t        o = {\n\t          offset: arguments[0],\n\t          color: arguments[1],\n\t          opacity: arguments[2]\n\t        };\n\t      } // set attributes\n\n\n\t      if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n\t      if (o.color != null) this.attr('stop-color', o.color);\n\t      if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));\n\t      return this;\n\t    }\n\t  }]);\n\n\t  return Stop;\n\t}(Element);\n\tregister(Stop, 'Stop');\n\n\tfunction from(x, y) {\n\t  return (this._element || this).type === 'radialGradient' ? this.attr({\n\t    fx: new SVGNumber(x),\n\t    fy: new SVGNumber(y)\n\t  }) : this.attr({\n\t    x1: new SVGNumber(x),\n\t    y1: new SVGNumber(y)\n\t  });\n\t}\n\tfunction to(x, y) {\n\t  return (this._element || this).type === 'radialGradient' ? this.attr({\n\t    cx: new SVGNumber(x),\n\t    cy: new SVGNumber(y)\n\t  }) : this.attr({\n\t    x2: new SVGNumber(x),\n\t    y2: new SVGNumber(y)\n\t  });\n\t}\n\n\tvar gradiented = ({\n\t\t__proto__: null,\n\t\tfrom: from,\n\t\tto: to\n\t});\n\n\tvar Gradient =\n\t/*#__PURE__*/\n\tfunction (_Container) {\n\t  _inherits(Gradient, _Container);\n\n\t  function Gradient(type, attrs) {\n\t    _classCallCheck(this, Gradient);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Gradient).call(this, nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type), attrs));\n\t  } // Add a color stop\n\n\n\t  _createClass(Gradient, [{\n\t    key: \"stop\",\n\t    value: function stop(offset, color, opacity) {\n\t      return this.put(new Stop()).update(offset, color, opacity);\n\t    } // Update gradient\n\n\t  }, {\n\t    key: \"update\",\n\t    value: function update(block) {\n\t      // remove all stops\n\t      this.clear(); // invoke passed block\n\n\t      if (typeof block === 'function') {\n\t        block.call(this, this);\n\t      }\n\n\t      return this;\n\t    } // Return the fill id\n\n\t  }, {\n\t    key: \"url\",\n\t    value: function url() {\n\t      return 'url(#' + this.id() + ')';\n\t    } // Alias string convertion to fill\n\n\t  }, {\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      return this.url();\n\t    } // custom attr to handle transform\n\n\t  }, {\n\t    key: \"attr\",\n\t    value: function attr(a, b, c) {\n\t      if (a === 'transform') a = 'gradientTransform';\n\t      return _get(_getPrototypeOf(Gradient.prototype), \"attr\", this).call(this, a, b, c);\n\t    }\n\t  }, {\n\t    key: \"targets\",\n\t    value: function targets() {\n\t      return baseFind('svg [fill*=\"' + this.id() + '\"]');\n\t    }\n\t  }, {\n\t    key: \"bbox\",\n\t    value: function bbox() {\n\t      return new Box();\n\t    }\n\t  }]);\n\n\t  return Gradient;\n\t}(Container);\n\textend(Gradient, gradiented);\n\tregisterMethods({\n\t  Container: {\n\t    // Create gradient element in defs\n\t    gradient: wrapWithAttrCheck(function (type, block) {\n\t      return this.defs().gradient(type, block);\n\t    })\n\t  },\n\t  // define gradient\n\t  Defs: {\n\t    gradient: wrapWithAttrCheck(function (type, block) {\n\t      return this.put(new Gradient(type)).update(block);\n\t    })\n\t  }\n\t});\n\tregister(Gradient, 'Gradient');\n\n\tvar Pattern =\n\t/*#__PURE__*/\n\tfunction (_Container) {\n\t  _inherits(Pattern, _Container);\n\n\t  // Initialize node\n\t  function Pattern(node) {\n\t    _classCallCheck(this, Pattern);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Pattern).call(this, nodeOrNew('pattern', node), node));\n\t  } // Return the fill id\n\n\n\t  _createClass(Pattern, [{\n\t    key: \"url\",\n\t    value: function url() {\n\t      return 'url(#' + this.id() + ')';\n\t    } // Update pattern by rebuilding\n\n\t  }, {\n\t    key: \"update\",\n\t    value: function update(block) {\n\t      // remove content\n\t      this.clear(); // invoke passed block\n\n\t      if (typeof block === 'function') {\n\t        block.call(this, this);\n\t      }\n\n\t      return this;\n\t    } // Alias string convertion to fill\n\n\t  }, {\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      return this.url();\n\t    } // custom attr to handle transform\n\n\t  }, {\n\t    key: \"attr\",\n\t    value: function attr(a, b, c) {\n\t      if (a === 'transform') a = 'patternTransform';\n\t      return _get(_getPrototypeOf(Pattern.prototype), \"attr\", this).call(this, a, b, c);\n\t    }\n\t  }, {\n\t    key: \"targets\",\n\t    value: function targets() {\n\t      return baseFind('svg [fill*=\"' + this.id() + '\"]');\n\t    }\n\t  }, {\n\t    key: \"bbox\",\n\t    value: function bbox() {\n\t      return new Box();\n\t    }\n\t  }]);\n\n\t  return Pattern;\n\t}(Container);\n\tregisterMethods({\n\t  Container: {\n\t    // Create pattern element in defs\n\t    pattern: function pattern() {\n\t      var _this$defs;\n\n\t      return (_this$defs = this.defs()).pattern.apply(_this$defs, arguments);\n\t    }\n\t  },\n\t  Defs: {\n\t    pattern: wrapWithAttrCheck(function (width, height, block) {\n\t      return this.put(new Pattern()).update(block).attr({\n\t        x: 0,\n\t        y: 0,\n\t        width: width,\n\t        height: height,\n\t        patternUnits: 'userSpaceOnUse'\n\t      });\n\t    })\n\t  }\n\t});\n\tregister(Pattern, 'Pattern');\n\n\tvar Image =\n\t/*#__PURE__*/\n\tfunction (_Shape) {\n\t  _inherits(Image, _Shape);\n\n\t  function Image(node) {\n\t    _classCallCheck(this, Image);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Image).call(this, nodeOrNew('image', node), node));\n\t  } // (re)load image\n\n\n\t  _createClass(Image, [{\n\t    key: \"load\",\n\t    value: function load(url, callback) {\n\t      if (!url) return this;\n\t      var img = new globals.window.Image();\n\t      on(img, 'load', function (e) {\n\t        var p = this.parent(Pattern); // ensure image size\n\n\t        if (this.width() === 0 && this.height() === 0) {\n\t          this.size(img.width, img.height);\n\t        }\n\n\t        if (p instanceof Pattern) {\n\t          // ensure pattern size if not set\n\t          if (p.width() === 0 && p.height() === 0) {\n\t            p.size(this.width(), this.height());\n\t          }\n\t        }\n\n\t        if (typeof callback === 'function') {\n\t          callback.call(this, e);\n\t        }\n\t      }, this);\n\t      on(img, 'load error', function () {\n\t        // dont forget to unbind memory leaking events\n\t        off(img);\n\t      });\n\t      return this.attr('href', img.src = url, xlink);\n\t    }\n\t  }]);\n\n\t  return Image;\n\t}(Shape);\n\tregisterAttrHook(function (attr, val, _this) {\n\t  // convert image fill and stroke to patterns\n\t  if (attr === 'fill' || attr === 'stroke') {\n\t    if (isImage.test(val)) {\n\t      val = _this.root().defs().image(val);\n\t    }\n\t  }\n\n\t  if (val instanceof Image) {\n\t    val = _this.root().defs().pattern(0, 0, function (pattern) {\n\t      pattern.add(val);\n\t    });\n\t  }\n\n\t  return val;\n\t});\n\tregisterMethods({\n\t  Container: {\n\t    // create image element, load image and set its size\n\t    image: wrapWithAttrCheck(function (source, callback) {\n\t      return this.put(new Image()).size(0, 0).load(source, callback);\n\t    })\n\t  }\n\t});\n\tregister(Image, 'Image');\n\n\tvar PointArray = subClassArray('PointArray', SVGArray);\n\textend(PointArray, {\n\t  // Convert array to string\n\t  toString: function toString() {\n\t    // convert to a poly point string\n\t    for (var i = 0, il = this.length, array = []; i < il; i++) {\n\t      array.push(this[i].join(','));\n\t    }\n\n\t    return array.join(' ');\n\t  },\n\t  // Convert array to line object\n\t  toLine: function toLine() {\n\t    return {\n\t      x1: this[0][0],\n\t      y1: this[0][1],\n\t      x2: this[1][0],\n\t      y2: this[1][1]\n\t    };\n\t  },\n\t  // Get morphed array at given position\n\t  at: function at(pos) {\n\t    // make sure a destination is defined\n\t    if (!this.destination) return this; // generate morphed point string\n\n\t    for (var i = 0, il = this.length, array = []; i < il; i++) {\n\t      array.push([this[i][0] + (this.destination[i][0] - this[i][0]) * pos, this[i][1] + (this.destination[i][1] - this[i][1]) * pos]);\n\t    }\n\n\t    return new PointArray(array);\n\t  },\n\t  // Parse point string and flat array\n\t  parse: function parse() {\n\t    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[0, 0]];\n\t    var points = []; // if it is an array\n\n\t    if (array instanceof Array) {\n\t      // and it is not flat, there is no need to parse it\n\t      if (array[0] instanceof Array) {\n\t        return array;\n\t      }\n\t    } else {\n\t      // Else, it is considered as a string\n\t      // parse points\n\t      array = array.trim().split(delimiter).map(parseFloat);\n\t    } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\n\t    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\n\n\n\t    if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples\n\n\t    for (var i = 0, len = array.length; i < len; i = i + 2) {\n\t      points.push([array[i], array[i + 1]]);\n\t    }\n\n\t    return points;\n\t  },\n\t  // transform points with matrix (similar to Point.transform)\n\t  transform: function transform(m) {\n\t    var points = [];\n\n\t    for (var i = 0; i < this.length; i++) {\n\t      var point = this[i]; // Perform the matrix multiplication\n\n\t      points.push([m.a * point[0] + m.c * point[1] + m.e, m.b * point[0] + m.d * point[1] + m.f]);\n\t    } // Return the required point\n\n\n\t    return new PointArray(points);\n\t  },\n\t  // Move point string\n\t  move: function move(x, y) {\n\t    var box = this.bbox(); // get relative offset\n\n\t    x -= box.x;\n\t    y -= box.y; // move every point\n\n\t    if (!isNaN(x) && !isNaN(y)) {\n\t      for (var i = this.length - 1; i >= 0; i--) {\n\t        this[i] = [this[i][0] + x, this[i][1] + y];\n\t      }\n\t    }\n\n\t    return this;\n\t  },\n\t  // Resize poly string\n\t  size: function size(width, height) {\n\t    var i;\n\t    var box = this.bbox(); // recalculate position of all points according to new size\n\n\t    for (i = this.length - 1; i >= 0; i--) {\n\t      if (box.width) this[i][0] = (this[i][0] - box.x) * width / box.width + box.x;\n\t      if (box.height) this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;\n\t    }\n\n\t    return this;\n\t  },\n\t  // Get bounding box of points\n\t  bbox: function bbox() {\n\t    var maxX = -Infinity;\n\t    var maxY = -Infinity;\n\t    var minX = Infinity;\n\t    var minY = Infinity;\n\t    this.forEach(function (el) {\n\t      maxX = Math.max(el[0], maxX);\n\t      maxY = Math.max(el[1], maxY);\n\t      minX = Math.min(el[0], minX);\n\t      minY = Math.min(el[1], minY);\n\t    });\n\t    return {\n\t      x: minX,\n\t      y: minY,\n\t      width: maxX - minX,\n\t      height: maxY - minY\n\t    };\n\t  }\n\t});\n\n\tvar MorphArray = PointArray; // Move by left top corner over x-axis\n\n\tfunction x$1(x) {\n\t  return x == null ? this.bbox().x : this.move(x, this.bbox().y);\n\t} // Move by left top corner over y-axis\n\n\tfunction y$1(y) {\n\t  return y == null ? this.bbox().y : this.move(this.bbox().x, y);\n\t} // Set width of element\n\n\tfunction width$1(width) {\n\t  var b = this.bbox();\n\t  return width == null ? b.width : this.size(width, b.height);\n\t} // Set height of element\n\n\tfunction height$1(height) {\n\t  var b = this.bbox();\n\t  return height == null ? b.height : this.size(b.width, height);\n\t}\n\n\tvar pointed = ({\n\t\t__proto__: null,\n\t\tMorphArray: MorphArray,\n\t\tx: x$1,\n\t\ty: y$1,\n\t\twidth: width$1,\n\t\theight: height$1\n\t});\n\n\tvar Line =\n\t/*#__PURE__*/\n\tfunction (_Shape) {\n\t  _inherits(Line, _Shape);\n\n\t  // Initialize node\n\t  function Line(node) {\n\t    _classCallCheck(this, Line);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Line).call(this, nodeOrNew('line', node), node));\n\t  } // Get array\n\n\n\t  _createClass(Line, [{\n\t    key: \"array\",\n\t    value: function array() {\n\t      return new PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);\n\t    } // Overwrite native plot() method\n\n\t  }, {\n\t    key: \"plot\",\n\t    value: function plot(x1, y1, x2, y2) {\n\t      if (x1 == null) {\n\t        return this.array();\n\t      } else if (typeof y1 !== 'undefined') {\n\t        x1 = {\n\t          x1: x1,\n\t          y1: y1,\n\t          x2: x2,\n\t          y2: y2\n\t        };\n\t      } else {\n\t        x1 = new PointArray(x1).toLine();\n\t      }\n\n\t      return this.attr(x1);\n\t    } // Move by left top corner\n\n\t  }, {\n\t    key: \"move\",\n\t    value: function move(x, y) {\n\t      return this.attr(this.array().move(x, y).toLine());\n\t    } // Set element size to given width and height\n\n\t  }, {\n\t    key: \"size\",\n\t    value: function size(width, height) {\n\t      var p = proportionalSize(this, width, height);\n\t      return this.attr(this.array().size(p.width, p.height).toLine());\n\t    }\n\t  }]);\n\n\t  return Line;\n\t}(Shape);\n\textend(Line, pointed);\n\tregisterMethods({\n\t  Container: {\n\t    // Create a line element\n\t    line: wrapWithAttrCheck(function () {\n\t      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\n\t      // make sure plot is called as a setter\n\t      // x1 is not necessarily a number, it can also be an array, a string and a PointArray\n\t      return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [0, 0, 0, 0]);\n\t    })\n\t  }\n\t});\n\tregister(Line, 'Line');\n\n\tvar Marker =\n\t/*#__PURE__*/\n\tfunction (_Container) {\n\t  _inherits(Marker, _Container);\n\n\t  // Initialize node\n\t  function Marker(node) {\n\t    _classCallCheck(this, Marker);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Marker).call(this, nodeOrNew('marker', node), node));\n\t  } // Set width of element\n\n\n\t  _createClass(Marker, [{\n\t    key: \"width\",\n\t    value: function width(_width) {\n\t      return this.attr('markerWidth', _width);\n\t    } // Set height of element\n\n\t  }, {\n\t    key: \"height\",\n\t    value: function height(_height) {\n\t      return this.attr('markerHeight', _height);\n\t    } // Set marker refX and refY\n\n\t  }, {\n\t    key: \"ref\",\n\t    value: function ref(x, y) {\n\t      return this.attr('refX', x).attr('refY', y);\n\t    } // Update marker\n\n\t  }, {\n\t    key: \"update\",\n\t    value: function update(block) {\n\t      // remove all content\n\t      this.clear(); // invoke passed block\n\n\t      if (typeof block === 'function') {\n\t        block.call(this, this);\n\t      }\n\n\t      return this;\n\t    } // Return the fill id\n\n\t  }, {\n\t    key: \"toString\",\n\t    value: function toString() {\n\t      return 'url(#' + this.id() + ')';\n\t    }\n\t  }]);\n\n\t  return Marker;\n\t}(Container);\n\tregisterMethods({\n\t  Container: {\n\t    marker: function marker() {\n\t      var _this$defs;\n\n\t      // Create marker element in defs\n\t      return (_this$defs = this.defs()).marker.apply(_this$defs, arguments);\n\t    }\n\t  },\n\t  Defs: {\n\t    // Create marker\n\t    marker: wrapWithAttrCheck(function (width, height, block) {\n\t      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\n\t      return this.put(new Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);\n\t    })\n\t  },\n\t  marker: {\n\t    // Create and attach markers\n\t    marker: function marker(_marker, width, height, block) {\n\t      var attr = ['marker']; // Build attribute name\n\n\t      if (_marker !== 'all') attr.push(_marker);\n\t      attr = attr.join('-'); // Set marker attribute\n\n\t      _marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width, height, block);\n\t      return this.attr(attr, _marker);\n\t    }\n\t  }\n\t});\n\tregister(Marker, 'Marker');\n\n\tvar nativeSort = [].sort;\n\tvar test$2 = [1, 2, 3];\n\n\t// IE8-\n\tvar FAILS_ON_UNDEFINED = fails(function () {\n\t  test$2.sort(undefined);\n\t});\n\t// V8 bug\n\tvar FAILS_ON_NULL = fails(function () {\n\t  test$2.sort(null);\n\t});\n\t// Old WebKit\n\tvar SLOPPY_METHOD$2 = sloppyArrayMethod('sort');\n\n\tvar FORCED$4 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || SLOPPY_METHOD$2;\n\n\t// `Array.prototype.sort` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.sort\n\t_export({ target: 'Array', proto: true, forced: FORCED$4 }, {\n\t  sort: function sort(comparefn) {\n\t    return comparefn === undefined\n\t      ? nativeSort.call(toObject(this))\n\t      : nativeSort.call(toObject(this), aFunction$1(comparefn));\n\t  }\n\t});\n\n\t/***\n\tBase Class\n\t==========\n\tThe base stepper class that will be\n\t***/\n\n\tfunction makeSetterGetter(k, f) {\n\t  return function (v) {\n\t    if (v == null) return this[v];\n\t    this[k] = v;\n\t    if (f) f.call(this);\n\t    return this;\n\t  };\n\t}\n\n\tvar easing = {\n\t  '-': function _(pos) {\n\t    return pos;\n\t  },\n\t  '<>': function _(pos) {\n\t    return -Math.cos(pos * Math.PI) / 2 + 0.5;\n\t  },\n\t  '>': function _(pos) {\n\t    return Math.sin(pos * Math.PI / 2);\n\t  },\n\t  '<': function _(pos) {\n\t    return -Math.cos(pos * Math.PI / 2) + 1;\n\t  },\n\t  bezier: function bezier(x1, y1, x2, y2) {\n\t    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo\n\t    return function (t) {\n\t      if (t < 0) {\n\t        if (x1 > 0) {\n\t          return y1 / x1 * t;\n\t        } else if (x2 > 0) {\n\t          return y2 / x2 * t;\n\t        } else {\n\t          return 0;\n\t        }\n\t      } else if (t > 1) {\n\t        if (x2 < 1) {\n\t          return (1 - y2) / (1 - x2) * t + (y2 - x2) / (1 - x2);\n\t        } else if (x1 < 1) {\n\t          return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1);\n\t        } else {\n\t          return 1;\n\t        }\n\t      } else {\n\t        return 3 * t * Math.pow(1 - t, 2) * y1 + 3 * Math.pow(t, 2) * (1 - t) * y2 + Math.pow(t, 3);\n\t      }\n\t    };\n\t  },\n\t  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo\n\t  steps: function steps(_steps) {\n\t    var stepPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'end';\n\t    // deal with \"jump-\" prefix\n\t    stepPosition = stepPosition.split('-').reverse()[0];\n\t    var jumps = _steps;\n\n\t    if (stepPosition === 'none') {\n\t      --jumps;\n\t    } else if (stepPosition === 'both') {\n\t      ++jumps;\n\t    } // The beforeFlag is essentially useless\n\n\n\t    return function (t) {\n\t      var beforeFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t      // Step is called currentStep in referenced url\n\t      var step = Math.floor(t * _steps);\n\t      var jumping = t * step % 1 === 0;\n\n\t      if (stepPosition === 'start' || stepPosition === 'both') {\n\t        ++step;\n\t      }\n\n\t      if (beforeFlag && jumping) {\n\t        --step;\n\t      }\n\n\t      if (t >= 0 && step < 0) {\n\t        step = 0;\n\t      }\n\n\t      if (t <= 1 && step > jumps) {\n\t        step = jumps;\n\t      }\n\n\t      return step / jumps;\n\t    };\n\t  }\n\t};\n\tvar Stepper =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function Stepper() {\n\t    _classCallCheck(this, Stepper);\n\t  }\n\n\t  _createClass(Stepper, [{\n\t    key: \"done\",\n\t    value: function done() {\n\t      return false;\n\t    }\n\t  }]);\n\n\t  return Stepper;\n\t}();\n\t/***\n\tEasing Functions\n\t================\n\t***/\n\n\tvar Ease =\n\t/*#__PURE__*/\n\tfunction (_Stepper) {\n\t  _inherits(Ease, _Stepper);\n\n\t  function Ease(fn) {\n\t    var _this;\n\n\t    _classCallCheck(this, Ease);\n\n\t    _this = _possibleConstructorReturn(this, _getPrototypeOf(Ease).call(this));\n\t    _this.ease = easing[fn || timeline.ease] || fn;\n\t    return _this;\n\t  }\n\n\t  _createClass(Ease, [{\n\t    key: \"step\",\n\t    value: function step(from, to, pos) {\n\t      if (typeof from !== 'number') {\n\t        return pos < 1 ? from : to;\n\t      }\n\n\t      return from + (to - from) * this.ease(pos);\n\t    }\n\t  }]);\n\n\t  return Ease;\n\t}(Stepper);\n\t/***\n\tController Types\n\t================\n\t***/\n\n\tvar Controller =\n\t/*#__PURE__*/\n\tfunction (_Stepper2) {\n\t  _inherits(Controller, _Stepper2);\n\n\t  function Controller(fn) {\n\t    var _this2;\n\n\t    _classCallCheck(this, Controller);\n\n\t    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Controller).call(this));\n\t    _this2.stepper = fn;\n\t    return _this2;\n\t  }\n\n\t  _createClass(Controller, [{\n\t    key: \"step\",\n\t    value: function step(current, target, dt, c) {\n\t      return this.stepper(current, target, dt, c);\n\t    }\n\t  }, {\n\t    key: \"done\",\n\t    value: function done(c) {\n\t      return c.done;\n\t    }\n\t  }]);\n\n\t  return Controller;\n\t}(Stepper);\n\n\tfunction recalculate() {\n\t  // Apply the default parameters\n\t  var duration = (this._duration || 500) / 1000;\n\t  var overshoot = this._overshoot || 0; // Calculate the PID natural response\n\n\t  var eps = 1e-10;\n\t  var pi = Math.PI;\n\t  var os = Math.log(overshoot / 100 + eps);\n\t  var zeta = -os / Math.sqrt(pi * pi + os * os);\n\t  var wn = 3.9 / (zeta * duration); // Calculate the Spring values\n\n\t  this.d = 2 * zeta * wn;\n\t  this.k = wn * wn;\n\t}\n\n\tvar Spring =\n\t/*#__PURE__*/\n\tfunction (_Controller) {\n\t  _inherits(Spring, _Controller);\n\n\t  function Spring(duration, overshoot) {\n\t    var _this3;\n\n\t    _classCallCheck(this, Spring);\n\n\t    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Spring).call(this));\n\n\t    _this3.duration(duration || 500).overshoot(overshoot || 0);\n\n\t    return _this3;\n\t  }\n\n\t  _createClass(Spring, [{\n\t    key: \"step\",\n\t    value: function step(current, target, dt, c) {\n\t      if (typeof current === 'string') return current;\n\t      c.done = dt === Infinity;\n\t      if (dt === Infinity) return target;\n\t      if (dt === 0) return current;\n\t      if (dt > 100) dt = 16;\n\t      dt /= 1000; // Get the previous velocity\n\n\t      var velocity = c.velocity || 0; // Apply the control to get the new position and store it\n\n\t      var acceleration = -this.d * velocity - this.k * (current - target);\n\t      var newPosition = current + velocity * dt + acceleration * dt * dt / 2; // Store the velocity\n\n\t      c.velocity = velocity + acceleration * dt; // Figure out if we have converged, and if so, pass the value\n\n\t      c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;\n\t      return c.done ? target : newPosition;\n\t    }\n\t  }]);\n\n\t  return Spring;\n\t}(Controller);\n\textend(Spring, {\n\t  duration: makeSetterGetter('_duration', recalculate),\n\t  overshoot: makeSetterGetter('_overshoot', recalculate)\n\t});\n\tvar PID =\n\t/*#__PURE__*/\n\tfunction (_Controller2) {\n\t  _inherits(PID, _Controller2);\n\n\t  function PID(p, i, d, windup) {\n\t    var _this4;\n\n\t    _classCallCheck(this, PID);\n\n\t    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PID).call(this));\n\t    p = p == null ? 0.1 : p;\n\t    i = i == null ? 0.01 : i;\n\t    d = d == null ? 0 : d;\n\t    windup = windup == null ? 1000 : windup;\n\n\t    _this4.p(p).i(i).d(d).windup(windup);\n\n\t    return _this4;\n\t  }\n\n\t  _createClass(PID, [{\n\t    key: \"step\",\n\t    value: function step(current, target, dt, c) {\n\t      if (typeof current === 'string') return current;\n\t      c.done = dt === Infinity;\n\t      if (dt === Infinity) return target;\n\t      if (dt === 0) return current;\n\t      var p = target - current;\n\t      var i = (c.integral || 0) + p * dt;\n\t      var d = (p - (c.error || 0)) / dt;\n\t      var windup = this.windup; // antiwindup\n\n\t      if (windup !== false) {\n\t        i = Math.max(-windup, Math.min(i, windup));\n\t      }\n\n\t      c.error = p;\n\t      c.integral = i;\n\t      c.done = Math.abs(p) < 0.001;\n\t      return c.done ? target : current + (this.P * p + this.I * i + this.D * d);\n\t    }\n\t  }]);\n\n\t  return PID;\n\t}(Controller);\n\textend(PID, {\n\t  windup: makeSetterGetter('windup'),\n\t  p: makeSetterGetter('P'),\n\t  i: makeSetterGetter('I'),\n\t  d: makeSetterGetter('D')\n\t});\n\n\tvar PathArray = subClassArray('PathArray', SVGArray);\n\tfunction pathRegReplace(a, b, c, d) {\n\t  return c + d.replace(dots, ' .');\n\t}\n\n\tfunction arrayToString(a) {\n\t  for (var i = 0, il = a.length, s = ''; i < il; i++) {\n\t    s += a[i][0];\n\n\t    if (a[i][1] != null) {\n\t      s += a[i][1];\n\n\t      if (a[i][2] != null) {\n\t        s += ' ';\n\t        s += a[i][2];\n\n\t        if (a[i][3] != null) {\n\t          s += ' ';\n\t          s += a[i][3];\n\t          s += ' ';\n\t          s += a[i][4];\n\n\t          if (a[i][5] != null) {\n\t            s += ' ';\n\t            s += a[i][5];\n\t            s += ' ';\n\t            s += a[i][6];\n\n\t            if (a[i][7] != null) {\n\t              s += ' ';\n\t              s += a[i][7];\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  return s + ' ';\n\t}\n\n\tvar pathHandlers = {\n\t  M: function M(c, p, p0) {\n\t    p.x = p0.x = c[0];\n\t    p.y = p0.y = c[1];\n\t    return ['M', p.x, p.y];\n\t  },\n\t  L: function L(c, p) {\n\t    p.x = c[0];\n\t    p.y = c[1];\n\t    return ['L', c[0], c[1]];\n\t  },\n\t  H: function H(c, p) {\n\t    p.x = c[0];\n\t    return ['H', c[0]];\n\t  },\n\t  V: function V(c, p) {\n\t    p.y = c[0];\n\t    return ['V', c[0]];\n\t  },\n\t  C: function C(c, p) {\n\t    p.x = c[4];\n\t    p.y = c[5];\n\t    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];\n\t  },\n\t  S: function S(c, p) {\n\t    p.x = c[2];\n\t    p.y = c[3];\n\t    return ['S', c[0], c[1], c[2], c[3]];\n\t  },\n\t  Q: function Q(c, p) {\n\t    p.x = c[2];\n\t    p.y = c[3];\n\t    return ['Q', c[0], c[1], c[2], c[3]];\n\t  },\n\t  T: function T(c, p) {\n\t    p.x = c[0];\n\t    p.y = c[1];\n\t    return ['T', c[0], c[1]];\n\t  },\n\t  Z: function Z(c, p, p0) {\n\t    p.x = p0.x;\n\t    p.y = p0.y;\n\t    return ['Z'];\n\t  },\n\t  A: function A(c, p) {\n\t    p.x = c[5];\n\t    p.y = c[6];\n\t    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];\n\t  }\n\t};\n\tvar mlhvqtcsaz = 'mlhvqtcsaz'.split('');\n\n\tfor (var i = 0, il = mlhvqtcsaz.length; i < il; ++i) {\n\t  pathHandlers[mlhvqtcsaz[i]] = function (i) {\n\t    return function (c, p, p0) {\n\t      if (i === 'H') c[0] = c[0] + p.x;else if (i === 'V') c[0] = c[0] + p.y;else if (i === 'A') {\n\t        c[5] = c[5] + p.x;\n\t        c[6] = c[6] + p.y;\n\t      } else {\n\t        for (var j = 0, jl = c.length; j < jl; ++j) {\n\t          c[j] = c[j] + (j % 2 ? p.y : p.x);\n\t        }\n\t      }\n\t      return pathHandlers[i](c, p, p0);\n\t    };\n\t  }(mlhvqtcsaz[i].toUpperCase());\n\t}\n\n\textend(PathArray, {\n\t  // Convert array to string\n\t  toString: function toString() {\n\t    return arrayToString(this);\n\t  },\n\t  // Move path string\n\t  move: function move(x, y) {\n\t    // get bounding box of current situation\n\t    var box = this.bbox(); // get relative offset\n\n\t    x -= box.x;\n\t    y -= box.y;\n\n\t    if (!isNaN(x) && !isNaN(y)) {\n\t      // move every point\n\t      for (var l, i = this.length - 1; i >= 0; i--) {\n\t        l = this[i][0];\n\n\t        if (l === 'M' || l === 'L' || l === 'T') {\n\t          this[i][1] += x;\n\t          this[i][2] += y;\n\t        } else if (l === 'H') {\n\t          this[i][1] += x;\n\t        } else if (l === 'V') {\n\t          this[i][1] += y;\n\t        } else if (l === 'C' || l === 'S' || l === 'Q') {\n\t          this[i][1] += x;\n\t          this[i][2] += y;\n\t          this[i][3] += x;\n\t          this[i][4] += y;\n\n\t          if (l === 'C') {\n\t            this[i][5] += x;\n\t            this[i][6] += y;\n\t          }\n\t        } else if (l === 'A') {\n\t          this[i][6] += x;\n\t          this[i][7] += y;\n\t        }\n\t      }\n\t    }\n\n\t    return this;\n\t  },\n\t  // Resize path string\n\t  size: function size(width, height) {\n\t    // get bounding box of current situation\n\t    var box = this.bbox();\n\t    var i, l; // If the box width or height is 0 then we ignore\n\t    // transformations on the respective axis\n\n\t    box.width = box.width === 0 ? 1 : box.width;\n\t    box.height = box.height === 0 ? 1 : box.height; // recalculate position of all points according to new size\n\n\t    for (i = this.length - 1; i >= 0; i--) {\n\t      l = this[i][0];\n\n\t      if (l === 'M' || l === 'L' || l === 'T') {\n\t        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n\t        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;\n\t      } else if (l === 'H') {\n\t        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n\t      } else if (l === 'V') {\n\t        this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;\n\t      } else if (l === 'C' || l === 'S' || l === 'Q') {\n\t        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;\n\t        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;\n\t        this[i][3] = (this[i][3] - box.x) * width / box.width + box.x;\n\t        this[i][4] = (this[i][4] - box.y) * height / box.height + box.y;\n\n\t        if (l === 'C') {\n\t          this[i][5] = (this[i][5] - box.x) * width / box.width + box.x;\n\t          this[i][6] = (this[i][6] - box.y) * height / box.height + box.y;\n\t        }\n\t      } else if (l === 'A') {\n\t        // resize radii\n\t        this[i][1] = this[i][1] * width / box.width;\n\t        this[i][2] = this[i][2] * height / box.height; // move position values\n\n\t        this[i][6] = (this[i][6] - box.x) * width / box.width + box.x;\n\t        this[i][7] = (this[i][7] - box.y) * height / box.height + box.y;\n\t      }\n\t    }\n\n\t    return this;\n\t  },\n\t  // Test if the passed path array use the same path data commands as this path array\n\t  equalCommands: function equalCommands(pathArray) {\n\t    var i, il, equalCommands;\n\t    pathArray = new PathArray(pathArray);\n\t    equalCommands = this.length === pathArray.length;\n\n\t    for (i = 0, il = this.length; equalCommands && i < il; i++) {\n\t      equalCommands = this[i][0] === pathArray[i][0];\n\t    }\n\n\t    return equalCommands;\n\t  },\n\t  // Make path array morphable\n\t  morph: function morph(pathArray) {\n\t    pathArray = new PathArray(pathArray);\n\n\t    if (this.equalCommands(pathArray)) {\n\t      this.destination = pathArray;\n\t    } else {\n\t      this.destination = null;\n\t    }\n\n\t    return this;\n\t  },\n\t  // Get morphed path array at given position\n\t  at: function at(pos) {\n\t    // make sure a destination is defined\n\t    if (!this.destination) return this;\n\t    var sourceArray = this;\n\t    var destinationArray = this.destination.value;\n\t    var array = [];\n\t    var pathArray = new PathArray();\n\t    var i, il, j, jl; // Animate has specified in the SVG spec\n\t    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\n\n\t    for (i = 0, il = sourceArray.length; i < il; i++) {\n\t      array[i] = [sourceArray[i][0]];\n\n\t      for (j = 1, jl = sourceArray[i].length; j < jl; j++) {\n\t        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;\n\t      } // For the two flags of the elliptical arc command, the SVG spec say:\n\t      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\n\t      // Elliptical arc command as an array followed by corresponding indexes:\n\t      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n\t      //   0    1   2        3                 4             5      6  7\n\n\n\t      if (array[i][0] === 'A') {\n\t        array[i][4] = +(array[i][4] !== 0);\n\t        array[i][5] = +(array[i][5] !== 0);\n\t      }\n\t    } // Directly modify the value of a path array, this is done this way for performance\n\n\n\t    pathArray.value = array;\n\t    return pathArray;\n\t  },\n\t  // Absolutize and parse path to array\n\t  parse: function parse() {\n\t    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [['M', 0, 0]];\n\t    // if it's already a patharray, no need to parse it\n\t    if (array instanceof PathArray) return array; // prepare for parsing\n\n\t    var s;\n\t    var paramCnt = {\n\t      M: 2,\n\t      L: 2,\n\t      H: 1,\n\t      V: 1,\n\t      C: 6,\n\t      S: 4,\n\t      Q: 4,\n\t      T: 2,\n\t      A: 7,\n\t      Z: 0\n\t    };\n\n\t    if (typeof array === 'string') {\n\t      array = array.replace(numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\n\t      .replace(pathLetters, ' $& ') // put some room between letters and numbers\n\t      .replace(hyphen, '$1 -') // add space before hyphen\n\t      .trim() // trim\n\t      .split(delimiter); // split into array\n\t    } else {\n\t      array = array.reduce(function (prev, curr) {\n\t        return [].concat.call(prev, curr);\n\t      }, []);\n\t    } // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\n\n\n\t    var result = [];\n\t    var p = new Point();\n\t    var p0 = new Point();\n\t    var index = 0;\n\t    var len = array.length;\n\n\t    do {\n\t      // Test if we have a path letter\n\t      if (isPathLetter.test(array[index])) {\n\t        s = array[index];\n\t        ++index; // If last letter was a move command and we got no new, it defaults to [L]ine\n\t      } else if (s === 'M') {\n\t        s = 'L';\n\t      } else if (s === 'm') {\n\t        s = 'l';\n\t      }\n\n\t      result.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));\n\t    } while (len > index);\n\n\t    return result;\n\t  },\n\t  // Get bounding box of path\n\t  bbox: function bbox() {\n\t    parser().path.setAttribute('d', this.toString());\n\t    return parser.nodes.path.getBBox();\n\t  }\n\t});\n\n\tvar Morphable =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function Morphable(stepper) {\n\t    _classCallCheck(this, Morphable);\n\n\t    this._stepper = stepper || new Ease('-');\n\t    this._from = null;\n\t    this._to = null;\n\t    this._type = null;\n\t    this._context = null;\n\t    this._morphObj = null;\n\t  }\n\n\t  _createClass(Morphable, [{\n\t    key: \"from\",\n\t    value: function from(val) {\n\t      if (val == null) {\n\t        return this._from;\n\t      }\n\n\t      this._from = this._set(val);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"to\",\n\t    value: function to(val) {\n\t      if (val == null) {\n\t        return this._to;\n\t      }\n\n\t      this._to = this._set(val);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"type\",\n\t    value: function type(_type) {\n\t      // getter\n\t      if (_type == null) {\n\t        return this._type;\n\t      } // setter\n\n\n\t      this._type = _type;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"_set\",\n\t    value: function _set(value) {\n\t      if (!this._type) {\n\t        var type = _typeof(value);\n\n\t        if (type === 'number') {\n\t          this.type(SVGNumber);\n\t        } else if (type === 'string') {\n\t          if (Color.isColor(value)) {\n\t            this.type(Color);\n\t          } else if (delimiter.test(value)) {\n\t            this.type(pathLetters.test(value) ? PathArray : SVGArray);\n\t          } else if (numberAndUnit.test(value)) {\n\t            this.type(SVGNumber);\n\t          } else {\n\t            this.type(NonMorphable);\n\t          }\n\t        } else if (morphableTypes.indexOf(value.constructor) > -1) {\n\t          this.type(value.constructor);\n\t        } else if (Array.isArray(value)) {\n\t          this.type(SVGArray);\n\t        } else if (type === 'object') {\n\t          this.type(ObjectBag);\n\t        } else {\n\t          this.type(NonMorphable);\n\t        }\n\t      }\n\n\t      var result = new this._type(value);\n\n\t      if (this._type === Color) {\n\t        result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;\n\t      }\n\n\t      result = result.toArray();\n\t      this._morphObj = this._morphObj || new this._type();\n\t      this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function (o) {\n\t        o.done = true;\n\t        return o;\n\t      });\n\t      return result;\n\t    }\n\t  }, {\n\t    key: \"stepper\",\n\t    value: function stepper(_stepper) {\n\t      if (_stepper == null) return this._stepper;\n\t      this._stepper = _stepper;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"done\",\n\t    value: function done() {\n\t      var complete = this._context.map(this._stepper.done).reduce(function (last, curr) {\n\t        return last && curr;\n\t      }, true);\n\n\t      return complete;\n\t    }\n\t  }, {\n\t    key: \"at\",\n\t    value: function at(pos) {\n\t      var _this = this;\n\n\t      return this._morphObj.fromArray(this._from.map(function (i, index) {\n\t        return _this._stepper.step(i, _this._to[index], pos, _this._context[index], _this._context);\n\t      }));\n\t    }\n\t  }]);\n\n\t  return Morphable;\n\t}();\n\tvar NonMorphable =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function NonMorphable() {\n\t    _classCallCheck(this, NonMorphable);\n\n\t    this.init.apply(this, arguments);\n\t  }\n\n\t  _createClass(NonMorphable, [{\n\t    key: \"init\",\n\t    value: function init(val) {\n\t      val = Array.isArray(val) ? val[0] : val;\n\t      this.value = val;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"valueOf\",\n\t    value: function valueOf() {\n\t      return this.value;\n\t    }\n\t  }, {\n\t    key: \"toArray\",\n\t    value: function toArray() {\n\t      return [this.value];\n\t    }\n\t  }]);\n\n\t  return NonMorphable;\n\t}();\n\tvar TransformBag =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function TransformBag() {\n\t    _classCallCheck(this, TransformBag);\n\n\t    this.init.apply(this, arguments);\n\t  }\n\n\t  _createClass(TransformBag, [{\n\t    key: \"init\",\n\t    value: function init(obj) {\n\t      if (Array.isArray(obj)) {\n\t        obj = {\n\t          scaleX: obj[0],\n\t          scaleY: obj[1],\n\t          shear: obj[2],\n\t          rotate: obj[3],\n\t          translateX: obj[4],\n\t          translateY: obj[5],\n\t          originX: obj[6],\n\t          originY: obj[7]\n\t        };\n\t      }\n\n\t      Object.assign(this, TransformBag.defaults, obj);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"toArray\",\n\t    value: function toArray() {\n\t      var v = this;\n\t      return [v.scaleX, v.scaleY, v.shear, v.rotate, v.translateX, v.translateY, v.originX, v.originY];\n\t    }\n\t  }]);\n\n\t  return TransformBag;\n\t}();\n\tTransformBag.defaults = {\n\t  scaleX: 1,\n\t  scaleY: 1,\n\t  shear: 0,\n\t  rotate: 0,\n\t  translateX: 0,\n\t  translateY: 0,\n\t  originX: 0,\n\t  originY: 0\n\t};\n\tvar ObjectBag =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function ObjectBag() {\n\t    _classCallCheck(this, ObjectBag);\n\n\t    this.init.apply(this, arguments);\n\t  }\n\n\t  _createClass(ObjectBag, [{\n\t    key: \"init\",\n\t    value: function init(objOrArr) {\n\t      this.values = [];\n\n\t      if (Array.isArray(objOrArr)) {\n\t        this.values = objOrArr;\n\t        return;\n\t      }\n\n\t      objOrArr = objOrArr || {};\n\t      var entries = [];\n\n\t      for (var i in objOrArr) {\n\t        entries.push([i, objOrArr[i]]);\n\t      }\n\n\t      entries.sort(function (a, b) {\n\t        return a[0] - b[0];\n\t      });\n\t      this.values = entries.reduce(function (last, curr) {\n\t        return last.concat(curr);\n\t      }, []);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"valueOf\",\n\t    value: function valueOf() {\n\t      var obj = {};\n\t      var arr = this.values;\n\n\t      for (var i = 0, len = arr.length; i < len; i += 2) {\n\t        obj[arr[i]] = arr[i + 1];\n\t      }\n\n\t      return obj;\n\t    }\n\t  }, {\n\t    key: \"toArray\",\n\t    value: function toArray() {\n\t      return this.values;\n\t    }\n\t  }]);\n\n\t  return ObjectBag;\n\t}();\n\tvar morphableTypes = [NonMorphable, TransformBag, ObjectBag];\n\tfunction registerMorphableType() {\n\t  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t  morphableTypes.push.apply(morphableTypes, _toConsumableArray([].concat(type)));\n\t}\n\tfunction makeMorphable() {\n\t  extend(morphableTypes, {\n\t    to: function to(val) {\n\t      return new Morphable().type(this.constructor).from(this.valueOf()).to(val);\n\t    },\n\t    fromArray: function fromArray(arr) {\n\t      this.init(arr);\n\t      return this;\n\t    }\n\t  });\n\t}\n\n\tvar Path =\n\t/*#__PURE__*/\n\tfunction (_Shape) {\n\t  _inherits(Path, _Shape);\n\n\t  // Initialize node\n\t  function Path(node) {\n\t    _classCallCheck(this, Path);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, nodeOrNew('path', node), node));\n\t  } // Get array\n\n\n\t  _createClass(Path, [{\n\t    key: \"array\",\n\t    value: function array() {\n\t      return this._array || (this._array = new PathArray(this.attr('d')));\n\t    } // Plot new path\n\n\t  }, {\n\t    key: \"plot\",\n\t    value: function plot(d) {\n\t      return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new PathArray(d));\n\t    } // Clear array cache\n\n\t  }, {\n\t    key: \"clear\",\n\t    value: function clear() {\n\t      delete this._array;\n\t      return this;\n\t    } // Move by left top corner\n\n\t  }, {\n\t    key: \"move\",\n\t    value: function move(x, y) {\n\t      return this.attr('d', this.array().move(x, y));\n\t    } // Move by left top corner over x-axis\n\n\t  }, {\n\t    key: \"x\",\n\t    value: function x(_x) {\n\t      return _x == null ? this.bbox().x : this.move(_x, this.bbox().y);\n\t    } // Move by left top corner over y-axis\n\n\t  }, {\n\t    key: \"y\",\n\t    value: function y(_y) {\n\t      return _y == null ? this.bbox().y : this.move(this.bbox().x, _y);\n\t    } // Set element size to given width and height\n\n\t  }, {\n\t    key: \"size\",\n\t    value: function size(width, height) {\n\t      var p = proportionalSize(this, width, height);\n\t      return this.attr('d', this.array().size(p.width, p.height));\n\t    } // Set width of element\n\n\t  }, {\n\t    key: \"width\",\n\t    value: function width(_width) {\n\t      return _width == null ? this.bbox().width : this.size(_width, this.bbox().height);\n\t    } // Set height of element\n\n\t  }, {\n\t    key: \"height\",\n\t    value: function height(_height) {\n\t      return _height == null ? this.bbox().height : this.size(this.bbox().width, _height);\n\t    }\n\t  }, {\n\t    key: \"targets\",\n\t    value: function targets() {\n\t      return baseFind('svg textpath [href*=\"' + this.id() + '\"]');\n\t    }\n\t  }]);\n\n\t  return Path;\n\t}(Shape); // Define morphable array\n\tPath.prototype.MorphArray = PathArray; // Add parent method\n\n\tregisterMethods({\n\t  Container: {\n\t    // Create a wrapped path element\n\t    path: wrapWithAttrCheck(function (d) {\n\t      // make sure plot is called as a setter\n\t      return this.put(new Path()).plot(d || new PathArray());\n\t    })\n\t  }\n\t});\n\tregister(Path, 'Path');\n\n\tfunction array() {\n\t  return this._array || (this._array = new PointArray(this.attr('points')));\n\t} // Plot new path\n\n\tfunction plot(p) {\n\t  return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new PointArray(p));\n\t} // Clear array cache\n\n\tfunction clear() {\n\t  delete this._array;\n\t  return this;\n\t} // Move by left top corner\n\n\tfunction move(x, y) {\n\t  return this.attr('points', this.array().move(x, y));\n\t} // Set element size to given width and height\n\n\tfunction size(width, height) {\n\t  var p = proportionalSize(this, width, height);\n\t  return this.attr('points', this.array().size(p.width, p.height));\n\t}\n\n\tvar poly = ({\n\t\t__proto__: null,\n\t\tarray: array,\n\t\tplot: plot,\n\t\tclear: clear,\n\t\tmove: move,\n\t\tsize: size\n\t});\n\n\tvar Polygon =\n\t/*#__PURE__*/\n\tfunction (_Shape) {\n\t  _inherits(Polygon, _Shape);\n\n\t  // Initialize node\n\t  function Polygon(node) {\n\t    _classCallCheck(this, Polygon);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Polygon).call(this, nodeOrNew('polygon', node), node));\n\t  }\n\n\t  return Polygon;\n\t}(Shape);\n\tregisterMethods({\n\t  Container: {\n\t    // Create a wrapped polygon element\n\t    polygon: wrapWithAttrCheck(function (p) {\n\t      // make sure plot is called as a setter\n\t      return this.put(new Polygon()).plot(p || new PointArray());\n\t    })\n\t  }\n\t});\n\textend(Polygon, pointed);\n\textend(Polygon, poly);\n\tregister(Polygon, 'Polygon');\n\n\tvar Polyline =\n\t/*#__PURE__*/\n\tfunction (_Shape) {\n\t  _inherits(Polyline, _Shape);\n\n\t  // Initialize node\n\t  function Polyline(node) {\n\t    _classCallCheck(this, Polyline);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Polyline).call(this, nodeOrNew('polyline', node), node));\n\t  }\n\n\t  return Polyline;\n\t}(Shape);\n\tregisterMethods({\n\t  Container: {\n\t    // Create a wrapped polygon element\n\t    polyline: wrapWithAttrCheck(function (p) {\n\t      // make sure plot is called as a setter\n\t      return this.put(new Polyline()).plot(p || new PointArray());\n\t    })\n\t  }\n\t});\n\textend(Polyline, pointed);\n\textend(Polyline, poly);\n\tregister(Polyline, 'Polyline');\n\n\tvar Rect =\n\t/*#__PURE__*/\n\tfunction (_Shape) {\n\t  _inherits(Rect, _Shape);\n\n\t  // Initialize node\n\t  function Rect(node) {\n\t    _classCallCheck(this, Rect);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this, nodeOrNew('rect', node), node));\n\t  }\n\n\t  return Rect;\n\t}(Shape);\n\textend(Rect, {\n\t  rx: rx,\n\t  ry: ry\n\t});\n\tregisterMethods({\n\t  Container: {\n\t    // Create a rect element\n\t    rect: wrapWithAttrCheck(function (width, height) {\n\t      return this.put(new Rect()).size(width, height);\n\t    })\n\t  }\n\t});\n\tregister(Rect, 'Rect');\n\n\tvar max$3 = Math.max;\n\tvar min$4 = Math.min;\n\tvar MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;\n\tvar MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';\n\n\t// `Array.prototype.splice` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.splice\n\t// with adding support of @@species\n\t_export({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('splice') }, {\n\t  splice: function splice(start, deleteCount /* , ...items */) {\n\t    var O = toObject(this);\n\t    var len = toLength(O.length);\n\t    var actualStart = toAbsoluteIndex(start, len);\n\t    var argumentsLength = arguments.length;\n\t    var insertCount, actualDeleteCount, A, k, from, to;\n\t    if (argumentsLength === 0) {\n\t      insertCount = actualDeleteCount = 0;\n\t    } else if (argumentsLength === 1) {\n\t      insertCount = 0;\n\t      actualDeleteCount = len - actualStart;\n\t    } else {\n\t      insertCount = argumentsLength - 2;\n\t      actualDeleteCount = min$4(max$3(toInteger(deleteCount), 0), len - actualStart);\n\t    }\n\t    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {\n\t      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);\n\t    }\n\t    A = arraySpeciesCreate(O, actualDeleteCount);\n\t    for (k = 0; k < actualDeleteCount; k++) {\n\t      from = actualStart + k;\n\t      if (from in O) createProperty(A, k, O[from]);\n\t    }\n\t    A.length = actualDeleteCount;\n\t    if (insertCount < actualDeleteCount) {\n\t      for (k = actualStart; k < len - actualDeleteCount; k++) {\n\t        from = k + actualDeleteCount;\n\t        to = k + insertCount;\n\t        if (from in O) O[to] = O[from];\n\t        else delete O[to];\n\t      }\n\t      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];\n\t    } else if (insertCount > actualDeleteCount) {\n\t      for (k = len - actualDeleteCount; k > actualStart; k--) {\n\t        from = k + actualDeleteCount - 1;\n\t        to = k + insertCount - 1;\n\t        if (from in O) O[to] = O[from];\n\t        else delete O[to];\n\t      }\n\t    }\n\t    for (k = 0; k < insertCount; k++) {\n\t      O[k + actualStart] = arguments[k + 2];\n\t    }\n\t    O.length = len - actualDeleteCount + insertCount;\n\t    return A;\n\t  }\n\t});\n\n\tvar Queue =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function Queue() {\n\t    _classCallCheck(this, Queue);\n\n\t    this._first = null;\n\t    this._last = null;\n\t  }\n\n\t  _createClass(Queue, [{\n\t    key: \"push\",\n\t    value: function push(value) {\n\t      // An item stores an id and the provided value\n\t      var item = value.next ? value : {\n\t        value: value,\n\t        next: null,\n\t        prev: null\n\t      }; // Deal with the queue being empty or populated\n\n\t      if (this._last) {\n\t        item.prev = this._last;\n\t        this._last.next = item;\n\t        this._last = item;\n\t      } else {\n\t        this._last = item;\n\t        this._first = item;\n\t      } // Return the current item\n\n\n\t      return item;\n\t    }\n\t  }, {\n\t    key: \"shift\",\n\t    value: function shift() {\n\t      // Check if we have a value\n\t      var remove = this._first;\n\t      if (!remove) return null; // If we do, remove it and relink things\n\n\t      this._first = remove.next;\n\t      if (this._first) this._first.prev = null;\n\t      this._last = this._first ? this._last : null;\n\t      return remove.value;\n\t    } // Shows us the first item in the list\n\n\t  }, {\n\t    key: \"first\",\n\t    value: function first() {\n\t      return this._first && this._first.value;\n\t    } // Shows us the last item in the list\n\n\t  }, {\n\t    key: \"last\",\n\t    value: function last() {\n\t      return this._last && this._last.value;\n\t    } // Removes the item that was returned from the push\n\n\t  }, {\n\t    key: \"remove\",\n\t    value: function remove(item) {\n\t      // Relink the previous item\n\t      if (item.prev) item.prev.next = item.next;\n\t      if (item.next) item.next.prev = item.prev;\n\t      if (item === this._last) this._last = item.prev;\n\t      if (item === this._first) this._first = item.next; // Invalidate item\n\n\t      item.prev = null;\n\t      item.next = null;\n\t    }\n\t  }]);\n\n\t  return Queue;\n\t}();\n\n\tvar Animator = {\n\t  nextDraw: null,\n\t  frames: new Queue(),\n\t  timeouts: new Queue(),\n\t  immediates: new Queue(),\n\t  timer: function timer() {\n\t    return globals.window.performance || globals.window.Date;\n\t  },\n\t  transforms: [],\n\t  frame: function frame(fn) {\n\t    // Store the node\n\t    var node = Animator.frames.push({\n\t      run: fn\n\t    }); // Request an animation frame if we don't have one\n\n\t    if (Animator.nextDraw === null) {\n\t      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n\t    } // Return the node so we can remove it easily\n\n\n\t    return node;\n\t  },\n\t  timeout: function timeout(fn, delay) {\n\t    delay = delay || 0; // Work out when the event should fire\n\n\t    var time = Animator.timer().now() + delay; // Add the timeout to the end of the queue\n\n\t    var node = Animator.timeouts.push({\n\t      run: fn,\n\t      time: time\n\t    }); // Request another animation frame if we need one\n\n\t    if (Animator.nextDraw === null) {\n\t      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n\t    }\n\n\t    return node;\n\t  },\n\t  immediate: function immediate(fn) {\n\t    // Add the immediate fn to the end of the queue\n\t    var node = Animator.immediates.push(fn); // Request another animation frame if we need one\n\n\t    if (Animator.nextDraw === null) {\n\t      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);\n\t    }\n\n\t    return node;\n\t  },\n\t  cancelFrame: function cancelFrame(node) {\n\t    node != null && Animator.frames.remove(node);\n\t  },\n\t  clearTimeout: function clearTimeout(node) {\n\t    node != null && Animator.timeouts.remove(node);\n\t  },\n\t  cancelImmediate: function cancelImmediate(node) {\n\t    node != null && Animator.immediates.remove(node);\n\t  },\n\t  _draw: function _draw(now) {\n\t    // Run all the timeouts we can run, if they are not ready yet, add them\n\t    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])\n\t    var nextTimeout = null;\n\t    var lastTimeout = Animator.timeouts.last();\n\n\t    while (nextTimeout = Animator.timeouts.shift()) {\n\t      // Run the timeout if its time, or push it to the end\n\t      if (now >= nextTimeout.time) {\n\t        nextTimeout.run();\n\t      } else {\n\t        Animator.timeouts.push(nextTimeout);\n\t      } // If we hit the last item, we should stop shifting out more items\n\n\n\t      if (nextTimeout === lastTimeout) break;\n\t    } // Run all of the animation frames\n\n\n\t    var nextFrame = null;\n\t    var lastFrame = Animator.frames.last();\n\n\t    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {\n\t      nextFrame.run(now);\n\t    }\n\n\t    var nextImmediate = null;\n\n\t    while (nextImmediate = Animator.immediates.shift()) {\n\t      nextImmediate();\n\t    } // If we have remaining timeouts or frames, draw until we don't anymore\n\n\n\t    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;\n\t  }\n\t};\n\n\tvar makeSchedule = function makeSchedule(runnerInfo) {\n\t  var start = runnerInfo.start;\n\t  var duration = runnerInfo.runner.duration();\n\t  var end = start + duration;\n\t  return {\n\t    start: start,\n\t    duration: duration,\n\t    end: end,\n\t    runner: runnerInfo.runner\n\t  };\n\t};\n\n\tvar defaultSource = function defaultSource() {\n\t  var w = globals.window;\n\t  return (w.performance || w.Date).now();\n\t};\n\n\tvar Timeline =\n\t/*#__PURE__*/\n\tfunction (_EventTarget) {\n\t  _inherits(Timeline, _EventTarget);\n\n\t  // Construct a new timeline on the given element\n\t  function Timeline() {\n\t    var _this;\n\n\t    var timeSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSource;\n\n\t    _classCallCheck(this, Timeline);\n\n\t    _this = _possibleConstructorReturn(this, _getPrototypeOf(Timeline).call(this));\n\t    _this._timeSource = timeSource; // Store the timing variables\n\n\t    _this._startTime = 0;\n\t    _this._speed = 1.0; // Determines how long a runner is hold in memory. Can be a dt or true/false\n\n\t    _this._persist = 0; // Keep track of the running animations and their starting parameters\n\n\t    _this._nextFrame = null;\n\t    _this._paused = true;\n\t    _this._runners = [];\n\t    _this._runnerIds = [];\n\t    _this._lastRunnerId = -1;\n\t    _this._time = 0;\n\t    _this._lastSourceTime = 0;\n\t    _this._lastStepTime = 0; // Make sure that step is always called in class context\n\n\t    _this._step = _this._stepFn.bind(_assertThisInitialized(_this), false);\n\t    _this._stepImmediate = _this._stepFn.bind(_assertThisInitialized(_this), true);\n\t    return _this;\n\t  } // schedules a runner on the timeline\n\n\n\t  _createClass(Timeline, [{\n\t    key: \"schedule\",\n\t    value: function schedule(runner, delay, when) {\n\t      if (runner == null) {\n\t        return this._runners.map(makeSchedule);\n\t      } // The start time for the next animation can either be given explicitly,\n\t      // derived from the current timeline time or it can be relative to the\n\t      // last start time to chain animations direclty\n\n\n\t      var absoluteStartTime = 0;\n\t      var endTime = this.getEndTime();\n\t      delay = delay || 0; // Work out when to start the animation\n\n\t      if (when == null || when === 'last' || when === 'after') {\n\t        // Take the last time and increment\n\t        absoluteStartTime = endTime;\n\t      } else if (when === 'absolute' || when === 'start') {\n\t        absoluteStartTime = delay;\n\t        delay = 0;\n\t      } else if (when === 'now') {\n\t        absoluteStartTime = this._time;\n\t      } else if (when === 'relative') {\n\t        var _runnerInfo = this._runners[runner.id];\n\n\t        if (_runnerInfo) {\n\t          absoluteStartTime = _runnerInfo.start + delay;\n\t          delay = 0;\n\t        }\n\t      } else {\n\t        throw new Error('Invalid value for the \"when\" parameter');\n\t      } // Manage runner\n\n\n\t      runner.unschedule();\n\t      runner.timeline(this);\n\t      var persist = runner.persist();\n\t      var runnerInfo = {\n\t        persist: persist === null ? this._persist : persist,\n\t        start: absoluteStartTime + delay,\n\t        runner: runner\n\t      };\n\t      this._lastRunnerId = runner.id;\n\n\t      this._runners.push(runnerInfo);\n\n\t      this._runners.sort(function (a, b) {\n\t        return a.start - b.start;\n\t      });\n\n\t      this._runnerIds = this._runners.map(function (info) {\n\t        return info.runner.id;\n\t      });\n\n\t      this.updateTime()._continue();\n\n\t      return this;\n\t    } // Remove the runner from this timeline\n\n\t  }, {\n\t    key: \"unschedule\",\n\t    value: function unschedule(runner) {\n\t      var index = this._runnerIds.indexOf(runner.id);\n\n\t      if (index < 0) return this;\n\n\t      this._runners.splice(index, 1);\n\n\t      this._runnerIds.splice(index, 1);\n\n\t      runner.timeline(null);\n\t      return this;\n\t    } // Calculates the end of the timeline\n\n\t  }, {\n\t    key: \"getEndTime\",\n\t    value: function getEndTime() {\n\t      var lastRunnerInfo = this._runners[this._runnerIds.indexOf(this._lastRunnerId)];\n\n\t      var lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;\n\t      var lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : 0;\n\t      return lastStartTime + lastDuration;\n\t    }\n\t  }, {\n\t    key: \"getEndTimeOfTimeline\",\n\t    value: function getEndTimeOfTimeline() {\n\t      var lastEndTime = 0;\n\n\t      for (var i = 0; i < this._runners.length; i++) {\n\t        var runnerInfo = this._runners[i];\n\t        var duration = runnerInfo ? runnerInfo.runner.duration() : 0;\n\t        var startTime = runnerInfo ? runnerInfo.start : 0;\n\t        var endTime = startTime + duration;\n\n\t        if (endTime > lastEndTime) {\n\t          lastEndTime = endTime;\n\t        }\n\t      }\n\n\t      return lastEndTime;\n\t    } // Makes sure, that after pausing the time doesn't jump\n\n\t  }, {\n\t    key: \"updateTime\",\n\t    value: function updateTime() {\n\t      if (!this.active()) {\n\t        this._lastSourceTime = this._timeSource();\n\t      }\n\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"play\",\n\t    value: function play() {\n\t      // Now make sure we are not paused and continue the animation\n\t      this._paused = false;\n\t      return this.updateTime()._continue();\n\t    }\n\t  }, {\n\t    key: \"pause\",\n\t    value: function pause() {\n\t      this._paused = true;\n\t      return this._continue();\n\t    }\n\t  }, {\n\t    key: \"stop\",\n\t    value: function stop() {\n\t      // Go to start and pause\n\t      this.time(0);\n\t      return this.pause();\n\t    }\n\t  }, {\n\t    key: \"finish\",\n\t    value: function finish() {\n\t      // Go to end and pause\n\t      this.time(this.getEndTimeOfTimeline() + 1);\n\t      return this.pause();\n\t    }\n\t  }, {\n\t    key: \"speed\",\n\t    value: function speed(_speed) {\n\t      if (_speed == null) return this._speed;\n\t      this._speed = _speed;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"reverse\",\n\t    value: function reverse(yes) {\n\t      var currentSpeed = this.speed();\n\t      if (yes == null) return this.speed(-currentSpeed);\n\t      var positive = Math.abs(currentSpeed);\n\t      return this.speed(yes ? positive : -positive);\n\t    }\n\t  }, {\n\t    key: \"seek\",\n\t    value: function seek(dt) {\n\t      return this.time(this._time + dt);\n\t    }\n\t  }, {\n\t    key: \"time\",\n\t    value: function time(_time) {\n\t      if (_time == null) return this._time;\n\t      this._time = _time;\n\t      return this._continue(true);\n\t    }\n\t  }, {\n\t    key: \"persist\",\n\t    value: function persist(dtOrForever) {\n\t      if (dtOrForever == null) return this._persist;\n\t      this._persist = dtOrForever;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"source\",\n\t    value: function source(fn) {\n\t      if (fn == null) return this._timeSource;\n\t      this._timeSource = fn;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"_stepFn\",\n\t    value: function _stepFn() {\n\t      var immediateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t      // Get the time delta from the last time and update the time\n\t      var time = this._timeSource();\n\n\t      var dtSource = time - this._lastSourceTime;\n\t      if (immediateStep) dtSource = 0;\n\t      var dtTime = this._speed * dtSource + (this._time - this._lastStepTime);\n\t      this._lastSourceTime = time; // Only update the time if we use the timeSource.\n\t      // Otherwise use the current time\n\n\t      if (!immediateStep) {\n\t        // Update the time\n\t        this._time += dtTime;\n\t        this._time = this._time < 0 ? 0 : this._time;\n\t      }\n\n\t      this._lastStepTime = this._time;\n\t      this.fire('time', this._time); // This is for the case that the timeline was seeked so that the time\n\t      // is now before the startTime of the runner. Thats why we need to set\n\t      // the runner to position 0\n\t      // FIXME:\n\t      // However, reseting in insertion order leads to bugs. Considering the case,\n\t      // where 2 runners change the same attriute but in different times,\n\t      // reseting both of them will lead to the case where the later defined\n\t      // runner always wins the reset even if the other runner started earlier\n\t      // and therefore should win the attribute battle\n\t      // this can be solved by reseting them backwards\n\n\t      for (var k = this._runners.length; k--;) {\n\t        // Get and run the current runner and ignore it if its inactive\n\t        var runnerInfo = this._runners[k];\n\t        var runner = runnerInfo.runner; // Make sure that we give the actual difference\n\t        // between runner start time and now\n\n\t        var dtToStart = this._time - runnerInfo.start; // Dont run runner if not started yet\n\t        // and try to reset it\n\n\t        if (dtToStart <= 0) {\n\t          runner.reset();\n\t        }\n\t      } // Run all of the runners directly\n\n\n\t      var runnersLeft = false;\n\n\t      for (var i = 0, len = this._runners.length; i < len; i++) {\n\t        // Get and run the current runner and ignore it if its inactive\n\t        var _runnerInfo2 = this._runners[i];\n\t        var _runner = _runnerInfo2.runner;\n\t        var dt = dtTime; // Make sure that we give the actual difference\n\t        // between runner start time and now\n\n\t        var _dtToStart = this._time - _runnerInfo2.start; // Dont run runner if not started yet\n\n\n\t        if (_dtToStart <= 0) {\n\t          runnersLeft = true;\n\t          continue;\n\t        } else if (_dtToStart < dt) {\n\t          // Adjust dt to make sure that animation is on point\n\t          dt = _dtToStart;\n\t        }\n\n\t        if (!_runner.active()) continue; // If this runner is still going, signal that we need another animation\n\t        // frame, otherwise, remove the completed runner\n\n\t        var finished = _runner.step(dt).done;\n\n\t        if (!finished) {\n\t          runnersLeft = true; // continue\n\t        } else if (_runnerInfo2.persist !== true) {\n\t          // runner is finished. And runner might get removed\n\t          var endTime = _runner.duration() - _runner.time() + this._time;\n\n\t          if (endTime + _runnerInfo2.persist < this._time) {\n\t            // Delete runner and correct index\n\t            _runner.unschedule();\n\n\t            --i;\n\t            --len;\n\t          }\n\t        }\n\t      } // Basically: we continue when there are runners right from us in time\n\t      // when -->, and when runners are left from us when <--\n\n\n\t      if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {\n\t        this._continue();\n\t      } else {\n\t        this.pause();\n\t        this.fire('finished');\n\t      }\n\n\t      return this;\n\t    } // Checks if we are running and continues the animation\n\n\t  }, {\n\t    key: \"_continue\",\n\t    value: function _continue() {\n\t      var immediateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t      Animator.cancelFrame(this._nextFrame);\n\t      this._nextFrame = null;\n\t      if (immediateStep) return this._stepImmediate();\n\t      if (this._paused) return this;\n\t      this._nextFrame = Animator.frame(this._step);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"active\",\n\t    value: function active() {\n\t      return !!this._nextFrame;\n\t    }\n\t  }]);\n\n\t  return Timeline;\n\t}(EventTarget);\n\tregisterMethods({\n\t  Element: {\n\t    timeline: function timeline(_timeline) {\n\t      if (_timeline == null) {\n\t        this._timeline = this._timeline || new Timeline();\n\t        return this._timeline;\n\t      } else {\n\t        this._timeline = _timeline;\n\t        return this;\n\t      }\n\t    }\n\t  }\n\t});\n\n\tfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\n\tfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\tvar Runner =\n\t/*#__PURE__*/\n\tfunction (_EventTarget) {\n\t  _inherits(Runner, _EventTarget);\n\n\t  function Runner(options) {\n\t    var _this;\n\n\t    _classCallCheck(this, Runner);\n\n\t    _this = _possibleConstructorReturn(this, _getPrototypeOf(Runner).call(this)); // Store a unique id on the runner, so that we can identify it later\n\n\t    _this.id = Runner.id++; // Ensure a default value\n\n\t    options = options == null ? timeline.duration : options; // Ensure that we get a controller\n\n\t    options = typeof options === 'function' ? new Controller(options) : options; // Declare all of the variables\n\n\t    _this._element = null;\n\t    _this._timeline = null;\n\t    _this.done = false;\n\t    _this._queue = []; // Work out the stepper and the duration\n\n\t    _this._duration = typeof options === 'number' && options;\n\t    _this._isDeclarative = options instanceof Controller;\n\t    _this._stepper = _this._isDeclarative ? options : new Ease(); // We copy the current values from the timeline because they can change\n\n\t    _this._history = {}; // Store the state of the runner\n\n\t    _this.enabled = true;\n\t    _this._time = 0;\n\t    _this._lastTime = 0; // At creation, the runner is in reseted state\n\n\t    _this._reseted = true; // Save transforms applied to this runner\n\n\t    _this.transforms = new Matrix();\n\t    _this.transformId = 1; // Looping variables\n\n\t    _this._haveReversed = false;\n\t    _this._reverse = false;\n\t    _this._loopsDone = 0;\n\t    _this._swing = false;\n\t    _this._wait = 0;\n\t    _this._times = 1;\n\t    _this._frameId = null; // Stores how long a runner is stored after beeing done\n\n\t    _this._persist = _this._isDeclarative ? true : null;\n\t    return _this;\n\t  }\n\t  /*\n\t  Runner Definitions\n\t  ==================\n\t  These methods help us define the runtime behaviour of the Runner or they\n\t  help us make new runners from the current runner\n\t  */\n\n\n\t  _createClass(Runner, [{\n\t    key: \"element\",\n\t    value: function element(_element) {\n\t      if (_element == null) return this._element;\n\t      this._element = _element;\n\n\t      _element._prepareRunner();\n\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"timeline\",\n\t    value: function timeline(_timeline) {\n\t      // check explicitly for undefined so we can set the timeline to null\n\t      if (typeof _timeline === 'undefined') return this._timeline;\n\t      this._timeline = _timeline;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"animate\",\n\t    value: function animate(duration, delay, when) {\n\t      var o = Runner.sanitise(duration, delay, when);\n\t      var runner = new Runner(o.duration);\n\t      if (this._timeline) runner.timeline(this._timeline);\n\t      if (this._element) runner.element(this._element);\n\t      return runner.loop(o).schedule(o.delay, o.when);\n\t    }\n\t  }, {\n\t    key: \"schedule\",\n\t    value: function schedule(timeline, delay, when) {\n\t      // The user doesn't need to pass a timeline if we already have one\n\t      if (!(timeline instanceof Timeline)) {\n\t        when = delay;\n\t        delay = timeline;\n\t        timeline = this.timeline();\n\t      } // If there is no timeline, yell at the user...\n\n\n\t      if (!timeline) {\n\t        throw Error('Runner cannot be scheduled without timeline');\n\t      } // Schedule the runner on the timeline provided\n\n\n\t      timeline.schedule(this, delay, when);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"unschedule\",\n\t    value: function unschedule() {\n\t      var timeline = this.timeline();\n\t      timeline && timeline.unschedule(this);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"loop\",\n\t    value: function loop(times, swing, wait) {\n\t      // Deal with the user passing in an object\n\t      if (_typeof(times) === 'object') {\n\t        swing = times.swing;\n\t        wait = times.wait;\n\t        times = times.times;\n\t      } // Sanitise the values and store them\n\n\n\t      this._times = times || Infinity;\n\t      this._swing = swing || false;\n\t      this._wait = wait || 0; // Allow true to be passed\n\n\t      if (this._times === true) {\n\t        this._times = Infinity;\n\t      }\n\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"delay\",\n\t    value: function delay(_delay) {\n\t      return this.animate(0, _delay);\n\t    }\n\t    /*\n\t    Basic Functionality\n\t    ===================\n\t    These methods allow us to attach basic functions to the runner directly\n\t    */\n\n\t  }, {\n\t    key: \"queue\",\n\t    value: function queue(initFn, runFn, retargetFn, isTransform) {\n\t      this._queue.push({\n\t        initialiser: initFn || noop,\n\t        runner: runFn || noop,\n\t        retarget: retargetFn,\n\t        isTransform: isTransform,\n\t        initialised: false,\n\t        finished: false\n\t      });\n\n\t      var timeline = this.timeline();\n\t      timeline && this.timeline()._continue();\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"during\",\n\t    value: function during(fn) {\n\t      return this.queue(null, fn);\n\t    }\n\t  }, {\n\t    key: \"after\",\n\t    value: function after(fn) {\n\t      return this.on('finished', fn);\n\t    }\n\t    /*\n\t    Runner animation methods\n\t    ========================\n\t    Control how the animation plays\n\t    */\n\n\t  }, {\n\t    key: \"time\",\n\t    value: function time(_time) {\n\t      if (_time == null) {\n\t        return this._time;\n\t      }\n\n\t      var dt = _time - this._time;\n\t      this.step(dt);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"duration\",\n\t    value: function duration() {\n\t      return this._times * (this._wait + this._duration) - this._wait;\n\t    }\n\t  }, {\n\t    key: \"loops\",\n\t    value: function loops(p) {\n\t      var loopDuration = this._duration + this._wait;\n\n\t      if (p == null) {\n\t        var loopsDone = Math.floor(this._time / loopDuration);\n\t        var relativeTime = this._time - loopsDone * loopDuration;\n\t        var position = relativeTime / this._duration;\n\t        return Math.min(loopsDone + position, this._times);\n\t      }\n\n\t      var whole = Math.floor(p);\n\t      var partial = p % 1;\n\t      var time = loopDuration * whole + this._duration * partial;\n\t      return this.time(time);\n\t    }\n\t  }, {\n\t    key: \"persist\",\n\t    value: function persist(dtOrForever) {\n\t      if (dtOrForever == null) return this._persist;\n\t      this._persist = dtOrForever;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"position\",\n\t    value: function position(p) {\n\t      // Get all of the variables we need\n\t      var x = this._time;\n\t      var d = this._duration;\n\t      var w = this._wait;\n\t      var t = this._times;\n\t      var s = this._swing;\n\t      var r = this._reverse;\n\t      var position;\n\n\t      if (p == null) {\n\t        /*\n\t        This function converts a time to a position in the range [0, 1]\n\t        The full explanation can be found in this desmos demonstration\n\t          https://www.desmos.com/calculator/u4fbavgche\n\t        The logic is slightly simplified here because we can use booleans\n\t        */\n\t        // Figure out the value without thinking about the start or end time\n\t        var f = function f(x) {\n\t          var swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));\n\t          var backwards = swinging && !r || !swinging && r;\n\t          var uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;\n\t          var clipped = Math.max(Math.min(uncliped, 1), 0);\n\t          return clipped;\n\t        }; // Figure out the value by incorporating the start time\n\n\n\t        var endTime = t * (w + d) - w;\n\t        position = x <= 0 ? Math.round(f(1e-5)) : x < endTime ? f(x) : Math.round(f(endTime - 1e-5));\n\t        return position;\n\t      } // Work out the loops done and add the position to the loops done\n\n\n\t      var loopsDone = Math.floor(this.loops());\n\t      var swingForward = s && loopsDone % 2 === 0;\n\t      var forwards = swingForward && !r || r && swingForward;\n\t      position = loopsDone + (forwards ? p : 1 - p);\n\t      return this.loops(position);\n\t    }\n\t  }, {\n\t    key: \"progress\",\n\t    value: function progress(p) {\n\t      if (p == null) {\n\t        return Math.min(1, this._time / this.duration());\n\t      }\n\n\t      return this.time(p * this.duration());\n\t    }\n\t  }, {\n\t    key: \"step\",\n\t    value: function step(dt) {\n\t      // If we are inactive, this stepper just gets skipped\n\t      if (!this.enabled) return this; // Update the time and get the new position\n\n\t      dt = dt == null ? 16 : dt;\n\t      this._time += dt;\n\t      var position = this.position(); // Figure out if we need to run the stepper in this frame\n\n\t      var running = this._lastPosition !== position && this._time >= 0;\n\t      this._lastPosition = position; // Figure out if we just started\n\n\t      var duration = this.duration();\n\t      var justStarted = this._lastTime <= 0 && this._time > 0;\n\t      var justFinished = this._lastTime < duration && this._time >= duration;\n\t      this._lastTime = this._time;\n\n\t      if (justStarted) {\n\t        this.fire('start', this);\n\t      } // Work out if the runner is finished set the done flag here so animations\n\t      // know, that they are running in the last step (this is good for\n\t      // transformations which can be merged)\n\n\n\t      var declarative = this._isDeclarative;\n\t      this.done = !declarative && !justFinished && this._time >= duration; // Runner is running. So its not in reseted state anymore\n\n\t      this._reseted = false; // Call initialise and the run function\n\n\t      if (running || declarative) {\n\t        this._initialise(running); // clear the transforms on this runner so they dont get added again and again\n\n\n\t        this.transforms = new Matrix();\n\n\t        var converged = this._run(declarative ? dt : position);\n\n\t        this.fire('step', this);\n\t      } // correct the done flag here\n\t      // declaritive animations itself know when they converged\n\n\n\t      this.done = this.done || converged && declarative;\n\n\t      if (justFinished) {\n\t        this.fire('finished', this);\n\t      }\n\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"reset\",\n\t    value: function reset() {\n\t      if (this._reseted) return this;\n\t      this.time(0);\n\t      this._reseted = true;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"finish\",\n\t    value: function finish() {\n\t      return this.step(Infinity);\n\t    }\n\t  }, {\n\t    key: \"reverse\",\n\t    value: function reverse(_reverse) {\n\t      this._reverse = _reverse == null ? !this._reverse : _reverse;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"ease\",\n\t    value: function ease(fn) {\n\t      this._stepper = new Ease(fn);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"active\",\n\t    value: function active(enabled) {\n\t      if (enabled == null) return this.enabled;\n\t      this.enabled = enabled;\n\t      return this;\n\t    }\n\t    /*\n\t    Private Methods\n\t    ===============\n\t    Methods that shouldn't be used externally\n\t    */\n\t    // Save a morpher to the morpher list so that we can retarget it later\n\n\t  }, {\n\t    key: \"_rememberMorpher\",\n\t    value: function _rememberMorpher(method, morpher) {\n\t      this._history[method] = {\n\t        morpher: morpher,\n\t        caller: this._queue[this._queue.length - 1]\n\t      }; // We have to resume the timeline in case a controller\n\t      // is already done without beeing ever run\n\t      // This can happen when e.g. this is done:\n\t      //    anim = el.animate(new SVG.Spring)\n\t      // and later\n\t      //    anim.move(...)\n\n\t      if (this._isDeclarative) {\n\t        var timeline = this.timeline();\n\t        timeline && timeline.play();\n\t      }\n\t    } // Try to set the target for a morpher if the morpher exists, otherwise\n\t    // do nothing and return false\n\n\t  }, {\n\t    key: \"_tryRetarget\",\n\t    value: function _tryRetarget(method, target, extra) {\n\t      if (this._history[method]) {\n\t        // if the last method wasnt even initialised, throw it away\n\t        if (!this._history[method].caller.initialised) {\n\t          var index = this._queue.indexOf(this._history[method].caller);\n\n\t          this._queue.splice(index, 1);\n\n\t          return false;\n\t        } // for the case of transformations, we use the special retarget function\n\t        // which has access to the outer scope\n\n\n\t        if (this._history[method].caller.retarget) {\n\t          this._history[method].caller.retarget(target, extra); // for everything else a simple morpher change is sufficient\n\n\t        } else {\n\t          this._history[method].morpher.to(target);\n\t        }\n\n\t        this._history[method].caller.finished = false;\n\t        var timeline = this.timeline();\n\t        timeline && timeline.play();\n\t        return true;\n\t      }\n\n\t      return false;\n\t    } // Run each initialise function in the runner if required\n\n\t  }, {\n\t    key: \"_initialise\",\n\t    value: function _initialise(running) {\n\t      // If we aren't running, we shouldn't initialise when not declarative\n\t      if (!running && !this._isDeclarative) return; // Loop through all of the initialisers\n\n\t      for (var i = 0, len = this._queue.length; i < len; ++i) {\n\t        // Get the current initialiser\n\t        var current = this._queue[i]; // Determine whether we need to initialise\n\n\t        var needsIt = this._isDeclarative || !current.initialised && running;\n\t        running = !current.finished; // Call the initialiser if we need to\n\n\t        if (needsIt && running) {\n\t          current.initialiser.call(this);\n\t          current.initialised = true;\n\t        }\n\t      }\n\t    } // Run each run function for the position or dt given\n\n\t  }, {\n\t    key: \"_run\",\n\t    value: function _run(positionOrDt) {\n\t      // Run all of the _queue directly\n\t      var allfinished = true;\n\n\t      for (var i = 0, len = this._queue.length; i < len; ++i) {\n\t        // Get the current function to run\n\t        var current = this._queue[i]; // Run the function if its not finished, we keep track of the finished\n\t        // flag for the sake of declarative _queue\n\n\t        var converged = current.runner.call(this, positionOrDt);\n\t        current.finished = current.finished || converged === true;\n\t        allfinished = allfinished && current.finished;\n\t      } // We report when all of the constructors are finished\n\n\n\t      return allfinished;\n\t    }\n\t  }, {\n\t    key: \"addTransform\",\n\t    value: function addTransform(transform, index) {\n\t      this.transforms.lmultiplyO(transform);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"clearTransform\",\n\t    value: function clearTransform() {\n\t      this.transforms = new Matrix();\n\t      return this;\n\t    } // TODO: Keep track of all transformations so that deletion is faster\n\n\t  }, {\n\t    key: \"clearTransformsFromQueue\",\n\t    value: function clearTransformsFromQueue() {\n\t      if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {\n\t        this._queue = this._queue.filter(function (item) {\n\t          return !item.isTransform;\n\t        });\n\t      }\n\t    }\n\t  }], [{\n\t    key: \"sanitise\",\n\t    value: function sanitise(duration, delay, when) {\n\t      // Initialise the default parameters\n\t      var times = 1;\n\t      var swing = false;\n\t      var wait = 0;\n\t      duration = duration || timeline.duration;\n\t      delay = delay || timeline.delay;\n\t      when = when || 'last'; // If we have an object, unpack the values\n\n\t      if (_typeof(duration) === 'object' && !(duration instanceof Stepper)) {\n\t        delay = duration.delay || delay;\n\t        when = duration.when || when;\n\t        swing = duration.swing || swing;\n\t        times = duration.times || times;\n\t        wait = duration.wait || wait;\n\t        duration = duration.duration || timeline.duration;\n\t      }\n\n\t      return {\n\t        duration: duration,\n\t        delay: delay,\n\t        swing: swing,\n\t        times: times,\n\t        wait: wait,\n\t        when: when\n\t      };\n\t    }\n\t  }]);\n\n\t  return Runner;\n\t}(EventTarget);\n\tRunner.id = 0;\n\n\tvar FakeRunner =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function FakeRunner() {\n\t    var transforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();\n\t    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\t    var done = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n\t    _classCallCheck(this, FakeRunner);\n\n\t    this.transforms = transforms;\n\t    this.id = id;\n\t    this.done = done;\n\t  }\n\n\t  _createClass(FakeRunner, [{\n\t    key: \"clearTransformsFromQueue\",\n\t    value: function clearTransformsFromQueue() {}\n\t  }]);\n\n\t  return FakeRunner;\n\t}();\n\n\textend([Runner, FakeRunner], {\n\t  mergeWith: function mergeWith(runner) {\n\t    return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);\n\t  }\n\t}); // FakeRunner.emptyRunner = new FakeRunner()\n\n\tvar lmultiply = function lmultiply(last, curr) {\n\t  return last.lmultiplyO(curr);\n\t};\n\n\tvar getRunnerTransform = function getRunnerTransform(runner) {\n\t  return runner.transforms;\n\t};\n\n\tfunction mergeTransforms() {\n\t  // Find the matrix to apply to the element and apply it\n\t  var runners = this._transformationRunners.runners;\n\t  var netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());\n\t  this.transform(netTransform);\n\n\t  this._transformationRunners.merge();\n\n\t  if (this._transformationRunners.length() === 1) {\n\t    this._frameId = null;\n\t  }\n\t}\n\n\tvar RunnerArray =\n\t/*#__PURE__*/\n\tfunction () {\n\t  function RunnerArray() {\n\t    _classCallCheck(this, RunnerArray);\n\n\t    this.runners = [];\n\t    this.ids = [];\n\t  }\n\n\t  _createClass(RunnerArray, [{\n\t    key: \"add\",\n\t    value: function add(runner) {\n\t      if (this.runners.includes(runner)) return;\n\t      var id = runner.id + 1;\n\t      this.runners.push(runner);\n\t      this.ids.push(id);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"getByID\",\n\t    value: function getByID(id) {\n\t      return this.runners[this.ids.indexOf(id + 1)];\n\t    }\n\t  }, {\n\t    key: \"remove\",\n\t    value: function remove(id) {\n\t      var index = this.ids.indexOf(id + 1);\n\t      this.ids.splice(index, 1);\n\t      this.runners.splice(index, 1);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"merge\",\n\t    value: function merge() {\n\t      var _this2 = this;\n\n\t      var lastRunner = null;\n\t      this.runners.forEach(function (runner, i) {\n\t        var condition = lastRunner && runner.done && lastRunner.done // don't merge runner when persisted on timeline\n\t        && (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));\n\n\t        if (condition) {\n\t          // the +1 happens in the function\n\t          _this2.remove(runner.id);\n\n\t          _this2.edit(lastRunner.id, runner.mergeWith(lastRunner));\n\t        }\n\n\t        lastRunner = runner;\n\t      });\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"edit\",\n\t    value: function edit(id, newRunner) {\n\t      var index = this.ids.indexOf(id + 1);\n\t      this.ids.splice(index, 1, id + 1);\n\t      this.runners.splice(index, 1, newRunner);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"length\",\n\t    value: function length() {\n\t      return this.ids.length;\n\t    }\n\t  }, {\n\t    key: \"clearBefore\",\n\t    value: function clearBefore(id) {\n\t      var deleteCnt = this.ids.indexOf(id + 1) || 1;\n\t      this.ids.splice(0, deleteCnt, 0);\n\t      this.runners.splice(0, deleteCnt, new FakeRunner()).forEach(function (r) {\n\t        return r.clearTransformsFromQueue();\n\t      });\n\t      return this;\n\t    }\n\t  }]);\n\n\t  return RunnerArray;\n\t}();\n\n\tregisterMethods({\n\t  Element: {\n\t    animate: function animate(duration, delay, when) {\n\t      var o = Runner.sanitise(duration, delay, when);\n\t      var timeline = this.timeline();\n\t      return new Runner(o.duration).loop(o).element(this).timeline(timeline.play()).schedule(o.delay, o.when);\n\t    },\n\t    delay: function delay(by, when) {\n\t      return this.animate(0, by, when);\n\t    },\n\t    // this function searches for all runners on the element and deletes the ones\n\t    // which run before the current one. This is because absolute transformations\n\t    // overwfrite anything anyway so there is no need to waste time computing\n\t    // other runners\n\t    _clearTransformRunnersBefore: function _clearTransformRunnersBefore(currentRunner) {\n\t      this._transformationRunners.clearBefore(currentRunner.id);\n\t    },\n\t    _currentTransform: function _currentTransform(current) {\n\t      return this._transformationRunners.runners // we need the equal sign here to make sure, that also transformations\n\t      // on the same runner which execute before the current transformation are\n\t      // taken into account\n\t      .filter(function (runner) {\n\t        return runner.id <= current.id;\n\t      }).map(getRunnerTransform).reduce(lmultiply, new Matrix());\n\t    },\n\t    _addRunner: function _addRunner(runner) {\n\t      this._transformationRunners.add(runner); // Make sure that the runner merge is executed at the very end of\n\t      // all Animator functions. Thats why we use immediate here to execute\n\t      // the merge right after all frames are run\n\n\n\t      Animator.cancelImmediate(this._frameId);\n\t      this._frameId = Animator.immediate(mergeTransforms.bind(this));\n\t    },\n\t    _prepareRunner: function _prepareRunner() {\n\t      if (this._frameId == null) {\n\t        this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));\n\t      }\n\t    }\n\t  }\n\t});\n\textend(Runner, {\n\t  attr: function attr(a, v) {\n\t    return this.styleAttr('attr', a, v);\n\t  },\n\t  // Add animatable styles\n\t  css: function css(s, v) {\n\t    return this.styleAttr('css', s, v);\n\t  },\n\t  styleAttr: function styleAttr(type, name, val) {\n\t    // apply attributes individually\n\t    if (_typeof(name) === 'object') {\n\t      for (var key in name) {\n\t        this.styleAttr(type, key, name[key]);\n\t      }\n\n\t      return this;\n\t    }\n\n\t    var morpher = new Morphable(this._stepper).to(val);\n\t    this.queue(function () {\n\t      morpher = morpher.from(this.element()[type](name));\n\t    }, function (pos) {\n\t      this.element()[type](name, morpher.at(pos));\n\t      return morpher.done();\n\t    });\n\t    return this;\n\t  },\n\t  zoom: function zoom(level, point) {\n\t    if (this._tryRetarget('zoom', to, point)) return this;\n\t    var morpher = new Morphable(this._stepper).to(new SVGNumber(level));\n\t    this.queue(function () {\n\t      morpher = morpher.from(this.element().zoom());\n\t    }, function (pos) {\n\t      this.element().zoom(morpher.at(pos), point);\n\t      return morpher.done();\n\t    }, function (newLevel, newPoint) {\n\t      point = newPoint;\n\t      morpher.to(newLevel);\n\t    });\n\n\t    this._rememberMorpher('zoom', morpher);\n\n\t    return this;\n\t  },\n\n\t  /**\n\t   ** absolute transformations\n\t   **/\n\t  //\n\t  // M v -----|-----(D M v = F v)------|----->  T v\n\t  //\n\t  // 1. define the final state (T) and decompose it (once)\n\t  //    t = [tx, ty, the, lam, sy, sx]\n\t  // 2. on every frame: pull the current state of all previous transforms\n\t  //    (M - m can change)\n\t  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]\n\t  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)\n\t  //   - Note F(0) = M\n\t  //   - Note F(1) = T\n\t  // 4. Now you get the delta matrix as a result: D = F * inv(M)\n\t  transform: function transform(transforms, relative, affine) {\n\t    // If we have a declarative function, we should retarget it if possible\n\t    relative = transforms.relative || relative;\n\n\t    if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {\n\t      return this;\n\t    } // Parse the parameters\n\n\n\t    var isMatrix = Matrix.isMatrixLike(transforms);\n\t    affine = transforms.affine != null ? transforms.affine : affine != null ? affine : !isMatrix; // Create a morepher and set its type\n\n\t    var morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);\n\t    var origin;\n\t    var element;\n\t    var current;\n\t    var currentAngle;\n\t    var startTransform;\n\n\t    function setup() {\n\t      // make sure element and origin is defined\n\t      element = element || this.element();\n\t      origin = origin || getOrigin(transforms, element);\n\t      startTransform = new Matrix(relative ? undefined : element); // add the runner to the element so it can merge transformations\n\n\t      element._addRunner(this); // Deactivate all transforms that have run so far if we are absolute\n\n\n\t      if (!relative) {\n\t        element._clearTransformRunnersBefore(this);\n\t      }\n\t    }\n\n\t    function run(pos) {\n\t      // clear all other transforms before this in case something is saved\n\t      // on this runner. We are absolute. We dont need these!\n\t      if (!relative) this.clearTransform();\n\n\t      var _transform = new Point(origin).transform(element._currentTransform(this)),\n\t          x = _transform.x,\n\t          y = _transform.y;\n\n\t      var target = new Matrix(_objectSpread$1({}, transforms, {\n\t        origin: [x, y]\n\t      }));\n\t      var start = this._isDeclarative && current ? current : startTransform;\n\n\t      if (affine) {\n\t        target = target.decompose(x, y);\n\t        start = start.decompose(x, y); // Get the current and target angle as it was set\n\n\t        var rTarget = target.rotate;\n\t        var rCurrent = start.rotate; // Figure out the shortest path to rotate directly\n\n\t        var possibilities = [rTarget - 360, rTarget, rTarget + 360];\n\t        var distances = possibilities.map(function (a) {\n\t          return Math.abs(a - rCurrent);\n\t        });\n\t        var shortest = Math.min.apply(Math, _toConsumableArray(distances));\n\t        var index = distances.indexOf(shortest);\n\t        target.rotate = possibilities[index];\n\t      }\n\n\t      if (relative) {\n\t        // we have to be careful here not to overwrite the rotation\n\t        // with the rotate method of Matrix\n\t        if (!isMatrix) {\n\t          target.rotate = transforms.rotate || 0;\n\t        }\n\n\t        if (this._isDeclarative && currentAngle) {\n\t          start.rotate = currentAngle;\n\t        }\n\t      }\n\n\t      morpher.from(start);\n\t      morpher.to(target);\n\t      var affineParameters = morpher.at(pos);\n\t      currentAngle = affineParameters.rotate;\n\t      current = new Matrix(affineParameters);\n\t      this.addTransform(current);\n\n\t      element._addRunner(this);\n\n\t      return morpher.done();\n\t    }\n\n\t    function retarget(newTransforms) {\n\t      // only get a new origin if it changed since the last call\n\t      if ((newTransforms.origin || 'center').toString() !== (transforms.origin || 'center').toString()) {\n\t        origin = getOrigin(transforms, element);\n\t      } // overwrite the old transformations with the new ones\n\n\n\t      transforms = _objectSpread$1({}, newTransforms, {\n\t        origin: origin\n\t      });\n\t    }\n\n\t    this.queue(setup, run, retarget, true);\n\t    this._isDeclarative && this._rememberMorpher('transform', morpher);\n\t    return this;\n\t  },\n\t  // Animatable x-axis\n\t  x: function x(_x, relative) {\n\t    return this._queueNumber('x', _x);\n\t  },\n\t  // Animatable y-axis\n\t  y: function y(_y) {\n\t    return this._queueNumber('y', _y);\n\t  },\n\t  dx: function dx() {\n\t    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t    return this._queueNumberDelta('x', x);\n\t  },\n\t  dy: function dy() {\n\t    var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t    return this._queueNumberDelta('y', y);\n\t  },\n\t  dmove: function dmove(x, y) {\n\t    return this.dx(x).dy(y);\n\t  },\n\t  _queueNumberDelta: function _queueNumberDelta(method, to) {\n\t    to = new SVGNumber(to); // Try to change the target if we have this method already registerd\n\n\t    if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation\n\n\t    var morpher = new Morphable(this._stepper).to(to);\n\t    var from = null;\n\t    this.queue(function () {\n\t      from = this.element()[method]();\n\t      morpher.from(from);\n\t      morpher.to(from + to);\n\t    }, function (pos) {\n\t      this.element()[method](morpher.at(pos));\n\t      return morpher.done();\n\t    }, function (newTo) {\n\t      morpher.to(from + new SVGNumber(newTo));\n\t    }); // Register the morpher so that if it is changed again, we can retarget it\n\n\t    this._rememberMorpher(method, morpher);\n\n\t    return this;\n\t  },\n\t  _queueObject: function _queueObject(method, to) {\n\t    // Try to change the target if we have this method already registerd\n\t    if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation\n\n\t    var morpher = new Morphable(this._stepper).to(to);\n\t    this.queue(function () {\n\t      morpher.from(this.element()[method]());\n\t    }, function (pos) {\n\t      this.element()[method](morpher.at(pos));\n\t      return morpher.done();\n\t    }); // Register the morpher so that if it is changed again, we can retarget it\n\n\t    this._rememberMorpher(method, morpher);\n\n\t    return this;\n\t  },\n\t  _queueNumber: function _queueNumber(method, value) {\n\t    return this._queueObject(method, new SVGNumber(value));\n\t  },\n\t  // Animatable center x-axis\n\t  cx: function cx(x) {\n\t    return this._queueNumber('cx', x);\n\t  },\n\t  // Animatable center y-axis\n\t  cy: function cy(y) {\n\t    return this._queueNumber('cy', y);\n\t  },\n\t  // Add animatable move\n\t  move: function move(x, y) {\n\t    return this.x(x).y(y);\n\t  },\n\t  // Add animatable center\n\t  center: function center(x, y) {\n\t    return this.cx(x).cy(y);\n\t  },\n\t  // Add animatable size\n\t  size: function size(width, height) {\n\t    // animate bbox based size for all other elements\n\t    var box;\n\n\t    if (!width || !height) {\n\t      box = this._element.bbox();\n\t    }\n\n\t    if (!width) {\n\t      width = box.width / box.height * height;\n\t    }\n\n\t    if (!height) {\n\t      height = box.height / box.width * width;\n\t    }\n\n\t    return this.width(width).height(height);\n\t  },\n\t  // Add animatable width\n\t  width: function width(_width) {\n\t    return this._queueNumber('width', _width);\n\t  },\n\t  // Add animatable height\n\t  height: function height(_height) {\n\t    return this._queueNumber('height', _height);\n\t  },\n\t  // Add animatable plot\n\t  plot: function plot(a, b, c, d) {\n\t    // Lines can be plotted with 4 arguments\n\t    if (arguments.length === 4) {\n\t      return this.plot([a, b, c, d]);\n\t    }\n\n\t    if (this._tryRetarget('plot', a)) return this;\n\t    var morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a);\n\t    this.queue(function () {\n\t      morpher.from(this._element.array());\n\t    }, function (pos) {\n\t      this._element.plot(morpher.at(pos));\n\n\t      return morpher.done();\n\t    });\n\n\t    this._rememberMorpher('plot', morpher);\n\n\t    return this;\n\t  },\n\t  // Add leading method\n\t  leading: function leading(value) {\n\t    return this._queueNumber('leading', value);\n\t  },\n\t  // Add animatable viewbox\n\t  viewbox: function viewbox(x, y, width, height) {\n\t    return this._queueObject('viewbox', new Box(x, y, width, height));\n\t  },\n\t  update: function update(o) {\n\t    if (_typeof(o) !== 'object') {\n\t      return this.update({\n\t        offset: arguments[0],\n\t        color: arguments[1],\n\t        opacity: arguments[2]\n\t      });\n\t    }\n\n\t    if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n\t    if (o.color != null) this.attr('stop-color', o.color);\n\t    if (o.offset != null) this.attr('offset', o.offset);\n\t    return this;\n\t  }\n\t});\n\textend(Runner, {\n\t  rx: rx,\n\t  ry: ry,\n\t  from: from,\n\t  to: to\n\t});\n\tregister(Runner, 'Runner');\n\n\tvar Svg =\n\t/*#__PURE__*/\n\tfunction (_Container) {\n\t  _inherits(Svg, _Container);\n\n\t  function Svg(node) {\n\t    var _this;\n\n\t    _classCallCheck(this, Svg);\n\n\t    _this = _possibleConstructorReturn(this, _getPrototypeOf(Svg).call(this, nodeOrNew('svg', node), node));\n\n\t    _this.namespace();\n\n\t    return _this;\n\t  }\n\n\t  _createClass(Svg, [{\n\t    key: \"isRoot\",\n\t    value: function isRoot() {\n\t      return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) || this.node.parentNode.nodeName === '#document';\n\t    } // Check if this is a root svg\n\t    // If not, call docs from this element\n\n\t  }, {\n\t    key: \"root\",\n\t    value: function root() {\n\t      if (this.isRoot()) return this;\n\t      return _get(_getPrototypeOf(Svg.prototype), \"root\", this).call(this);\n\t    } // Add namespaces\n\n\t  }, {\n\t    key: \"namespace\",\n\t    value: function namespace() {\n\t      if (!this.isRoot()) return this.root().namespace();\n\t      return this.attr({\n\t        xmlns: ns,\n\t        version: '1.1'\n\t      }).attr('xmlns:xlink', xlink, xmlns).attr('xmlns:svgjs', svgjs, xmlns);\n\t    } // Creates and returns defs element\n\n\t  }, {\n\t    key: \"defs\",\n\t    value: function defs() {\n\t      if (!this.isRoot()) return this.root().defs();\n\t      return adopt(this.node.querySelector('defs')) || this.put(new Defs());\n\t    } // custom parent method\n\n\t  }, {\n\t    key: \"parent\",\n\t    value: function parent(type) {\n\t      if (this.isRoot()) {\n\t        return this.node.parentNode.nodeName === '#document' ? null : adopt(this.node.parentNode);\n\t      }\n\n\t      return _get(_getPrototypeOf(Svg.prototype), \"parent\", this).call(this, type);\n\t    }\n\t  }, {\n\t    key: \"clear\",\n\t    value: function clear() {\n\t      // remove children\n\t      while (this.node.hasChildNodes()) {\n\t        this.node.removeChild(this.node.lastChild);\n\t      } // remove defs reference\n\n\n\t      delete this._defs;\n\t      return this;\n\t    }\n\t  }]);\n\n\t  return Svg;\n\t}(Container);\n\tregisterMethods({\n\t  Container: {\n\t    // Create nested svg document\n\t    nested: wrapWithAttrCheck(function () {\n\t      return this.put(new Svg());\n\t    })\n\t  }\n\t});\n\tregister(Svg, 'Svg', true);\n\n\tvar _Symbol =\n\t/*#__PURE__*/\n\tfunction (_Container) {\n\t  _inherits(_Symbol, _Container);\n\n\t  // Initialize node\n\t  function _Symbol(node) {\n\t    _classCallCheck(this, _Symbol);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(_Symbol).call(this, nodeOrNew('symbol', node), node));\n\t  }\n\n\t  return _Symbol;\n\t}(Container);\n\tregisterMethods({\n\t  Container: {\n\t    symbol: wrapWithAttrCheck(function () {\n\t      return this.put(new _Symbol());\n\t    })\n\t  }\n\t});\n\tregister(_Symbol, 'Symbol');\n\n\tfunction plain(text) {\n\t  // clear if build mode is disabled\n\t  if (this._build === false) {\n\t    this.clear();\n\t  } // create text node\n\n\n\t  this.node.appendChild(globals.document.createTextNode(text));\n\t  return this;\n\t} // Get length of text element\n\n\tfunction length() {\n\t  return this.node.getComputedTextLength();\n\t}\n\n\tvar textable = ({\n\t\t__proto__: null,\n\t\tplain: plain,\n\t\tlength: length\n\t});\n\n\tvar Text =\n\t/*#__PURE__*/\n\tfunction (_Shape) {\n\t  _inherits(Text, _Shape);\n\n\t  // Initialize node\n\t  function Text(node) {\n\t    var _this;\n\n\t    _classCallCheck(this, Text);\n\n\t    _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this, nodeOrNew('text', node), node));\n\t    _this.dom.leading = new SVGNumber(1.3); // store leading value for rebuilding\n\n\t    _this._rebuild = true; // enable automatic updating of dy values\n\n\t    _this._build = false; // disable build mode for adding multiple lines\n\n\t    return _this;\n\t  } // Move over x-axis\n\t  // Text is moved its bounding box\n\t  // text-anchor does NOT matter\n\n\n\t  _createClass(Text, [{\n\t    key: \"x\",\n\t    value: function x(_x) {\n\t      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n\n\t      if (_x == null) {\n\t        return box.x;\n\t      }\n\n\t      return this.attr('x', this.attr('x') + _x - box.x);\n\t    } // Move over y-axis\n\n\t  }, {\n\t    key: \"y\",\n\t    value: function y(_y) {\n\t      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n\n\t      if (_y == null) {\n\t        return box.y;\n\t      }\n\n\t      return this.attr('y', this.attr('y') + _y - box.y);\n\t    }\n\t  }, {\n\t    key: \"move\",\n\t    value: function move(x, y) {\n\t      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();\n\t      return this.x(x, box).y(y, box);\n\t    } // Move center over x-axis\n\n\t  }, {\n\t    key: \"cx\",\n\t    value: function cx(x) {\n\t      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n\n\t      if (x == null) {\n\t        return box.cx;\n\t      }\n\n\t      return this.attr('x', this.attr('x') + x - box.cx);\n\t    } // Move center over y-axis\n\n\t  }, {\n\t    key: \"cy\",\n\t    value: function cy(y) {\n\t      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n\n\t      if (y == null) {\n\t        return box.cy;\n\t      }\n\n\t      return this.attr('y', this.attr('y') + y - box.cy);\n\t    }\n\t  }, {\n\t    key: \"center\",\n\t    value: function center(x, y) {\n\t      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();\n\t      return this.cx(x, box).cy(y, box);\n\t    } // Set the text content\n\n\t  }, {\n\t    key: \"text\",\n\t    value: function text(_text) {\n\t      // act as getter\n\t      if (_text === undefined) {\n\t        var children = this.node.childNodes;\n\t        var firstLine = 0;\n\t        _text = '';\n\n\t        for (var i = 0, len = children.length; i < len; ++i) {\n\t          // skip textPaths - they are no lines\n\t          if (children[i].nodeName === 'textPath') {\n\t            if (i === 0) firstLine = 1;\n\t            continue;\n\t          } // add newline if its not the first child and newLined is set to true\n\n\n\t          if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) {\n\t            _text += '\\n';\n\t          } // add content of this node\n\n\n\t          _text += children[i].textContent;\n\t        }\n\n\t        return _text;\n\t      } // remove existing content\n\n\n\t      this.clear().build(true);\n\n\t      if (typeof _text === 'function') {\n\t        // call block\n\t        _text.call(this, this);\n\t      } else {\n\t        // store text and make sure text is not blank\n\t        _text = _text.split('\\n'); // build new lines\n\n\t        for (var j = 0, jl = _text.length; j < jl; j++) {\n\t          this.tspan(_text[j]).newLine();\n\t        }\n\t      } // disable build mode and rebuild lines\n\n\n\t      return this.build(false).rebuild();\n\t    } // Set / get leading\n\n\t  }, {\n\t    key: \"leading\",\n\t    value: function leading(value) {\n\t      // act as getter\n\t      if (value == null) {\n\t        return this.dom.leading;\n\t      } // act as setter\n\n\n\t      this.dom.leading = new SVGNumber(value);\n\t      return this.rebuild();\n\t    } // Rebuild appearance type\n\n\t  }, {\n\t    key: \"rebuild\",\n\t    value: function rebuild(_rebuild) {\n\t      // store new rebuild flag if given\n\t      if (typeof _rebuild === 'boolean') {\n\t        this._rebuild = _rebuild;\n\t      } // define position of all lines\n\n\n\t      if (this._rebuild) {\n\t        var self = this;\n\t        var blankLineOffset = 0;\n\t        var leading = this.dom.leading;\n\t        this.each(function () {\n\t          var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');\n\t          var dy = leading * new SVGNumber(fontSize);\n\n\t          if (this.dom.newLined) {\n\t            this.attr('x', self.attr('x'));\n\n\t            if (this.text() === '\\n') {\n\t              blankLineOffset += dy;\n\t            } else {\n\t              this.attr('dy', dy + blankLineOffset);\n\t              blankLineOffset = 0;\n\t            }\n\t          }\n\t        });\n\t        this.fire('rebuild');\n\t      }\n\n\t      return this;\n\t    } // Enable / disable build mode\n\n\t  }, {\n\t    key: \"build\",\n\t    value: function build(_build) {\n\t      this._build = !!_build;\n\t      return this;\n\t    } // overwrite method from parent to set data properly\n\n\t  }, {\n\t    key: \"setData\",\n\t    value: function setData(o) {\n\t      this.dom = o;\n\t      this.dom.leading = new SVGNumber(o.leading || 1.3);\n\t      return this;\n\t    }\n\t  }]);\n\n\t  return Text;\n\t}(Shape);\n\textend(Text, textable);\n\tregisterMethods({\n\t  Container: {\n\t    // Create text element\n\t    text: wrapWithAttrCheck(function (text) {\n\t      return this.put(new Text()).text(text);\n\t    }),\n\t    // Create plain text element\n\t    plain: wrapWithAttrCheck(function (text) {\n\t      return this.put(new Text()).plain(text);\n\t    })\n\t  }\n\t});\n\tregister(Text, 'Text');\n\n\tvar Tspan =\n\t/*#__PURE__*/\n\tfunction (_Text) {\n\t  _inherits(Tspan, _Text);\n\n\t  // Initialize node\n\t  function Tspan(node) {\n\t    _classCallCheck(this, Tspan);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Tspan).call(this, nodeOrNew('tspan', node), node));\n\t  } // Set text content\n\n\n\t  _createClass(Tspan, [{\n\t    key: \"text\",\n\t    value: function text(_text) {\n\t      if (_text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '');\n\t      typeof _text === 'function' ? _text.call(this, this) : this.plain(_text);\n\t      return this;\n\t    } // Shortcut dx\n\n\t  }, {\n\t    key: \"dx\",\n\t    value: function dx(_dx) {\n\t      return this.attr('dx', _dx);\n\t    } // Shortcut dy\n\n\t  }, {\n\t    key: \"dy\",\n\t    value: function dy(_dy) {\n\t      return this.attr('dy', _dy);\n\t    }\n\t  }, {\n\t    key: \"x\",\n\t    value: function x(_x) {\n\t      return this.attr('x', _x);\n\t    }\n\t  }, {\n\t    key: \"y\",\n\t    value: function y(_y) {\n\t      return this.attr('x', _y);\n\t    }\n\t  }, {\n\t    key: \"move\",\n\t    value: function move(x, y) {\n\t      return this.x(x).y(y);\n\t    } // Create new line\n\n\t  }, {\n\t    key: \"newLine\",\n\t    value: function newLine() {\n\t      // fetch text parent\n\t      var t = this.parent(Text); // mark new line\n\n\t      this.dom.newLined = true;\n\t      var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');\n\t      var dy = t.dom.leading * new SVGNumber(fontSize); // apply new position\n\n\t      return this.dy(dy).attr('x', t.x());\n\t    }\n\t  }]);\n\n\t  return Tspan;\n\t}(Text);\n\textend(Tspan, textable);\n\tregisterMethods({\n\t  Tspan: {\n\t    tspan: wrapWithAttrCheck(function (text) {\n\t      var tspan = new Tspan(); // clear if build mode is disabled\n\n\t      if (!this._build) {\n\t        this.clear();\n\t      } // add new tspan\n\n\n\t      this.node.appendChild(tspan.node);\n\t      return tspan.text(text);\n\t    })\n\t  }\n\t});\n\tregister(Tspan, 'Tspan');\n\n\tvar ClipPath =\n\t/*#__PURE__*/\n\tfunction (_Container) {\n\t  _inherits(ClipPath, _Container);\n\n\t  function ClipPath(node) {\n\t    _classCallCheck(this, ClipPath);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(ClipPath).call(this, nodeOrNew('clipPath', node), node));\n\t  } // Unclip all clipped elements and remove itself\n\n\n\t  _createClass(ClipPath, [{\n\t    key: \"remove\",\n\t    value: function remove() {\n\t      // unclip all targets\n\t      this.targets().forEach(function (el) {\n\t        el.unclip();\n\t      }); // remove clipPath from parent\n\n\t      return _get(_getPrototypeOf(ClipPath.prototype), \"remove\", this).call(this);\n\t    }\n\t  }, {\n\t    key: \"targets\",\n\t    value: function targets() {\n\t      return baseFind('svg [clip-path*=\"' + this.id() + '\"]');\n\t    }\n\t  }]);\n\n\t  return ClipPath;\n\t}(Container);\n\tregisterMethods({\n\t  Container: {\n\t    // Create clipping element\n\t    clip: wrapWithAttrCheck(function () {\n\t      return this.defs().put(new ClipPath());\n\t    })\n\t  },\n\t  Element: {\n\t    // Distribute clipPath to svg element\n\t    clipWith: function clipWith(element) {\n\t      // use given clip or create a new one\n\t      var clipper = element instanceof ClipPath ? element : this.parent().clip().add(element); // apply mask\n\n\t      return this.attr('clip-path', 'url(\"#' + clipper.id() + '\")');\n\t    },\n\t    // Unclip element\n\t    unclip: function unclip() {\n\t      return this.attr('clip-path', null);\n\t    },\n\t    clipper: function clipper() {\n\t      return this.reference('clip-path');\n\t    }\n\t  }\n\t});\n\tregister(ClipPath, 'ClipPath');\n\n\tvar ForeignObject =\n\t/*#__PURE__*/\n\tfunction (_Element) {\n\t  _inherits(ForeignObject, _Element);\n\n\t  function ForeignObject(node) {\n\t    _classCallCheck(this, ForeignObject);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(ForeignObject).call(this, nodeOrNew('foreignObject', node), node));\n\t  }\n\n\t  return ForeignObject;\n\t}(Element);\n\tregisterMethods({\n\t  Container: {\n\t    foreignObject: wrapWithAttrCheck(function (width, height) {\n\t      return this.put(new ForeignObject()).size(width, height);\n\t    })\n\t  }\n\t});\n\tregister(ForeignObject, 'ForeignObject');\n\n\tvar G =\n\t/*#__PURE__*/\n\tfunction (_Container) {\n\t  _inherits(G, _Container);\n\n\t  function G(node) {\n\t    _classCallCheck(this, G);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(G).call(this, nodeOrNew('g', node), node));\n\t  }\n\n\t  _createClass(G, [{\n\t    key: \"x\",\n\t    value: function x(_x) {\n\t      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n\t      if (_x == null) return box.x;\n\t      return this.move(_x, box.y, box);\n\t    }\n\t  }, {\n\t    key: \"y\",\n\t    value: function y(_y) {\n\t      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n\t      if (_y == null) return box.y;\n\t      return this.move(box.x, _y, box);\n\t    }\n\t  }, {\n\t    key: \"move\",\n\t    value: function move() {\n\t      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();\n\t      var dx = x - box.x;\n\t      var dy = y - box.y;\n\t      return this.dmove(dx, dy);\n\t    }\n\t  }, {\n\t    key: \"dx\",\n\t    value: function dx(_dx) {\n\t      return this.dmove(_dx, 0);\n\t    }\n\t  }, {\n\t    key: \"dy\",\n\t    value: function dy(_dy) {\n\t      return this.dmove(0, _dy);\n\t    }\n\t  }, {\n\t    key: \"dmove\",\n\t    value: function dmove(dx, dy) {\n\t      this.children().forEach(function (child, i) {\n\t        // Get the childs bbox\n\t        var bbox = child.bbox(); // Get childs matrix\n\n\t        var m = new Matrix(child); // Translate childs matrix by amount and\n\t        // transform it back into parents space\n\n\t        var matrix = m.translate(dx, dy).transform(m.inverse()); // Calculate new x and y from old box\n\n\t        var p = new Point(bbox.x, bbox.y).transform(matrix); // Move element\n\n\t        child.move(p.x, p.y);\n\t      });\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"width\",\n\t    value: function width(_width) {\n\t      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n\t      if (_width == null) return box.width;\n\t      return this.size(_width, box.height, box);\n\t    }\n\t  }, {\n\t    key: \"height\",\n\t    value: function height(_height) {\n\t      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();\n\t      if (_height == null) return box.height;\n\t      return this.size(box.width, _height, box);\n\t    }\n\t  }, {\n\t    key: \"size\",\n\t    value: function size(width, height) {\n\t      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();\n\t      var p = proportionalSize(this, width, height, box);\n\t      var scaleX = p.width / box.width;\n\t      var scaleY = p.height / box.height;\n\t      this.children().forEach(function (child, i) {\n\t        var o = new Point(box).transform(new Matrix(child).inverse());\n\t        child.scale(scaleX, scaleY, o.x, o.y);\n\t      });\n\t      return this;\n\t    }\n\t  }]);\n\n\t  return G;\n\t}(Container);\n\tregisterMethods({\n\t  Container: {\n\t    // Create a group element\n\t    group: wrapWithAttrCheck(function () {\n\t      return this.put(new G());\n\t    })\n\t  }\n\t});\n\tregister(G, 'G');\n\n\tvar A =\n\t/*#__PURE__*/\n\tfunction (_Container) {\n\t  _inherits(A, _Container);\n\n\t  function A(node) {\n\t    _classCallCheck(this, A);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(A).call(this, nodeOrNew('a', node), node));\n\t  } // Link url\n\n\n\t  _createClass(A, [{\n\t    key: \"to\",\n\t    value: function to(url) {\n\t      return this.attr('href', url, xlink);\n\t    } // Link target attribute\n\n\t  }, {\n\t    key: \"target\",\n\t    value: function target(_target) {\n\t      return this.attr('target', _target);\n\t    }\n\t  }]);\n\n\t  return A;\n\t}(Container);\n\tregisterMethods({\n\t  Container: {\n\t    // Create a hyperlink element\n\t    link: wrapWithAttrCheck(function (url) {\n\t      return this.put(new A()).to(url);\n\t    })\n\t  },\n\t  Element: {\n\t    // Create a hyperlink element\n\t    linkTo: function linkTo(url) {\n\t      var link = new A();\n\n\t      if (typeof url === 'function') {\n\t        url.call(link, link);\n\t      } else {\n\t        link.to(url);\n\t      }\n\n\t      return this.parent().put(link).put(this);\n\t    }\n\t  }\n\t});\n\tregister(A, 'A');\n\n\tvar Mask =\n\t/*#__PURE__*/\n\tfunction (_Container) {\n\t  _inherits(Mask, _Container);\n\n\t  // Initialize node\n\t  function Mask(node) {\n\t    _classCallCheck(this, Mask);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Mask).call(this, nodeOrNew('mask', node), node));\n\t  } // Unmask all masked elements and remove itself\n\n\n\t  _createClass(Mask, [{\n\t    key: \"remove\",\n\t    value: function remove() {\n\t      // unmask all targets\n\t      this.targets().forEach(function (el) {\n\t        el.unmask();\n\t      }); // remove mask from parent\n\n\t      return _get(_getPrototypeOf(Mask.prototype), \"remove\", this).call(this);\n\t    }\n\t  }, {\n\t    key: \"targets\",\n\t    value: function targets() {\n\t      return baseFind('svg [mask*=\"' + this.id() + '\"]');\n\t    }\n\t  }]);\n\n\t  return Mask;\n\t}(Container);\n\tregisterMethods({\n\t  Container: {\n\t    mask: wrapWithAttrCheck(function () {\n\t      return this.defs().put(new Mask());\n\t    })\n\t  },\n\t  Element: {\n\t    // Distribute mask to svg element\n\t    maskWith: function maskWith(element) {\n\t      // use given mask or create a new one\n\t      var masker = element instanceof Mask ? element : this.parent().mask().add(element); // apply mask\n\n\t      return this.attr('mask', 'url(\"#' + masker.id() + '\")');\n\t    },\n\t    // Unmask element\n\t    unmask: function unmask() {\n\t      return this.attr('mask', null);\n\t    },\n\t    masker: function masker() {\n\t      return this.reference('mask');\n\t    }\n\t  }\n\t});\n\tregister(Mask, 'Mask');\n\n\tfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\n\tfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\tfunction cssRule(selector, rule) {\n\t  if (!selector) return '';\n\t  if (!rule) return selector;\n\t  var ret = selector + '{';\n\n\t  for (var i in rule) {\n\t    ret += unCamelCase(i) + ':' + rule[i] + ';';\n\t  }\n\n\t  ret += '}';\n\t  return ret;\n\t}\n\n\tvar Style =\n\t/*#__PURE__*/\n\tfunction (_Element) {\n\t  _inherits(Style, _Element);\n\n\t  function Style(node) {\n\t    _classCallCheck(this, Style);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Style).call(this, nodeOrNew('style', node), node));\n\t  }\n\n\t  _createClass(Style, [{\n\t    key: \"addText\",\n\t    value: function addText() {\n\t      var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t      this.node.textContent += w;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: \"font\",\n\t    value: function font(name, src) {\n\t      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t      return this.rule('@font-face', _objectSpread$2({\n\t        fontFamily: name,\n\t        src: src\n\t      }, params));\n\t    }\n\t  }, {\n\t    key: \"rule\",\n\t    value: function rule(selector, obj) {\n\t      return this.addText(cssRule(selector, obj));\n\t    }\n\t  }]);\n\n\t  return Style;\n\t}(Element);\n\tregisterMethods('Dom', {\n\t  style: wrapWithAttrCheck(function (selector, obj) {\n\t    return this.put(new Style()).rule(selector, obj);\n\t  }),\n\t  fontface: wrapWithAttrCheck(function (name, src, params) {\n\t    return this.put(new Style()).font(name, src, params);\n\t  })\n\t});\n\tregister(Style, 'Style');\n\n\tvar TextPath =\n\t/*#__PURE__*/\n\tfunction (_Text) {\n\t  _inherits(TextPath, _Text);\n\n\t  // Initialize node\n\t  function TextPath(node) {\n\t    _classCallCheck(this, TextPath);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(TextPath).call(this, nodeOrNew('textPath', node), node));\n\t  } // return the array of the path track element\n\n\n\t  _createClass(TextPath, [{\n\t    key: \"array\",\n\t    value: function array() {\n\t      var track = this.track();\n\t      return track ? track.array() : null;\n\t    } // Plot path if any\n\n\t  }, {\n\t    key: \"plot\",\n\t    value: function plot(d) {\n\t      var track = this.track();\n\t      var pathArray = null;\n\n\t      if (track) {\n\t        pathArray = track.plot(d);\n\t      }\n\n\t      return d == null ? pathArray : this;\n\t    } // Get the path element\n\n\t  }, {\n\t    key: \"track\",\n\t    value: function track() {\n\t      return this.reference('href');\n\t    }\n\t  }]);\n\n\t  return TextPath;\n\t}(Text);\n\tregisterMethods({\n\t  Container: {\n\t    textPath: wrapWithAttrCheck(function (text, path) {\n\t      // Convert text to instance if needed\n\t      if (!(text instanceof Text)) {\n\t        text = this.text(text);\n\t      }\n\n\t      return text.path(path);\n\t    })\n\t  },\n\t  Text: {\n\t    // Create path for text to run on\n\t    path: wrapWithAttrCheck(function (track) {\n\t      var importNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var textPath = new TextPath(); // if track is a path, reuse it\n\n\t      if (!(track instanceof Path)) {\n\t        // create path element\n\t        track = this.defs().path(track);\n\t      } // link textPath to path and add content\n\n\n\t      textPath.attr('href', '#' + track, xlink); // Transplant all nodes from text to textPath\n\n\t      var node;\n\n\t      if (importNodes) {\n\t        while (node = this.node.firstChild) {\n\t          textPath.node.appendChild(node);\n\t        }\n\t      } // add textPath element as child node and return textPath\n\n\n\t      return this.put(textPath);\n\t    }),\n\t    // Get the textPath children\n\t    textPath: function textPath() {\n\t      return this.findOne('textPath');\n\t    }\n\t  },\n\t  Path: {\n\t    // creates a textPath from this path\n\t    text: wrapWithAttrCheck(function (text) {\n\t      // Convert text to instance if needed\n\t      if (!(text instanceof Text)) {\n\t        text = new Text().addTo(this.parent()).text(text);\n\t      } // Create textPath from text and path and return\n\n\n\t      return text.path(this);\n\t    }),\n\t    targets: function targets() {\n\t      return baseFind('svg [href*=\"' + this.id() + '\"]');\n\t    }\n\t  }\n\t});\n\tTextPath.prototype.MorphArray = PathArray;\n\tregister(TextPath, 'TextPath');\n\n\tvar Use =\n\t/*#__PURE__*/\n\tfunction (_Shape) {\n\t  _inherits(Use, _Shape);\n\n\t  function Use(node) {\n\t    _classCallCheck(this, Use);\n\n\t    return _possibleConstructorReturn(this, _getPrototypeOf(Use).call(this, nodeOrNew('use', node), node));\n\t  } // Use element as a reference\n\n\n\t  _createClass(Use, [{\n\t    key: \"element\",\n\t    value: function element(_element, file) {\n\t      // Set lined element\n\t      return this.attr('href', (file || '') + '#' + _element, xlink);\n\t    }\n\t  }]);\n\n\t  return Use;\n\t}(Shape);\n\tregisterMethods({\n\t  Container: {\n\t    // Create a use element\n\t    use: wrapWithAttrCheck(function (element, file) {\n\t      return this.put(new Use()).element(element, file);\n\t    })\n\t  }\n\t});\n\tregister(Use, 'Use');\n\n\t/* Optional Modules */\n\tvar SVG = makeInstance;\n\textend([Svg, _Symbol, Image, Pattern, Marker], getMethodsFor('viewbox'));\n\textend([Line, Polyline, Polygon, Path], getMethodsFor('marker'));\n\textend(Text, getMethodsFor('Text'));\n\textend(Path, getMethodsFor('Path'));\n\textend(Defs, getMethodsFor('Defs'));\n\textend([Text, Tspan], getMethodsFor('Tspan'));\n\textend([Rect, Ellipse, Circle, Gradient], getMethodsFor('radius'));\n\textend(EventTarget, getMethodsFor('EventTarget'));\n\textend(Dom, getMethodsFor('Dom'));\n\textend(Element, getMethodsFor('Element'));\n\textend(Shape, getMethodsFor('Shape')); // extend(Element, getConstructor('Memory'))\n\n\textend(Container, getMethodsFor('Container'));\n\textend(Runner, getMethodsFor('Runner'));\n\tList.extend(getMethodNames());\n\tregisterMorphableType([SVGNumber, Color, Box, Matrix, SVGArray, PointArray, PathArray]);\n\tmakeMorphable();\n\n\tvar svgMembers = ({\n\t\t__proto__: null,\n\t\tMorphable: Morphable,\n\t\tregisterMorphableType: registerMorphableType,\n\t\tmakeMorphable: makeMorphable,\n\t\tTransformBag: TransformBag,\n\t\tObjectBag: ObjectBag,\n\t\tNonMorphable: NonMorphable,\n\t\tdefaults: defaults,\n\t\tutils: utils,\n\t\tnamespaces: namespaces,\n\t\tregex: regex,\n\t\tSVG: SVG,\n\t\tparser: parser,\n\t\tfind: baseFind,\n\t\tregisterWindow: registerWindow,\n\t\tAnimator: Animator,\n\t\tController: Controller,\n\t\tEase: Ease,\n\t\tPID: PID,\n\t\tSpring: Spring,\n\t\teasing: easing,\n\t\tQueue: Queue,\n\t\tRunner: Runner,\n\t\tTimeline: Timeline,\n\t\tArray: SVGArray,\n\t\tBox: Box,\n\t\tColor: Color,\n\t\tEventTarget: EventTarget,\n\t\tMatrix: Matrix,\n\t\tNumber: SVGNumber,\n\t\tPathArray: PathArray,\n\t\tPoint: Point,\n\t\tPointArray: PointArray,\n\t\tList: List,\n\t\tCircle: Circle,\n\t\tClipPath: ClipPath,\n\t\tContainer: Container,\n\t\tDefs: Defs,\n\t\tDom: Dom,\n\t\tElement: Element,\n\t\tEllipse: Ellipse,\n\t\tForeignObject: ForeignObject,\n\t\tGradient: Gradient,\n\t\tG: G,\n\t\tA: A,\n\t\tImage: Image,\n\t\tLine: Line,\n\t\tMarker: Marker,\n\t\tMask: Mask,\n\t\tPath: Path,\n\t\tPattern: Pattern,\n\t\tPolygon: Polygon,\n\t\tPolyline: Polyline,\n\t\tRect: Rect,\n\t\tShape: Shape,\n\t\tStop: Stop,\n\t\tStyle: Style,\n\t\tSvg: Svg,\n\t\tSymbol: _Symbol,\n\t\tText: Text,\n\t\tTextPath: TextPath,\n\t\tTspan: Tspan,\n\t\tUse: Use,\n\t\ton: on,\n\t\toff: off,\n\t\tdispatch: dispatch,\n\t\troot: root,\n\t\tcreate: create,\n\t\tmakeInstance: makeInstance,\n\t\tnodeOrNew: nodeOrNew,\n\t\tadopt: adopt,\n\t\tmockAdopt: mockAdopt,\n\t\tregister: register,\n\t\tgetClass: getClass,\n\t\teid: eid,\n\t\tassignNewId: assignNewId,\n\t\textend: extend,\n\t\twrapWithAttrCheck: wrapWithAttrCheck,\n\t\tinvent: invent\n\t});\n\n\tfunction SVG$1(element) {\n\t  return makeInstance(element);\n\t}\n\tObject.assign(SVG$1, svgMembers);\n\n\treturn SVG$1;\n\n}());\n//# sourceMappingURL=svg.js.map\n\nexport default SVG.SVG;\n","/* js-yaml 3.14.0 https://github.com/nodeca/js-yaml */\n\nexport default (function (f) { if (typeof exports === \"object\" && typeof module !== \"undefined\") { module.exports = f() } else if (typeof define === \"function\" && define.amd) { define([], f) } else { var g; if (typeof window !== \"undefined\") { g = window } else if (typeof global !== \"undefined\") { g = global } else if (typeof self !== \"undefined\") { g = self } else { g = this } g.jsyaml = f() } })(function () {\n   return (function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = \"function\" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error(\"Cannot find module '\" + i + \"'\"); throw a.code = \"MODULE_NOT_FOUND\", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({\n    1: [function (require, module, exports) {\n      'use strict';\n\n\n      var loader = require('./js-yaml/loader');\n      var dumper = require('./js-yaml/dumper');\n\n\n      function deprecated(name) {\n        return function () {\n          throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n        };\n      }\n\n\n      module.exports.Type = require('./js-yaml/type');\n      module.exports.Schema = require('./js-yaml/schema');\n      module.exports.FAILSAFE_SCHEMA = require('./js-yaml/schema/failsafe');\n      module.exports.JSON_SCHEMA = require('./js-yaml/schema/json');\n      module.exports.CORE_SCHEMA = require('./js-yaml/schema/core');\n      module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n      module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\n      module.exports.load = loader.load;\n      module.exports.loadAll = loader.loadAll;\n      module.exports.safeLoad = loader.safeLoad;\n      module.exports.safeLoadAll = loader.safeLoadAll;\n      module.exports.dump = dumper.dump;\n      module.exports.safeDump = dumper.safeDump;\n      module.exports.YAMLException = require('./js-yaml/exception');\n\n      // Deprecated schema names from JS-YAML 2.0.x\n      module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\n      module.exports.SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n      module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n\n      // Deprecated functions from JS-YAML 1.x.x\n      module.exports.scan = deprecated('scan');\n      module.exports.parse = deprecated('parse');\n      module.exports.compose = deprecated('compose');\n      module.exports.addConstructor = deprecated('addConstructor');\n\n    }, { \"./js-yaml/dumper\": 3, \"./js-yaml/exception\": 4, \"./js-yaml/loader\": 5, \"./js-yaml/schema\": 7, \"./js-yaml/schema/core\": 8, \"./js-yaml/schema/default_full\": 9, \"./js-yaml/schema/default_safe\": 10, \"./js-yaml/schema/failsafe\": 11, \"./js-yaml/schema/json\": 12, \"./js-yaml/type\": 13 }], 2: [function (require, module, exports) {\n      'use strict';\n\n\n      function isNothing(subject) {\n        return (typeof subject === 'undefined') || (subject === null);\n      }\n\n\n      function isObject(subject) {\n        return (typeof subject === 'object') && (subject !== null);\n      }\n\n\n      function toArray(sequence) {\n        if (Array.isArray(sequence)) return sequence;\n        else if (isNothing(sequence)) return [];\n\n        return [sequence];\n      }\n\n\n      function extend(target, source) {\n        var index, length, key, sourceKeys;\n\n        if (source) {\n          sourceKeys = Object.keys(source);\n\n          for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n            key = sourceKeys[index];\n            target[key] = source[key];\n          }\n        }\n\n        return target;\n      }\n\n\n      function repeat(string, count) {\n        var result = '', cycle;\n\n        for (cycle = 0; cycle < count; cycle += 1) {\n          result += string;\n        }\n\n        return result;\n      }\n\n\n      function isNegativeZero(number) {\n        return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n      }\n\n\n      module.exports.isNothing = isNothing;\n      module.exports.isObject = isObject;\n      module.exports.toArray = toArray;\n      module.exports.repeat = repeat;\n      module.exports.isNegativeZero = isNegativeZero;\n      module.exports.extend = extend;\n\n    }, {}], 3: [function (require, module, exports) {\n      'use strict';\n\n      /*eslint-disable no-use-before-define*/\n\n      var common = require('./common');\n      var YAMLException = require('./exception');\n      var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n      var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\n      var _toString = Object.prototype.toString;\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n      var CHAR_TAB = 0x09; /* Tab */\n      var CHAR_LINE_FEED = 0x0A; /* LF */\n      var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */\n      var CHAR_SPACE = 0x20; /* Space */\n      var CHAR_EXCLAMATION = 0x21; /* ! */\n      var CHAR_DOUBLE_QUOTE = 0x22; /* \" */\n      var CHAR_SHARP = 0x23; /* # */\n      var CHAR_PERCENT = 0x25; /* % */\n      var CHAR_AMPERSAND = 0x26; /* & */\n      var CHAR_SINGLE_QUOTE = 0x27; /* ' */\n      var CHAR_ASTERISK = 0x2A; /* * */\n      var CHAR_COMMA = 0x2C; /* , */\n      var CHAR_MINUS = 0x2D; /* - */\n      var CHAR_COLON = 0x3A; /* : */\n      var CHAR_EQUALS = 0x3D; /* = */\n      var CHAR_GREATER_THAN = 0x3E; /* > */\n      var CHAR_QUESTION = 0x3F; /* ? */\n      var CHAR_COMMERCIAL_AT = 0x40; /* @ */\n      var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */\n      var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\n      var CHAR_GRAVE_ACCENT = 0x60; /* ` */\n      var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */\n      var CHAR_VERTICAL_LINE = 0x7C; /* | */\n      var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */\n\n      var ESCAPE_SEQUENCES = {};\n\n      ESCAPE_SEQUENCES[0x00] = '\\\\0';\n      ESCAPE_SEQUENCES[0x07] = '\\\\a';\n      ESCAPE_SEQUENCES[0x08] = '\\\\b';\n      ESCAPE_SEQUENCES[0x09] = '\\\\t';\n      ESCAPE_SEQUENCES[0x0A] = '\\\\n';\n      ESCAPE_SEQUENCES[0x0B] = '\\\\v';\n      ESCAPE_SEQUENCES[0x0C] = '\\\\f';\n      ESCAPE_SEQUENCES[0x0D] = '\\\\r';\n      ESCAPE_SEQUENCES[0x1B] = '\\\\e';\n      ESCAPE_SEQUENCES[0x22] = '\\\\\"';\n      ESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\n      ESCAPE_SEQUENCES[0x85] = '\\\\N';\n      ESCAPE_SEQUENCES[0xA0] = '\\\\_';\n      ESCAPE_SEQUENCES[0x2028] = '\\\\L';\n      ESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\n      var DEPRECATED_BOOLEANS_SYNTAX = [\n        'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n        'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n      ];\n\n      function compileStyleMap(schema, map) {\n        var result, keys, index, length, tag, style, type;\n\n        if (map === null) return {};\n\n        result = {};\n        keys = Object.keys(map);\n\n        for (index = 0, length = keys.length; index < length; index += 1) {\n          tag = keys[index];\n          style = String(map[tag]);\n\n          if (tag.slice(0, 2) === '!!') {\n            tag = 'tag:yaml.org,2002:' + tag.slice(2);\n          }\n          type = schema.compiledTypeMap['fallback'][tag];\n\n          if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n            style = type.styleAliases[style];\n          }\n\n          result[tag] = style;\n        }\n\n        return result;\n      }\n\n      function encodeHex(character) {\n        var string, handle, length;\n\n        string = character.toString(16).toUpperCase();\n\n        if (character <= 0xFF) {\n          handle = 'x';\n          length = 2;\n        } else if (character <= 0xFFFF) {\n          handle = 'u';\n          length = 4;\n        } else if (character <= 0xFFFFFFFF) {\n          handle = 'U';\n          length = 8;\n        } else {\n          throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n        }\n\n        return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n      }\n\n      function State(options) {\n        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n        this.indent = Math.max(1, (options['indent'] || 2));\n        this.noArrayIndent = options['noArrayIndent'] || false;\n        this.skipInvalid = options['skipInvalid'] || false;\n        this.flowLevel = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n        this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n        this.sortKeys = options['sortKeys'] || false;\n        this.lineWidth = options['lineWidth'] || 80;\n        this.noRefs = options['noRefs'] || false;\n        this.noCompatMode = options['noCompatMode'] || false;\n        this.condenseFlow = options['condenseFlow'] || false;\n\n        this.implicitTypes = this.schema.compiledImplicit;\n        this.explicitTypes = this.schema.compiledExplicit;\n\n        this.tag = null;\n        this.result = '';\n\n        this.duplicates = [];\n        this.usedDuplicates = null;\n      }\n\n      // Indents every line in a string. Empty lines (\\n only) are not indented.\n      function indentString(string, spaces) {\n        var ind = common.repeat(' ', spaces),\n          position = 0,\n          next = -1,\n          result = '',\n          line,\n          length = string.length;\n\n        while (position < length) {\n          next = string.indexOf('\\n', position);\n          if (next === -1) {\n            line = string.slice(position);\n            position = length;\n          } else {\n            line = string.slice(position, next + 1);\n            position = next + 1;\n          }\n\n          if (line.length && line !== '\\n') result += ind;\n\n          result += line;\n        }\n\n        return result;\n      }\n\n      function generateNextLine(state, level) {\n        return '\\n' + common.repeat(' ', state.indent * level);\n      }\n\n      function testImplicitResolving(state, str) {\n        var index, length, type;\n\n        for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n          type = state.implicitTypes[index];\n\n          if (type.resolve(str)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      // [33] s-white ::= s-space | s-tab\n      function isWhitespace(c) {\n        return c === CHAR_SPACE || c === CHAR_TAB;\n      }\n\n      // Returns true if the character can be printed without escaping.\n      // From YAML 1.2: \"any allowed characters known to be non-printable\n      // should also be escaped. [However,] This isnt mandatory\"\n      // Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n      function isPrintable(c) {\n        return (0x00020 <= c && c <= 0x00007E)\n          || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n          || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)\n          || (0x10000 <= c && c <= 0x10FFFF);\n      }\n\n      // [34] ns-char ::= nb-char - s-white\n      // [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n      // [26] b-char  ::= b-line-feed | b-carriage-return\n      // [24] b-line-feed       ::=     #xA    /* LF */\n      // [25] b-carriage-return ::=     #xD    /* CR */\n      // [3]  c-byte-order-mark ::=     #xFEFF\n      function isNsChar(c) {\n        return isPrintable(c) && !isWhitespace(c)\n          // byte-order-mark\n          && c !== 0xFEFF\n          // b-char\n          && c !== CHAR_CARRIAGE_RETURN\n          && c !== CHAR_LINE_FEED;\n      }\n\n      // Simplified test for values allowed after the first character in plain style.\n      function isPlainSafe(c, prev) {\n        // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n        // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n        return isPrintable(c) && c !== 0xFEFF\n          // - c-flow-indicator\n          && c !== CHAR_COMMA\n          && c !== CHAR_LEFT_SQUARE_BRACKET\n          && c !== CHAR_RIGHT_SQUARE_BRACKET\n          && c !== CHAR_LEFT_CURLY_BRACKET\n          && c !== CHAR_RIGHT_CURLY_BRACKET\n          // - \":\" - \"#\"\n          // /* An ns-char preceding */ \"#\"\n          && c !== CHAR_COLON\n          && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));\n      }\n\n      // Simplified test for values allowed as the first character in plain style.\n      function isPlainSafeFirst(c) {\n        // Uses a subset of ns-char - c-indicator\n        // where ns-char = nb-char - s-white.\n        return isPrintable(c) && c !== 0xFEFF\n          && !isWhitespace(c) // - s-white\n          // - (c-indicator ::=\n          // - | ? | : | , | [ | ] | { | }\n          && c !== CHAR_MINUS\n          && c !== CHAR_QUESTION\n          && c !== CHAR_COLON\n          && c !== CHAR_COMMA\n          && c !== CHAR_LEFT_SQUARE_BRACKET\n          && c !== CHAR_RIGHT_SQUARE_BRACKET\n          && c !== CHAR_LEFT_CURLY_BRACKET\n          && c !== CHAR_RIGHT_CURLY_BRACKET\n          // | # | & | * | ! | | | = | > | ' | \"\n          && c !== CHAR_SHARP\n          && c !== CHAR_AMPERSAND\n          && c !== CHAR_ASTERISK\n          && c !== CHAR_EXCLAMATION\n          && c !== CHAR_VERTICAL_LINE\n          && c !== CHAR_EQUALS\n          && c !== CHAR_GREATER_THAN\n          && c !== CHAR_SINGLE_QUOTE\n          && c !== CHAR_DOUBLE_QUOTE\n          // | % | @ | `)\n          && c !== CHAR_PERCENT\n          && c !== CHAR_COMMERCIAL_AT\n          && c !== CHAR_GRAVE_ACCENT;\n      }\n\n      // Determines whether block indentation indicator is required.\n      function needIndentIndicator(string) {\n        var leadingSpaceRe = /^\\n* /;\n        return leadingSpaceRe.test(string);\n      }\n\n      var STYLE_PLAIN = 1,\n        STYLE_SINGLE = 2,\n        STYLE_LITERAL = 3,\n        STYLE_FOLDED = 4,\n        STYLE_DOUBLE = 5;\n\n      // Determines which scalar styles are possible and returns the preferred style.\n      // lineWidth = -1 => no limit.\n      // Pre-conditions: str.length > 0.\n      // Post-conditions:\n      //    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n      //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n      //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n      function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n        var i;\n        var char, prev_char;\n        var hasLineBreak = false;\n        var hasFoldableLine = false; // only checked if shouldTrackWidth\n        var shouldTrackWidth = lineWidth !== -1;\n        var previousLineBreak = -1; // count the first line correctly\n        var plain = isPlainSafeFirst(string.charCodeAt(0))\n          && !isWhitespace(string.charCodeAt(string.length - 1));\n\n        if (singleLineOnly) {\n          // Case: no block styles.\n          // Check for disallowed characters to rule out plain and single.\n          for (i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n            if (!isPrintable(char)) {\n              return STYLE_DOUBLE;\n            }\n            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n            plain = plain && isPlainSafe(char, prev_char);\n          }\n        } else {\n          // Case: block styles permitted.\n          for (i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n            if (char === CHAR_LINE_FEED) {\n              hasLineBreak = true;\n              // Check if any line can be folded.\n              if (shouldTrackWidth) {\n                hasFoldableLine = hasFoldableLine ||\n                  // Foldable line = too long, and not more-indented.\n                  (i - previousLineBreak - 1 > lineWidth &&\n                    string[previousLineBreak + 1] !== ' ');\n                previousLineBreak = i;\n              }\n            } else if (!isPrintable(char)) {\n              return STYLE_DOUBLE;\n            }\n            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n            plain = plain && isPlainSafe(char, prev_char);\n          }\n          // in case the end is missing a \\n\n          hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n            (i - previousLineBreak - 1 > lineWidth &&\n              string[previousLineBreak + 1] !== ' '));\n        }\n        // Although every style can represent \\n without escaping, prefer block styles\n        // for multiline, since they're more readable and they don't add empty lines.\n        // Also prefer folding a super-long line.\n        if (!hasLineBreak && !hasFoldableLine) {\n          // Strings interpretable as another type have to be quoted;\n          // e.g. the string 'true' vs. the boolean true.\n          return plain && !testAmbiguousType(string)\n            ? STYLE_PLAIN : STYLE_SINGLE;\n        }\n        // Edge case: block indentation indicator can only have one digit.\n        if (indentPerLevel > 9 && needIndentIndicator(string)) {\n          return STYLE_DOUBLE;\n        }\n        // At this point we know block styles are valid.\n        // Prefer literal style unless we want to fold.\n        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n      }\n\n      // Note: line breaking/folding is implemented for only the folded style.\n      // NB. We drop the last trailing newline (if any) of a returned block scalar\n      //  since the dumper adds its own newline. This always works:\n      //     No ending newline => unaffected; already using strip \"-\" chomping.\n      //     Ending newline    => removed then restored.\n      //  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n      function writeScalar(state, string, level, iskey) {\n        state.dump = (function () {\n          if (string.length === 0) {\n            return \"''\";\n          }\n          if (!state.noCompatMode &&\n            DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n            return \"'\" + string + \"'\";\n          }\n\n          var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n          // As indentation gets deeper, let the width decrease monotonically\n          // to the lower bound min(state.lineWidth, 40).\n          // Note that this implies\n          //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.\n          //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n          // This behaves better than a constant minimum width which disallows narrower options,\n          // or an indent threshold which causes the width to suddenly increase.\n          var lineWidth = state.lineWidth === -1\n            ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n          // Without knowing if keys are implicit/explicit, assume implicit for safety.\n          var singleLineOnly = iskey\n            // No block styles in flow mode.\n            || (state.flowLevel > -1 && level >= state.flowLevel);\n          function testAmbiguity(string) {\n            return testImplicitResolving(state, string);\n          }\n\n          switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n            case STYLE_PLAIN:\n              return string;\n            case STYLE_SINGLE:\n              return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n            case STYLE_LITERAL:\n              return '|' + blockHeader(string, state.indent)\n                + dropEndingNewline(indentString(string, indent));\n            case STYLE_FOLDED:\n              return '>' + blockHeader(string, state.indent)\n                + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n            case STYLE_DOUBLE:\n              return '\"' + escapeString(string) + '\"';\n            default:\n              throw new YAMLException('impossible error: invalid scalar style');\n          }\n        }());\n      }\n\n      // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n      function blockHeader(string, indentPerLevel) {\n        var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n        // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n        var clip = string[string.length - 1] === '\\n';\n        var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n        var chomp = keep ? '+' : (clip ? '' : '-');\n\n        return indentIndicator + chomp + '\\n';\n      }\n\n      // (See the note for writeScalar.)\n      function dropEndingNewline(string) {\n        return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n      }\n\n      // Note: a long line without a suitable break point will exceed the width limit.\n      // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n      function foldString(string, width) {\n        // In folded style, $k$ consecutive newlines output as $k+1$ newlines\n        // unless they're before or after a more-indented line, or at the very\n        // beginning or end, in which case $k$ maps to $k$.\n        // Therefore, parse each chunk as newline(s) followed by a content line.\n        var lineRe = /(\\n+)([^\\n]*)/g;\n\n        // first line (possibly an empty line)\n        var result = (function () {\n          var nextLF = string.indexOf('\\n');\n          nextLF = nextLF !== -1 ? nextLF : string.length;\n          lineRe.lastIndex = nextLF;\n          return foldLine(string.slice(0, nextLF), width);\n        }());\n        // If we haven't reached the first content line yet, don't add an extra \\n.\n        var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n        var moreIndented;\n\n        // rest of the lines\n        var match;\n        while ((match = lineRe.exec(string))) {\n          var prefix = match[1], line = match[2];\n          moreIndented = (line[0] === ' ');\n          result += prefix\n            + (!prevMoreIndented && !moreIndented && line !== ''\n              ? '\\n' : '')\n            + foldLine(line, width);\n          prevMoreIndented = moreIndented;\n        }\n\n        return result;\n      }\n\n      // Greedy line breaking.\n      // Picks the longest line under the limit each time,\n      // otherwise settles for the shortest line over the limit.\n      // NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n      function foldLine(line, width) {\n        if (line === '' || line[0] === ' ') return line;\n\n        // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n        var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n        var match;\n        // start is an inclusive index. end, curr, and next are exclusive.\n        var start = 0, end, curr = 0, next = 0;\n        var result = '';\n\n        // Invariants: 0 <= start <= length-1.\n        //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n        // Inside the loop:\n        //   A match implies length >= 2, so curr and next are <= length-2.\n        while ((match = breakRe.exec(line))) {\n          next = match.index;\n          // maintain invariant: curr - start <= width\n          if (next - start > width) {\n            end = (curr > start) ? curr : next; // derive end <= length-2\n            result += '\\n' + line.slice(start, end);\n            // skip the space that was output as \\n\n            start = end + 1;                    // derive start <= length-1\n          }\n          curr = next;\n        }\n\n        // By the invariants, start <= length-1, so there is something left over.\n        // It is either the whole string or a part starting from non-whitespace.\n        result += '\\n';\n        // Insert a break if the remainder is too long and there is a break available.\n        if (line.length - start > width && curr > start) {\n          result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n        } else {\n          result += line.slice(start);\n        }\n\n        return result.slice(1); // drop extra \\n joiner\n      }\n\n      // Escapes a double-quoted string.\n      function escapeString(string) {\n        var result = '';\n        var char, nextChar;\n        var escapeSeq;\n\n        for (var i = 0; i < string.length; i++) {\n          char = string.charCodeAt(i);\n          // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n          if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {\n            nextChar = string.charCodeAt(i + 1);\n            if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {\n              // Combine the surrogate pair and store it escaped.\n              result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n              // Advance index one extra since we already used that char here.\n              i++; continue;\n            }\n          }\n          escapeSeq = ESCAPE_SEQUENCES[char];\n          result += !escapeSeq && isPrintable(char)\n            ? string[i]\n            : escapeSeq || encodeHex(char);\n        }\n\n        return result;\n      }\n\n      function writeFlowSequence(state, level, object) {\n        var _result = '',\n          _tag = state.tag,\n          index,\n          length;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          // Write only valid elements.\n          if (writeNode(state, level, object[index], false, false)) {\n            if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n            _result += state.dump;\n          }\n        }\n\n        state.tag = _tag;\n        state.dump = '[' + _result + ']';\n      }\n\n      function writeBlockSequence(state, level, object, compact) {\n        var _result = '',\n          _tag = state.tag,\n          index,\n          length;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          // Write only valid elements.\n          if (writeNode(state, level + 1, object[index], true, true)) {\n            if (!compact || index !== 0) {\n              _result += generateNextLine(state, level);\n            }\n\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n              _result += '-';\n            } else {\n              _result += '- ';\n            }\n\n            _result += state.dump;\n          }\n        }\n\n        state.tag = _tag;\n        state.dump = _result || '[]'; // Empty sequence if no valid values.\n      }\n\n      function writeFlowMapping(state, level, object) {\n        var _result = '',\n          _tag = state.tag,\n          objectKeyList = Object.keys(object),\n          index,\n          length,\n          objectKey,\n          objectValue,\n          pairBuffer;\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n          pairBuffer = '';\n          if (index !== 0) pairBuffer += ', ';\n\n          if (state.condenseFlow) pairBuffer += '\"';\n\n          objectKey = objectKeyList[index];\n          objectValue = object[objectKey];\n\n          if (!writeNode(state, level, objectKey, false, false)) {\n            continue; // Skip this pair because of invalid key;\n          }\n\n          if (state.dump.length > 1024) pairBuffer += '? ';\n\n          pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n          if (!writeNode(state, level, objectValue, false, false)) {\n            continue; // Skip this pair because of invalid value.\n          }\n\n          pairBuffer += state.dump;\n\n          // Both key and value are valid.\n          _result += pairBuffer;\n        }\n\n        state.tag = _tag;\n        state.dump = '{' + _result + '}';\n      }\n\n      function writeBlockMapping(state, level, object, compact) {\n        var _result = '',\n          _tag = state.tag,\n          objectKeyList = Object.keys(object),\n          index,\n          length,\n          objectKey,\n          objectValue,\n          explicitPair,\n          pairBuffer;\n\n        // Allow sorting keys so that the output file is deterministic\n        if (state.sortKeys === true) {\n          // Default sorting\n          objectKeyList.sort();\n        } else if (typeof state.sortKeys === 'function') {\n          // Custom sort function\n          objectKeyList.sort(state.sortKeys);\n        } else if (state.sortKeys) {\n          // Something is wrong\n          throw new YAMLException('sortKeys must be a boolean or a function');\n        }\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          pairBuffer = '';\n\n          if (!compact || index !== 0) {\n            pairBuffer += generateNextLine(state, level);\n          }\n\n          objectKey = objectKeyList[index];\n          objectValue = object[objectKey];\n\n          if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n            continue; // Skip this pair because of invalid key.\n          }\n\n          explicitPair = (state.tag !== null && state.tag !== '?') ||\n            (state.dump && state.dump.length > 1024);\n\n          if (explicitPair) {\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n              pairBuffer += '?';\n            } else {\n              pairBuffer += '? ';\n            }\n          }\n\n          pairBuffer += state.dump;\n\n          if (explicitPair) {\n            pairBuffer += generateNextLine(state, level);\n          }\n\n          if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n            continue; // Skip this pair because of invalid value.\n          }\n\n          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n            pairBuffer += ':';\n          } else {\n            pairBuffer += ': ';\n          }\n\n          pairBuffer += state.dump;\n\n          // Both key and value are valid.\n          _result += pairBuffer;\n        }\n\n        state.tag = _tag;\n        state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n      }\n\n      function detectType(state, object, explicit) {\n        var _result, typeList, index, length, type, style;\n\n        typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n        for (index = 0, length = typeList.length; index < length; index += 1) {\n          type = typeList[index];\n\n          if ((type.instanceOf || type.predicate) &&\n            (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n            (!type.predicate || type.predicate(object))) {\n\n            state.tag = explicit ? type.tag : '?';\n\n            if (type.represent) {\n              style = state.styleMap[type.tag] || type.defaultStyle;\n\n              if (_toString.call(type.represent) === '[object Function]') {\n                _result = type.represent(object, style);\n              } else if (_hasOwnProperty.call(type.represent, style)) {\n                _result = type.represent[style](object, style);\n              } else {\n                throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n              }\n\n              state.dump = _result;\n            }\n\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      // Serializes `object` and writes it to global `result`.\n      // Returns true on success, or false on invalid object.\n      //\n      function writeNode(state, level, object, block, compact, iskey) {\n        state.tag = null;\n        state.dump = object;\n\n        if (!detectType(state, object, false)) {\n          detectType(state, object, true);\n        }\n\n        var type = _toString.call(state.dump);\n\n        if (block) {\n          block = (state.flowLevel < 0 || state.flowLevel > level);\n        }\n\n        var objectOrArray = type === '[object Object]' || type === '[object Array]',\n          duplicateIndex,\n          duplicate;\n\n        if (objectOrArray) {\n          duplicateIndex = state.duplicates.indexOf(object);\n          duplicate = duplicateIndex !== -1;\n        }\n\n        if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n          compact = false;\n        }\n\n        if (duplicate && state.usedDuplicates[duplicateIndex]) {\n          state.dump = '*ref_' + duplicateIndex;\n        } else {\n          if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n            state.usedDuplicates[duplicateIndex] = true;\n          }\n          if (type === '[object Object]') {\n            if (block && (Object.keys(state.dump).length !== 0)) {\n              writeBlockMapping(state, level, state.dump, compact);\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + state.dump;\n              }\n            } else {\n              writeFlowMapping(state, level, state.dump);\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n              }\n            }\n          } else if (type === '[object Array]') {\n            var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;\n            if (block && (state.dump.length !== 0)) {\n              writeBlockSequence(state, arrayLevel, state.dump, compact);\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + state.dump;\n              }\n            } else {\n              writeFlowSequence(state, arrayLevel, state.dump);\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n              }\n            }\n          } else if (type === '[object String]') {\n            if (state.tag !== '?') {\n              writeScalar(state, state.dump, level, iskey);\n            }\n          } else {\n            if (state.skipInvalid) return false;\n            throw new YAMLException('unacceptable kind of an object to dump ' + type);\n          }\n\n          if (state.tag !== null && state.tag !== '?') {\n            state.dump = '!<' + state.tag + '> ' + state.dump;\n          }\n        }\n\n        return true;\n      }\n\n      function getDuplicateReferences(object, state) {\n        var objects = [],\n          duplicatesIndexes = [],\n          index,\n          length;\n\n        inspectNode(object, objects, duplicatesIndexes);\n\n        for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n          state.duplicates.push(objects[duplicatesIndexes[index]]);\n        }\n        state.usedDuplicates = new Array(length);\n      }\n\n      function inspectNode(object, objects, duplicatesIndexes) {\n        var objectKeyList,\n          index,\n          length;\n\n        if (object !== null && typeof object === 'object') {\n          index = objects.indexOf(object);\n          if (index !== -1) {\n            if (duplicatesIndexes.indexOf(index) === -1) {\n              duplicatesIndexes.push(index);\n            }\n          } else {\n            objects.push(object);\n\n            if (Array.isArray(object)) {\n              for (index = 0, length = object.length; index < length; index += 1) {\n                inspectNode(object[index], objects, duplicatesIndexes);\n              }\n            } else {\n              objectKeyList = Object.keys(object);\n\n              for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n                inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n              }\n            }\n          }\n        }\n      }\n\n      function dump(input, options) {\n        options = options || {};\n\n        var state = new State(options);\n\n        if (!state.noRefs) getDuplicateReferences(input, state);\n\n        if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n\n        return '';\n      }\n\n      function safeDump(input, options) {\n        return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n      }\n\n      module.exports.dump = dump;\n      module.exports.safeDump = safeDump;\n\n    }, { \"./common\": 2, \"./exception\": 4, \"./schema/default_full\": 9, \"./schema/default_safe\": 10 }], 4: [function (require, module, exports) {\n      // YAML error class. http://stackoverflow.com/questions/8458984\n      //\n      'use strict';\n\n      function YAMLException(reason, mark) {\n        // Super constructor\n        Error.call(this);\n\n        this.name = 'YAMLException';\n        this.reason = reason;\n        this.mark = mark;\n        this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');\n\n        // Include stack trace in error object\n        if (Error.captureStackTrace) {\n          // Chrome and NodeJS\n          Error.captureStackTrace(this, this.constructor);\n        } else {\n          // FF, IE 10+ and Safari 6+. Fallback for others\n          this.stack = (new Error()).stack || '';\n        }\n      }\n\n\n      // Inherit from Error\n      YAMLException.prototype = Object.create(Error.prototype);\n      YAMLException.prototype.constructor = YAMLException;\n\n\n      YAMLException.prototype.toString = function toString(compact) {\n        var result = this.name + ': ';\n\n        result += this.reason || '(unknown reason)';\n\n        if (!compact && this.mark) {\n          result += ' ' + this.mark.toString();\n        }\n\n        return result;\n      };\n\n\n      module.exports = YAMLException;\n\n    }, {}], 5: [function (require, module, exports) {\n      'use strict';\n\n      /*eslint-disable max-len,no-use-before-define*/\n\n      var common = require('./common');\n      var YAMLException = require('./exception');\n      var Mark = require('./mark');\n      var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n      var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n      var CONTEXT_FLOW_IN = 1;\n      var CONTEXT_FLOW_OUT = 2;\n      var CONTEXT_BLOCK_IN = 3;\n      var CONTEXT_BLOCK_OUT = 4;\n\n\n      var CHOMPING_CLIP = 1;\n      var CHOMPING_STRIP = 2;\n      var CHOMPING_KEEP = 3;\n\n\n      var PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n      var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n      var PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\n      var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\n      var PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\n      function _class(obj) { return Object.prototype.toString.call(obj); }\n\n      function is_EOL(c) {\n        return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n      }\n\n      function is_WHITE_SPACE(c) {\n        return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n      }\n\n      function is_WS_OR_EOL(c) {\n        return (c === 0x09/* Tab */) ||\n          (c === 0x20/* Space */) ||\n          (c === 0x0A/* LF */) ||\n          (c === 0x0D/* CR */);\n      }\n\n      function is_FLOW_INDICATOR(c) {\n        return c === 0x2C/* , */ ||\n          c === 0x5B/* [ */ ||\n          c === 0x5D/* ] */ ||\n          c === 0x7B/* { */ ||\n          c === 0x7D/* } */;\n      }\n\n      function fromHexCode(c) {\n        var lc;\n\n        if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n          return c - 0x30;\n        }\n\n        /*eslint-disable no-bitwise*/\n        lc = c | 0x20;\n\n        if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n          return lc - 0x61 + 10;\n        }\n\n        return -1;\n      }\n\n      function escapedHexLen(c) {\n        if (c === 0x78/* x */) { return 2; }\n        if (c === 0x75/* u */) { return 4; }\n        if (c === 0x55/* U */) { return 8; }\n        return 0;\n      }\n\n      function fromDecimalCode(c) {\n        if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n          return c - 0x30;\n        }\n\n        return -1;\n      }\n\n      function simpleEscapeSequence(c) {\n        /* eslint-disable indent */\n        return (c === 0x30/* 0 */) ? '\\x00' :\n          (c === 0x61/* a */) ? '\\x07' :\n            (c === 0x62/* b */) ? '\\x08' :\n              (c === 0x74/* t */) ? '\\x09' :\n                (c === 0x09/* Tab */) ? '\\x09' :\n                  (c === 0x6E/* n */) ? '\\x0A' :\n                    (c === 0x76/* v */) ? '\\x0B' :\n                      (c === 0x66/* f */) ? '\\x0C' :\n                        (c === 0x72/* r */) ? '\\x0D' :\n                          (c === 0x65/* e */) ? '\\x1B' :\n                            (c === 0x20/* Space */) ? ' ' :\n                              (c === 0x22/* \" */) ? '\\x22' :\n                                (c === 0x2F/* / */) ? '/' :\n                                  (c === 0x5C/* \\ */) ? '\\x5C' :\n                                    (c === 0x4E/* N */) ? '\\x85' :\n                                      (c === 0x5F/* _ */) ? '\\xA0' :\n                                        (c === 0x4C/* L */) ? '\\u2028' :\n                                          (c === 0x50/* P */) ? '\\u2029' : '';\n      }\n\n      function charFromCodepoint(c) {\n        if (c <= 0xFFFF) {\n          return String.fromCharCode(c);\n        }\n        // Encode UTF-16 surrogate pair\n        // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n        return String.fromCharCode(\n          ((c - 0x010000) >> 10) + 0xD800,\n          ((c - 0x010000) & 0x03FF) + 0xDC00\n        );\n      }\n\n      var simpleEscapeCheck = new Array(256); // integer, for fast access\n      var simpleEscapeMap = new Array(256);\n      for (var i = 0; i < 256; i++) {\n        simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n        simpleEscapeMap[i] = simpleEscapeSequence(i);\n      }\n\n\n      function State(input, options) {\n        this.input = input;\n\n        this.filename = options['filename'] || null;\n        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n        this.onWarning = options['onWarning'] || null;\n        this.legacy = options['legacy'] || false;\n        this.json = options['json'] || false;\n        this.listener = options['listener'] || null;\n\n        this.implicitTypes = this.schema.compiledImplicit;\n        this.typeMap = this.schema.compiledTypeMap;\n\n        this.length = input.length;\n        this.position = 0;\n        this.line = 0;\n        this.lineStart = 0;\n        this.lineIndent = 0;\n\n        this.documents = [];\n\n        /*\n        this.version;\n        this.checkLineBreaks;\n        this.tagMap;\n        this.anchorMap;\n        this.tag;\n        this.anchor;\n        this.kind;\n        this.result;*/\n\n      }\n\n\n      function generateError(state, message) {\n        return new YAMLException(\n          message,\n          new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));\n      }\n\n      function throwError(state, message) {\n        throw generateError(state, message);\n      }\n\n      function throwWarning(state, message) {\n        if (state.onWarning) {\n          state.onWarning.call(null, generateError(state, message));\n        }\n      }\n\n\n      var directiveHandlers = {\n\n        YAML: function handleYamlDirective(state, name, args) {\n\n          var match, major, minor;\n\n          if (state.version !== null) {\n            throwError(state, 'duplication of %YAML directive');\n          }\n\n          if (args.length !== 1) {\n            throwError(state, 'YAML directive accepts exactly one argument');\n          }\n\n          match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n          if (match === null) {\n            throwError(state, 'ill-formed argument of the YAML directive');\n          }\n\n          major = parseInt(match[1], 10);\n          minor = parseInt(match[2], 10);\n\n          if (major !== 1) {\n            throwError(state, 'unacceptable YAML version of the document');\n          }\n\n          state.version = args[0];\n          state.checkLineBreaks = (minor < 2);\n\n          if (minor !== 1 && minor !== 2) {\n            throwWarning(state, 'unsupported YAML version of the document');\n          }\n        },\n\n        TAG: function handleTagDirective(state, name, args) {\n\n          var handle, prefix;\n\n          if (args.length !== 2) {\n            throwError(state, 'TAG directive accepts exactly two arguments');\n          }\n\n          handle = args[0];\n          prefix = args[1];\n\n          if (!PATTERN_TAG_HANDLE.test(handle)) {\n            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n          }\n\n          if (_hasOwnProperty.call(state.tagMap, handle)) {\n            throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n          }\n\n          if (!PATTERN_TAG_URI.test(prefix)) {\n            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n          }\n\n          state.tagMap[handle] = prefix;\n        }\n      };\n\n\n      function captureSegment(state, start, end, checkJson) {\n        var _position, _length, _character, _result;\n\n        if (start < end) {\n          _result = state.input.slice(start, end);\n\n          if (checkJson) {\n            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n              _character = _result.charCodeAt(_position);\n              if (!(_character === 0x09 ||\n                (0x20 <= _character && _character <= 0x10FFFF))) {\n                throwError(state, 'expected valid JSON character');\n              }\n            }\n          } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n            throwError(state, 'the stream contains non-printable characters');\n          }\n\n          state.result += _result;\n        }\n      }\n\n      function mergeMappings(state, destination, source, overridableKeys) {\n        var sourceKeys, key, index, quantity;\n\n        if (!common.isObject(source)) {\n          throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n        }\n\n        sourceKeys = Object.keys(source);\n\n        for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n          key = sourceKeys[index];\n\n          if (!_hasOwnProperty.call(destination, key)) {\n            destination[key] = source[key];\n            overridableKeys[key] = true;\n          }\n        }\n      }\n\n      function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n        var index, quantity;\n\n        // The output is a plain object here, so keys can only be strings.\n        // We need to convert keyNode to a string, but doing so can hang the process\n        // (deeply nested arrays that explode exponentially using aliases).\n        if (Array.isArray(keyNode)) {\n          keyNode = Array.prototype.slice.call(keyNode);\n\n          for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n            if (Array.isArray(keyNode[index])) {\n              throwError(state, 'nested arrays are not supported inside keys');\n            }\n\n            if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n              keyNode[index] = '[object Object]';\n            }\n          }\n        }\n\n        // Avoid code execution in load() via toString property\n        // (still use its own toString for arrays, timestamps,\n        // and whatever user schema extensions happen to have @@toStringTag)\n        if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n          keyNode = '[object Object]';\n        }\n\n\n        keyNode = String(keyNode);\n\n        if (_result === null) {\n          _result = {};\n        }\n\n        if (keyTag === 'tag:yaml.org,2002:merge') {\n          if (Array.isArray(valueNode)) {\n            for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n              mergeMappings(state, _result, valueNode[index], overridableKeys);\n            }\n          } else {\n            mergeMappings(state, _result, valueNode, overridableKeys);\n          }\n        } else {\n          if (!state.json &&\n            !_hasOwnProperty.call(overridableKeys, keyNode) &&\n            _hasOwnProperty.call(_result, keyNode)) {\n            state.line = startLine || state.line;\n            state.position = startPos || state.position;\n            throwError(state, 'duplicated mapping key');\n          }\n          _result[keyNode] = valueNode;\n          delete overridableKeys[keyNode];\n        }\n\n        return _result;\n      }\n\n      function readLineBreak(state) {\n        var ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x0A/* LF */) {\n          state.position++;\n        } else if (ch === 0x0D/* CR */) {\n          state.position++;\n          if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n            state.position++;\n          }\n        } else {\n          throwError(state, 'a line break is expected');\n        }\n\n        state.line += 1;\n        state.lineStart = state.position;\n      }\n\n      function skipSeparationSpace(state, allowComments, checkIndent) {\n        var lineBreaks = 0,\n          ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n          while (is_WHITE_SPACE(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          if (allowComments && ch === 0x23/* # */) {\n            do {\n              ch = state.input.charCodeAt(++state.position);\n            } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n          }\n\n          if (is_EOL(ch)) {\n            readLineBreak(state);\n\n            ch = state.input.charCodeAt(state.position);\n            lineBreaks++;\n            state.lineIndent = 0;\n\n            while (ch === 0x20/* Space */) {\n              state.lineIndent++;\n              ch = state.input.charCodeAt(++state.position);\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n          throwWarning(state, 'deficient indentation');\n        }\n\n        return lineBreaks;\n      }\n\n      function testDocumentSeparator(state) {\n        var _position = state.position,\n          ch;\n\n        ch = state.input.charCodeAt(_position);\n\n        // Condition state.position === state.lineStart is tested\n        // in parent on each call, for efficiency. No needs to test here again.\n        if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n          ch === state.input.charCodeAt(_position + 1) &&\n          ch === state.input.charCodeAt(_position + 2)) {\n\n          _position += 3;\n\n          ch = state.input.charCodeAt(_position);\n\n          if (ch === 0 || is_WS_OR_EOL(ch)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      function writeFoldedLines(state, count) {\n        if (count === 1) {\n          state.result += ' ';\n        } else if (count > 1) {\n          state.result += common.repeat('\\n', count - 1);\n        }\n      }\n\n\n      function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n        var preceding,\n          following,\n          captureStart,\n          captureEnd,\n          hasPendingContent,\n          _line,\n          _lineStart,\n          _lineIndent,\n          _kind = state.kind,\n          _result = state.result,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (is_WS_OR_EOL(ch) ||\n          is_FLOW_INDICATOR(ch) ||\n          ch === 0x23/* # */ ||\n          ch === 0x26/* & */ ||\n          ch === 0x2A/* * */ ||\n          ch === 0x21/* ! */ ||\n          ch === 0x7C/* | */ ||\n          ch === 0x3E/* > */ ||\n          ch === 0x27/* ' */ ||\n          ch === 0x22/* \" */ ||\n          ch === 0x25/* % */ ||\n          ch === 0x40/* @ */ ||\n          ch === 0x60/* ` */) {\n          return false;\n        }\n\n        if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n          following = state.input.charCodeAt(state.position + 1);\n\n          if (is_WS_OR_EOL(following) ||\n            withinFlowCollection && is_FLOW_INDICATOR(following)) {\n            return false;\n          }\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n        captureStart = captureEnd = state.position;\n        hasPendingContent = false;\n\n        while (ch !== 0) {\n          if (ch === 0x3A/* : */) {\n            following = state.input.charCodeAt(state.position + 1);\n\n            if (is_WS_OR_EOL(following) ||\n              withinFlowCollection && is_FLOW_INDICATOR(following)) {\n              break;\n            }\n\n          } else if (ch === 0x23/* # */) {\n            preceding = state.input.charCodeAt(state.position - 1);\n\n            if (is_WS_OR_EOL(preceding)) {\n              break;\n            }\n\n          } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n            withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n            break;\n\n          } else if (is_EOL(ch)) {\n            _line = state.line;\n            _lineStart = state.lineStart;\n            _lineIndent = state.lineIndent;\n            skipSeparationSpace(state, false, -1);\n\n            if (state.lineIndent >= nodeIndent) {\n              hasPendingContent = true;\n              ch = state.input.charCodeAt(state.position);\n              continue;\n            } else {\n              state.position = captureEnd;\n              state.line = _line;\n              state.lineStart = _lineStart;\n              state.lineIndent = _lineIndent;\n              break;\n            }\n          }\n\n          if (hasPendingContent) {\n            captureSegment(state, captureStart, captureEnd, false);\n            writeFoldedLines(state, state.line - _line);\n            captureStart = captureEnd = state.position;\n            hasPendingContent = false;\n          }\n\n          if (!is_WHITE_SPACE(ch)) {\n            captureEnd = state.position + 1;\n          }\n\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        captureSegment(state, captureStart, captureEnd, false);\n\n        if (state.result) {\n          return true;\n        }\n\n        state.kind = _kind;\n        state.result = _result;\n        return false;\n      }\n\n      function readSingleQuotedScalar(state, nodeIndent) {\n        var ch,\n          captureStart, captureEnd;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x27/* ' */) {\n          return false;\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n        state.position++;\n        captureStart = captureEnd = state.position;\n\n        while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n          if (ch === 0x27/* ' */) {\n            captureSegment(state, captureStart, state.position, true);\n            ch = state.input.charCodeAt(++state.position);\n\n            if (ch === 0x27/* ' */) {\n              captureStart = state.position;\n              state.position++;\n              captureEnd = state.position;\n            } else {\n              return true;\n            }\n\n          } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n\n          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n          } else {\n            state.position++;\n            captureEnd = state.position;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a single quoted scalar');\n      }\n\n      function readDoubleQuotedScalar(state, nodeIndent) {\n        var captureStart,\n          captureEnd,\n          hexLength,\n          hexResult,\n          tmp,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x22/* \" */) {\n          return false;\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n        state.position++;\n        captureStart = captureEnd = state.position;\n\n        while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n          if (ch === 0x22/* \" */) {\n            captureSegment(state, captureStart, state.position, true);\n            state.position++;\n            return true;\n\n          } else if (ch === 0x5C/* \\ */) {\n            captureSegment(state, captureStart, state.position, true);\n            ch = state.input.charCodeAt(++state.position);\n\n            if (is_EOL(ch)) {\n              skipSeparationSpace(state, false, nodeIndent);\n\n              // TODO: rework to inline fn with no type cast?\n            } else if (ch < 256 && simpleEscapeCheck[ch]) {\n              state.result += simpleEscapeMap[ch];\n              state.position++;\n\n            } else if ((tmp = escapedHexLen(ch)) > 0) {\n              hexLength = tmp;\n              hexResult = 0;\n\n              for (; hexLength > 0; hexLength--) {\n                ch = state.input.charCodeAt(++state.position);\n\n                if ((tmp = fromHexCode(ch)) >= 0) {\n                  hexResult = (hexResult << 4) + tmp;\n\n                } else {\n                  throwError(state, 'expected hexadecimal character');\n                }\n              }\n\n              state.result += charFromCodepoint(hexResult);\n\n              state.position++;\n\n            } else {\n              throwError(state, 'unknown escape sequence');\n            }\n\n            captureStart = captureEnd = state.position;\n\n          } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n\n          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n          } else {\n            state.position++;\n            captureEnd = state.position;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a double quoted scalar');\n      }\n\n      function readFlowCollection(state, nodeIndent) {\n        var readNext = true,\n          _line,\n          _tag = state.tag,\n          _result,\n          _anchor = state.anchor,\n          following,\n          terminator,\n          isPair,\n          isExplicitPair,\n          isMapping,\n          overridableKeys = {},\n          keyNode,\n          keyTag,\n          valueNode,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x5B/* [ */) {\n          terminator = 0x5D;/* ] */\n          isMapping = false;\n          _result = [];\n        } else if (ch === 0x7B/* { */) {\n          terminator = 0x7D;/* } */\n          isMapping = true;\n          _result = {};\n        } else {\n          return false;\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n\n        while (ch !== 0) {\n          skipSeparationSpace(state, true, nodeIndent);\n\n          ch = state.input.charCodeAt(state.position);\n\n          if (ch === terminator) {\n            state.position++;\n            state.tag = _tag;\n            state.anchor = _anchor;\n            state.kind = isMapping ? 'mapping' : 'sequence';\n            state.result = _result;\n            return true;\n          } else if (!readNext) {\n            throwError(state, 'missed comma between flow collection entries');\n          }\n\n          keyTag = keyNode = valueNode = null;\n          isPair = isExplicitPair = false;\n\n          if (ch === 0x3F/* ? */) {\n            following = state.input.charCodeAt(state.position + 1);\n\n            if (is_WS_OR_EOL(following)) {\n              isPair = isExplicitPair = true;\n              state.position++;\n              skipSeparationSpace(state, true, nodeIndent);\n            }\n          }\n\n          _line = state.line;\n          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n          keyTag = state.tag;\n          keyNode = state.result;\n          skipSeparationSpace(state, true, nodeIndent);\n\n          ch = state.input.charCodeAt(state.position);\n\n          if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n            isPair = true;\n            state.input.charCodeAt(++state.position);\n            skipSeparationSpace(state, true, nodeIndent);\n            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n            valueNode = state.result;\n          }\n\n          if (isMapping) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n          } else if (isPair) {\n            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n          } else {\n            _result.push(keyNode);\n          }\n\n          skipSeparationSpace(state, true, nodeIndent);\n\n          ch = state.input.charCodeAt(state.position);\n\n          if (ch === 0x2C/* , */) {\n            readNext = true;\n            ch = state.input.charCodeAt(++state.position);\n          } else {\n            readNext = false;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a flow collection');\n      }\n\n      function readBlockScalar(state, nodeIndent) {\n        var captureStart,\n          folding,\n          chomping = CHOMPING_CLIP,\n          didReadContent = false,\n          detectedIndent = false,\n          textIndent = nodeIndent,\n          emptyLines = 0,\n          atMoreIndented = false,\n          tmp,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x7C/* | */) {\n          folding = false;\n        } else if (ch === 0x3E/* > */) {\n          folding = true;\n        } else {\n          return false;\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n\n        while (ch !== 0) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n            if (CHOMPING_CLIP === chomping) {\n              chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n            } else {\n              throwError(state, 'repeat of a chomping mode identifier');\n            }\n\n          } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n            if (tmp === 0) {\n              throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n            } else if (!detectedIndent) {\n              textIndent = nodeIndent + tmp - 1;\n              detectedIndent = true;\n            } else {\n              throwError(state, 'repeat of an indentation width identifier');\n            }\n\n          } else {\n            break;\n          }\n        }\n\n        if (is_WHITE_SPACE(ch)) {\n          do { ch = state.input.charCodeAt(++state.position); }\n          while (is_WHITE_SPACE(ch));\n\n          if (ch === 0x23/* # */) {\n            do { ch = state.input.charCodeAt(++state.position); }\n            while (!is_EOL(ch) && (ch !== 0));\n          }\n        }\n\n        while (ch !== 0) {\n          readLineBreak(state);\n          state.lineIndent = 0;\n\n          ch = state.input.charCodeAt(state.position);\n\n          while ((!detectedIndent || state.lineIndent < textIndent) &&\n            (ch === 0x20/* Space */)) {\n            state.lineIndent++;\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          if (!detectedIndent && state.lineIndent > textIndent) {\n            textIndent = state.lineIndent;\n          }\n\n          if (is_EOL(ch)) {\n            emptyLines++;\n            continue;\n          }\n\n          // End of the scalar.\n          if (state.lineIndent < textIndent) {\n\n            // Perform the chomping.\n            if (chomping === CHOMPING_KEEP) {\n              state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n            } else if (chomping === CHOMPING_CLIP) {\n              if (didReadContent) { // i.e. only if the scalar is not empty.\n                state.result += '\\n';\n              }\n            }\n\n            // Break this `while` cycle and go to the funciton's epilogue.\n            break;\n          }\n\n          // Folded style: use fancy rules to handle line breaks.\n          if (folding) {\n\n            // Lines starting with white space characters (more-indented lines) are not folded.\n            if (is_WHITE_SPACE(ch)) {\n              atMoreIndented = true;\n              // except for the first content line (cf. Example 8.1)\n              state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n              // End of more-indented block.\n            } else if (atMoreIndented) {\n              atMoreIndented = false;\n              state.result += common.repeat('\\n', emptyLines + 1);\n\n              // Just one line break - perceive as the same line.\n            } else if (emptyLines === 0) {\n              if (didReadContent) { // i.e. only if we have already read some scalar content.\n                state.result += ' ';\n              }\n\n              // Several line breaks - perceive as different lines.\n            } else {\n              state.result += common.repeat('\\n', emptyLines);\n            }\n\n            // Literal style: just add exact number of line breaks between content lines.\n          } else {\n            // Keep all line breaks except the header line break.\n            state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n          }\n\n          didReadContent = true;\n          detectedIndent = true;\n          emptyLines = 0;\n          captureStart = state.position;\n\n          while (!is_EOL(ch) && (ch !== 0)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          captureSegment(state, captureStart, state.position, false);\n        }\n\n        return true;\n      }\n\n      function readBlockSequence(state, nodeIndent) {\n        var _line,\n          _tag = state.tag,\n          _anchor = state.anchor,\n          _result = [],\n          following,\n          detected = false,\n          ch;\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n\n          if (ch !== 0x2D/* - */) {\n            break;\n          }\n\n          following = state.input.charCodeAt(state.position + 1);\n\n          if (!is_WS_OR_EOL(following)) {\n            break;\n          }\n\n          detected = true;\n          state.position++;\n\n          if (skipSeparationSpace(state, true, -1)) {\n            if (state.lineIndent <= nodeIndent) {\n              _result.push(null);\n              ch = state.input.charCodeAt(state.position);\n              continue;\n            }\n          }\n\n          _line = state.line;\n          composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n          _result.push(state.result);\n          skipSeparationSpace(state, true, -1);\n\n          ch = state.input.charCodeAt(state.position);\n\n          if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n            throwError(state, 'bad indentation of a sequence entry');\n          } else if (state.lineIndent < nodeIndent) {\n            break;\n          }\n        }\n\n        if (detected) {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          state.kind = 'sequence';\n          state.result = _result;\n          return true;\n        }\n        return false;\n      }\n\n      function readBlockMapping(state, nodeIndent, flowIndent) {\n        var following,\n          allowCompact,\n          _line,\n          _pos,\n          _tag = state.tag,\n          _anchor = state.anchor,\n          _result = {},\n          overridableKeys = {},\n          keyTag = null,\n          keyNode = null,\n          valueNode = null,\n          atExplicitKey = false,\n          detected = false,\n          ch;\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n          following = state.input.charCodeAt(state.position + 1);\n          _line = state.line; // Save the current line.\n          _pos = state.position;\n\n          //\n          // Explicit notation case. There are two separate blocks:\n          // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n          //\n          if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n            if (ch === 0x3F/* ? */) {\n              if (atExplicitKey) {\n                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                keyTag = keyNode = valueNode = null;\n              }\n\n              detected = true;\n              atExplicitKey = true;\n              allowCompact = true;\n\n            } else if (atExplicitKey) {\n              // i.e. 0x3A/* : */ === character after the explicit key.\n              atExplicitKey = false;\n              allowCompact = true;\n\n            } else {\n              throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n            }\n\n            state.position += 1;\n            ch = following;\n\n            //\n            // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n            //\n          } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n\n            if (state.line === _line) {\n              ch = state.input.charCodeAt(state.position);\n\n              while (is_WHITE_SPACE(ch)) {\n                ch = state.input.charCodeAt(++state.position);\n              }\n\n              if (ch === 0x3A/* : */) {\n                ch = state.input.charCodeAt(++state.position);\n\n                if (!is_WS_OR_EOL(ch)) {\n                  throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n                }\n\n                if (atExplicitKey) {\n                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                  keyTag = keyNode = valueNode = null;\n                }\n\n                detected = true;\n                atExplicitKey = false;\n                allowCompact = false;\n                keyTag = state.tag;\n                keyNode = state.result;\n\n              } else if (detected) {\n                throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n              } else {\n                state.tag = _tag;\n                state.anchor = _anchor;\n                return true; // Keep the result of `composeNode`.\n              }\n\n            } else if (detected) {\n              throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n            } else {\n              state.tag = _tag;\n              state.anchor = _anchor;\n              return true; // Keep the result of `composeNode`.\n            }\n\n          } else {\n            break; // Reading is done. Go to the epilogue.\n          }\n\n          //\n          // Common reading code for both explicit and implicit notations.\n          //\n          if (state.line === _line || state.lineIndent > nodeIndent) {\n            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n              if (atExplicitKey) {\n                keyNode = state.result;\n              } else {\n                valueNode = state.result;\n              }\n            }\n\n            if (!atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n              keyTag = keyNode = valueNode = null;\n            }\n\n            skipSeparationSpace(state, true, -1);\n            ch = state.input.charCodeAt(state.position);\n          }\n\n          if (state.lineIndent > nodeIndent && (ch !== 0)) {\n            throwError(state, 'bad indentation of a mapping entry');\n          } else if (state.lineIndent < nodeIndent) {\n            break;\n          }\n        }\n\n        //\n        // Epilogue.\n        //\n\n        // Special case: last mapping's node contains only the key in explicit notation.\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n        }\n\n        // Expose the resulting mapping.\n        if (detected) {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          state.kind = 'mapping';\n          state.result = _result;\n        }\n\n        return detected;\n      }\n\n      function readTagProperty(state) {\n        var _position,\n          isVerbatim = false,\n          isNamed = false,\n          tagHandle,\n          tagName,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x21/* ! */) return false;\n\n        if (state.tag !== null) {\n          throwError(state, 'duplication of a tag property');\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n\n        if (ch === 0x3C/* < */) {\n          isVerbatim = true;\n          ch = state.input.charCodeAt(++state.position);\n\n        } else if (ch === 0x21/* ! */) {\n          isNamed = true;\n          tagHandle = '!!';\n          ch = state.input.charCodeAt(++state.position);\n\n        } else {\n          tagHandle = '!';\n        }\n\n        _position = state.position;\n\n        if (isVerbatim) {\n          do { ch = state.input.charCodeAt(++state.position); }\n          while (ch !== 0 && ch !== 0x3E/* > */);\n\n          if (state.position < state.length) {\n            tagName = state.input.slice(_position, state.position);\n            state.input.charCodeAt(++state.position);\n          } else {\n            throwError(state, 'unexpected end of the stream within a verbatim tag');\n          }\n        } else {\n          while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n            if (ch === 0x21/* ! */) {\n              if (!isNamed) {\n                tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n                if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n                  throwError(state, 'named tag handle cannot contain such characters');\n                }\n\n                isNamed = true;\n                _position = state.position + 1;\n              } else {\n                throwError(state, 'tag suffix cannot contain exclamation marks');\n              }\n            }\n\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          tagName = state.input.slice(_position, state.position);\n\n          if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n            throwError(state, 'tag suffix cannot contain flow indicator characters');\n          }\n        }\n\n        if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n          throwError(state, 'tag name cannot contain such characters: ' + tagName);\n        }\n\n        if (isVerbatim) {\n          state.tag = tagName;\n\n        } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n          state.tag = state.tagMap[tagHandle] + tagName;\n\n        } else if (tagHandle === '!') {\n          state.tag = '!' + tagName;\n\n        } else if (tagHandle === '!!') {\n          state.tag = 'tag:yaml.org,2002:' + tagName;\n\n        } else {\n          throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n        }\n\n        return true;\n      }\n\n      function readAnchorProperty(state) {\n        var _position,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x26/* & */) return false;\n\n        if (state.anchor !== null) {\n          throwError(state, 'duplication of an anchor property');\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n\n        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (state.position === _position) {\n          throwError(state, 'name of an anchor node must contain at least one character');\n        }\n\n        state.anchor = state.input.slice(_position, state.position);\n        return true;\n      }\n\n      function readAlias(state) {\n        var _position, alias,\n          ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x2A/* * */) return false;\n\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n\n        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (state.position === _position) {\n          throwError(state, 'name of an alias node must contain at least one character');\n        }\n\n        alias = state.input.slice(_position, state.position);\n\n        if (!state.anchorMap.hasOwnProperty(alias)) {\n          throwError(state, 'unidentified alias \"' + alias + '\"');\n        }\n\n        state.result = state.anchorMap[alias];\n        skipSeparationSpace(state, true, -1);\n        return true;\n      }\n\n      function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n        var allowBlockStyles,\n          allowBlockScalars,\n          allowBlockCollections,\n          indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n          atNewLine = false,\n          hasContent = false,\n          typeIndex,\n          typeQuantity,\n          type,\n          flowIndent,\n          blockIndent;\n\n        if (state.listener !== null) {\n          state.listener('open', state);\n        }\n\n        state.tag = null;\n        state.anchor = null;\n        state.kind = null;\n        state.result = null;\n\n        allowBlockStyles = allowBlockScalars = allowBlockCollections =\n          CONTEXT_BLOCK_OUT === nodeContext ||\n          CONTEXT_BLOCK_IN === nodeContext;\n\n        if (allowToSeek) {\n          if (skipSeparationSpace(state, true, -1)) {\n            atNewLine = true;\n\n            if (state.lineIndent > parentIndent) {\n              indentStatus = 1;\n            } else if (state.lineIndent === parentIndent) {\n              indentStatus = 0;\n            } else if (state.lineIndent < parentIndent) {\n              indentStatus = -1;\n            }\n          }\n        }\n\n        if (indentStatus === 1) {\n          while (readTagProperty(state) || readAnchorProperty(state)) {\n            if (skipSeparationSpace(state, true, -1)) {\n              atNewLine = true;\n              allowBlockCollections = allowBlockStyles;\n\n              if (state.lineIndent > parentIndent) {\n                indentStatus = 1;\n              } else if (state.lineIndent === parentIndent) {\n                indentStatus = 0;\n              } else if (state.lineIndent < parentIndent) {\n                indentStatus = -1;\n              }\n            } else {\n              allowBlockCollections = false;\n            }\n          }\n        }\n\n        if (allowBlockCollections) {\n          allowBlockCollections = atNewLine || allowCompact;\n        }\n\n        if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n          if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n            flowIndent = parentIndent;\n          } else {\n            flowIndent = parentIndent + 1;\n          }\n\n          blockIndent = state.position - state.lineStart;\n\n          if (indentStatus === 1) {\n            if (allowBlockCollections &&\n              (readBlockSequence(state, blockIndent) ||\n                readBlockMapping(state, blockIndent, flowIndent)) ||\n              readFlowCollection(state, flowIndent)) {\n              hasContent = true;\n            } else {\n              if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n                readSingleQuotedScalar(state, flowIndent) ||\n                readDoubleQuotedScalar(state, flowIndent)) {\n                hasContent = true;\n\n              } else if (readAlias(state)) {\n                hasContent = true;\n\n                if (state.tag !== null || state.anchor !== null) {\n                  throwError(state, 'alias node should not have any properties');\n                }\n\n              } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n                hasContent = true;\n\n                if (state.tag === null) {\n                  state.tag = '?';\n                }\n              }\n\n              if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n              }\n            }\n          } else if (indentStatus === 0) {\n            // Special case: block sequences are allowed to have same indentation level as the parent.\n            // http://www.yaml.org/spec/1.2/spec.html#id2799784\n            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n          }\n        }\n\n        if (state.tag !== null && state.tag !== '!') {\n          if (state.tag === '?') {\n            // Implicit resolving is not allowed for non-scalar types, and '?'\n            // non-specific tag is only automatically assigned to plain scalars.\n            //\n            // We only need to check kind conformity in case user explicitly assigns '?'\n            // tag, for example like this: \"!<?> [0]\"\n            //\n            if (state.result !== null && state.kind !== 'scalar') {\n              throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n            }\n\n            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n              type = state.implicitTypes[typeIndex];\n\n              if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n                state.result = type.construct(state.result);\n                state.tag = type.tag;\n                if (state.anchor !== null) {\n                  state.anchorMap[state.anchor] = state.result;\n                }\n                break;\n              }\n            }\n          } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n            type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n            if (state.result !== null && type.kind !== state.kind) {\n              throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n            }\n\n            if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched\n              throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n            } else {\n              state.result = type.construct(state.result);\n              if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n              }\n            }\n          } else {\n            throwError(state, 'unknown tag !<' + state.tag + '>');\n          }\n        }\n\n        if (state.listener !== null) {\n          state.listener('close', state);\n        }\n        return state.tag !== null || state.anchor !== null || hasContent;\n      }\n\n      function readDocument(state) {\n        var documentStart = state.position,\n          _position,\n          directiveName,\n          directiveArgs,\n          hasDirectives = false,\n          ch;\n\n        state.version = null;\n        state.checkLineBreaks = state.legacy;\n        state.tagMap = {};\n        state.anchorMap = {};\n\n        while ((state.input.charCodeAt(state.position)) !== 0) {\n          skipSeparationSpace(state, true, -1);\n\n          ch = state.input.charCodeAt(state.position);\n\n          if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n            break;\n          }\n\n          hasDirectives = true;\n          ch = state.input.charCodeAt(++state.position);\n          _position = state.position;\n\n          while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          directiveName = state.input.slice(_position, state.position);\n          directiveArgs = [];\n\n          if (directiveName.length < 1) {\n            throwError(state, 'directive name must not be less than one character in length');\n          }\n\n          while (ch !== 0) {\n            while (is_WHITE_SPACE(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n\n            if (ch === 0x23/* # */) {\n              do { ch = state.input.charCodeAt(++state.position); }\n              while (ch !== 0 && !is_EOL(ch));\n              break;\n            }\n\n            if (is_EOL(ch)) break;\n\n            _position = state.position;\n\n            while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n\n            directiveArgs.push(state.input.slice(_position, state.position));\n          }\n\n          if (ch !== 0) readLineBreak(state);\n\n          if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n            directiveHandlers[directiveName](state, directiveName, directiveArgs);\n          } else {\n            throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n          }\n        }\n\n        skipSeparationSpace(state, true, -1);\n\n        if (state.lineIndent === 0 &&\n          state.input.charCodeAt(state.position) === 0x2D/* - */ &&\n          state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n          state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n          state.position += 3;\n          skipSeparationSpace(state, true, -1);\n\n        } else if (hasDirectives) {\n          throwError(state, 'directives end mark is expected');\n        }\n\n        composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n        skipSeparationSpace(state, true, -1);\n\n        if (state.checkLineBreaks &&\n          PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n          throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n        }\n\n        state.documents.push(state.result);\n\n        if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n          if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n            state.position += 3;\n            skipSeparationSpace(state, true, -1);\n          }\n          return;\n        }\n\n        if (state.position < (state.length - 1)) {\n          throwError(state, 'end of the stream or a document separator is expected');\n        } else {\n          return;\n        }\n      }\n\n\n      function loadDocuments(input, options) {\n        input = String(input);\n        options = options || {};\n\n        if (input.length !== 0) {\n\n          // Add tailing `\\n` if not exists\n          if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n            input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n            input += '\\n';\n          }\n\n          // Strip BOM\n          if (input.charCodeAt(0) === 0xFEFF) {\n            input = input.slice(1);\n          }\n        }\n\n        var state = new State(input, options);\n\n        var nullpos = input.indexOf('\\0');\n\n        if (nullpos !== -1) {\n          state.position = nullpos;\n          throwError(state, 'null byte is not allowed in input');\n        }\n\n        // Use 0 as string terminator. That significantly simplifies bounds check.\n        state.input += '\\0';\n\n        while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n          state.lineIndent += 1;\n          state.position += 1;\n        }\n\n        while (state.position < (state.length - 1)) {\n          readDocument(state);\n        }\n\n        return state.documents;\n      }\n\n\n      function loadAll(input, iterator, options) {\n        if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n          options = iterator;\n          iterator = null;\n        }\n\n        var documents = loadDocuments(input, options);\n\n        if (typeof iterator !== 'function') {\n          return documents;\n        }\n\n        for (var index = 0, length = documents.length; index < length; index += 1) {\n          iterator(documents[index]);\n        }\n      }\n\n\n      function load(input, options) {\n        var documents = loadDocuments(input, options);\n\n        if (documents.length === 0) {\n          /*eslint-disable no-undefined*/\n          return undefined;\n        } else if (documents.length === 1) {\n          return documents[0];\n        }\n        throw new YAMLException('expected a single document in the stream, but found more');\n      }\n\n\n      function safeLoadAll(input, iterator, options) {\n        if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n          options = iterator;\n          iterator = null;\n        }\n\n        return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n      }\n\n\n      function safeLoad(input, options) {\n        return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n      }\n\n\n      module.exports.loadAll = loadAll;\n      module.exports.load = load;\n      module.exports.safeLoadAll = safeLoadAll;\n      module.exports.safeLoad = safeLoad;\n\n    }, { \"./common\": 2, \"./exception\": 4, \"./mark\": 6, \"./schema/default_full\": 9, \"./schema/default_safe\": 10 }], 6: [function (require, module, exports) {\n      'use strict';\n\n\n      var common = require('./common');\n\n\n      function Mark(name, buffer, position, line, column) {\n        this.name = name;\n        this.buffer = buffer;\n        this.position = position;\n        this.line = line;\n        this.column = column;\n      }\n\n\n      Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n        var head, start, tail, end, snippet;\n\n        if (!this.buffer) return null;\n\n        indent = indent || 4;\n        maxLength = maxLength || 75;\n\n        head = '';\n        start = this.position;\n\n        while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n          start -= 1;\n          if (this.position - start > (maxLength / 2 - 1)) {\n            head = ' ... ';\n            start += 5;\n            break;\n          }\n        }\n\n        tail = '';\n        end = this.position;\n\n        while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n          end += 1;\n          if (end - this.position > (maxLength / 2 - 1)) {\n            tail = ' ... ';\n            end -= 5;\n            break;\n          }\n        }\n\n        snippet = this.buffer.slice(start, end);\n\n        return common.repeat(' ', indent) + head + snippet + tail + '\\n' +\n          common.repeat(' ', indent + this.position - start + head.length) + '^';\n      };\n\n\n      Mark.prototype.toString = function toString(compact) {\n        var snippet, where = '';\n\n        if (this.name) {\n          where += 'in \"' + this.name + '\" ';\n        }\n\n        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n        if (!compact) {\n          snippet = this.getSnippet();\n\n          if (snippet) {\n            where += ':\\n' + snippet;\n          }\n        }\n\n        return where;\n      };\n\n\n      module.exports = Mark;\n\n    }, { \"./common\": 2 }], 7: [function (require, module, exports) {\n      'use strict';\n\n      /*eslint-disable max-len*/\n\n      var common = require('./common');\n      var YAMLException = require('./exception');\n      var Type = require('./type');\n\n\n      function compileList(schema, name, result) {\n        var exclude = [];\n\n        schema.include.forEach(function (includedSchema) {\n          result = compileList(includedSchema, name, result);\n        });\n\n        schema[name].forEach(function (currentType) {\n          result.forEach(function (previousType, previousIndex) {\n            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n              exclude.push(previousIndex);\n            }\n          });\n\n          result.push(currentType);\n        });\n\n        return result.filter(function (type, index) {\n          return exclude.indexOf(index) === -1;\n        });\n      }\n\n\n      function compileMap(/* lists... */) {\n        var result = {\n          scalar: {},\n          sequence: {},\n          mapping: {},\n          fallback: {}\n        }, index, length;\n\n        function collectType(type) {\n          result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n        }\n\n        for (index = 0, length = arguments.length; index < length; index += 1) {\n          arguments[index].forEach(collectType);\n        }\n        return result;\n      }\n\n\n      function Schema(definition) {\n        this.include = definition.include || [];\n        this.implicit = definition.implicit || [];\n        this.explicit = definition.explicit || [];\n\n        this.implicit.forEach(function (type) {\n          if (type.loadKind && type.loadKind !== 'scalar') {\n            throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n          }\n        });\n\n        this.compiledImplicit = compileList(this, 'implicit', []);\n        this.compiledExplicit = compileList(this, 'explicit', []);\n        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n      }\n\n\n      Schema.DEFAULT = null;\n\n\n      Schema.create = function createSchema() {\n        var schemas, types;\n\n        switch (arguments.length) {\n          case 1:\n            schemas = Schema.DEFAULT;\n            types = arguments[0];\n            break;\n\n          case 2:\n            schemas = arguments[0];\n            types = arguments[1];\n            break;\n\n          default:\n            throw new YAMLException('Wrong number of arguments for Schema.create function');\n        }\n\n        schemas = common.toArray(schemas);\n        types = common.toArray(types);\n\n        if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n          throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n        }\n\n        if (!types.every(function (type) { return type instanceof Type; })) {\n          throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n        }\n\n        return new Schema({\n          include: schemas,\n          explicit: types\n        });\n      };\n\n\n      module.exports = Schema;\n\n    }, { \"./common\": 2, \"./exception\": 4, \"./type\": 13 }], 8: [function (require, module, exports) {\n      // Standard YAML's Core schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2804923\n      //\n      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n      // So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n      'use strict';\n\n\n      var Schema = require('../schema');\n\n\n      module.exports = new Schema({\n        include: [\n          require('./json')\n        ]\n      });\n\n    }, { \"../schema\": 7, \"./json\": 12 }], 9: [function (require, module, exports) {\n      // JS-YAML's default schema for `load` function.\n      // It is not described in the YAML specification.\n      //\n      // This schema is based on JS-YAML's default safe schema and includes\n      // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n      //\n      // Also this schema is used as default base schema at `Schema.create` function.\n\n\n      'use strict';\n\n\n      var Schema = require('../schema');\n\n\n      module.exports = Schema.DEFAULT = new Schema({\n        include: [\n          require('./default_safe')\n        ],\n        explicit: [\n          require('../type/js/undefined'),\n          require('../type/js/regexp'),\n          require('../type/js/function')\n        ]\n      });\n\n    }, { \"../schema\": 7, \"../type/js/function\": 18, \"../type/js/regexp\": 19, \"../type/js/undefined\": 20, \"./default_safe\": 10 }], 10: [function (require, module, exports) {\n      // JS-YAML's default schema for `safeLoad` function.\n      // It is not described in the YAML specification.\n      //\n      // This schema is based on standard YAML's Core schema and includes most of\n      // extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n      'use strict';\n\n\n      var Schema = require('../schema');\n\n\n      module.exports = new Schema({\n        include: [\n          require('./core')\n        ],\n        implicit: [\n          require('../type/timestamp'),\n          require('../type/merge')\n        ],\n        explicit: [\n          require('../type/binary'),\n          require('../type/omap'),\n          require('../type/pairs'),\n          require('../type/set')\n        ]\n      });\n\n    }, { \"../schema\": 7, \"../type/binary\": 14, \"../type/merge\": 22, \"../type/omap\": 24, \"../type/pairs\": 25, \"../type/set\": 27, \"../type/timestamp\": 29, \"./core\": 8 }], 11: [function (require, module, exports) {\n      // Standard YAML's Failsafe schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n      'use strict';\n\n\n      var Schema = require('../schema');\n\n\n      module.exports = new Schema({\n        explicit: [\n          require('../type/str'),\n          require('../type/seq'),\n          require('../type/map')\n        ]\n      });\n\n    }, { \"../schema\": 7, \"../type/map\": 21, \"../type/seq\": 26, \"../type/str\": 28 }], 12: [function (require, module, exports) {\n      // Standard YAML's JSON schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2803231\n      //\n      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n      // So, this schema is not such strict as defined in the YAML specification.\n      // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n      'use strict';\n\n\n      var Schema = require('../schema');\n\n\n      module.exports = new Schema({\n        include: [\n          require('./failsafe')\n        ],\n        implicit: [\n          require('../type/null'),\n          require('../type/bool'),\n          require('../type/int'),\n          require('../type/float')\n        ]\n      });\n\n    }, { \"../schema\": 7, \"../type/bool\": 15, \"../type/float\": 16, \"../type/int\": 17, \"../type/null\": 23, \"./failsafe\": 11 }], 13: [function (require, module, exports) {\n      'use strict';\n\n      var YAMLException = require('./exception');\n\n      var TYPE_CONSTRUCTOR_OPTIONS = [\n        'kind',\n        'resolve',\n        'construct',\n        'instanceOf',\n        'predicate',\n        'represent',\n        'defaultStyle',\n        'styleAliases'\n      ];\n\n      var YAML_NODE_KINDS = [\n        'scalar',\n        'sequence',\n        'mapping'\n      ];\n\n      function compileStyleAliases(map) {\n        var result = {};\n\n        if (map !== null) {\n          Object.keys(map).forEach(function (style) {\n            map[style].forEach(function (alias) {\n              result[String(alias)] = style;\n            });\n          });\n        }\n\n        return result;\n      }\n\n      function Type(tag, options) {\n        options = options || {};\n\n        Object.keys(options).forEach(function (name) {\n          if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n            throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n          }\n        });\n\n        // TODO: Add tag format check.\n        this.tag = tag;\n        this.kind = options['kind'] || null;\n        this.resolve = options['resolve'] || function () { return true; };\n        this.construct = options['construct'] || function (data) { return data; };\n        this.instanceOf = options['instanceOf'] || null;\n        this.predicate = options['predicate'] || null;\n        this.represent = options['represent'] || null;\n        this.defaultStyle = options['defaultStyle'] || null;\n        this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n        if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n          throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n        }\n      }\n\n      module.exports = Type;\n\n    }, { \"./exception\": 4 }], 14: [function (require, module, exports) {\n      'use strict';\n\n      /*eslint-disable no-bitwise*/\n\n      var NodeBuffer;\n\n      try {\n        // A trick for browserified version, to not include `Buffer` shim\n        var _require = require;\n        NodeBuffer = _require('buffer').Buffer;\n      } catch (__) { }\n\n      var Type = require('../type');\n\n\n      // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n      var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\n      function resolveYamlBinary(data) {\n        if (data === null) return false;\n\n        var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n        // Convert one by one.\n        for (idx = 0; idx < max; idx++) {\n          code = map.indexOf(data.charAt(idx));\n\n          // Skip CR/LF\n          if (code > 64) continue;\n\n          // Fail on illegal characters\n          if (code < 0) return false;\n\n          bitlen += 6;\n        }\n\n        // If there are any bits left, source was corrupted\n        return (bitlen % 8) === 0;\n      }\n\n      function constructYamlBinary(data) {\n        var idx, tailbits,\n          input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n          max = input.length,\n          map = BASE64_MAP,\n          bits = 0,\n          result = [];\n\n        // Collect by 6*4 bits (3 bytes)\n\n        for (idx = 0; idx < max; idx++) {\n          if ((idx % 4 === 0) && idx) {\n            result.push((bits >> 16) & 0xFF);\n            result.push((bits >> 8) & 0xFF);\n            result.push(bits & 0xFF);\n          }\n\n          bits = (bits << 6) | map.indexOf(input.charAt(idx));\n        }\n\n        // Dump tail\n\n        tailbits = (max % 4) * 6;\n\n        if (tailbits === 0) {\n          result.push((bits >> 16) & 0xFF);\n          result.push((bits >> 8) & 0xFF);\n          result.push(bits & 0xFF);\n        } else if (tailbits === 18) {\n          result.push((bits >> 10) & 0xFF);\n          result.push((bits >> 2) & 0xFF);\n        } else if (tailbits === 12) {\n          result.push((bits >> 4) & 0xFF);\n        }\n\n        // Wrap into Buffer for NodeJS and leave Array for browser\n        if (NodeBuffer) {\n          // Support node 6.+ Buffer API when available\n          return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n        }\n\n        return result;\n      }\n\n      function representYamlBinary(object /*, style*/) {\n        var result = '', bits = 0, idx, tail,\n          max = object.length,\n          map = BASE64_MAP;\n\n        // Convert every three bytes to 4 ASCII characters.\n\n        for (idx = 0; idx < max; idx++) {\n          if ((idx % 3 === 0) && idx) {\n            result += map[(bits >> 18) & 0x3F];\n            result += map[(bits >> 12) & 0x3F];\n            result += map[(bits >> 6) & 0x3F];\n            result += map[bits & 0x3F];\n          }\n\n          bits = (bits << 8) + object[idx];\n        }\n\n        // Dump tail\n\n        tail = max % 3;\n\n        if (tail === 0) {\n          result += map[(bits >> 18) & 0x3F];\n          result += map[(bits >> 12) & 0x3F];\n          result += map[(bits >> 6) & 0x3F];\n          result += map[bits & 0x3F];\n        } else if (tail === 2) {\n          result += map[(bits >> 10) & 0x3F];\n          result += map[(bits >> 4) & 0x3F];\n          result += map[(bits << 2) & 0x3F];\n          result += map[64];\n        } else if (tail === 1) {\n          result += map[(bits >> 2) & 0x3F];\n          result += map[(bits << 4) & 0x3F];\n          result += map[64];\n          result += map[64];\n        }\n\n        return result;\n      }\n\n      function isBinary(object) {\n        return NodeBuffer && NodeBuffer.isBuffer(object);\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:binary', {\n        kind: 'scalar',\n        resolve: resolveYamlBinary,\n        construct: constructYamlBinary,\n        predicate: isBinary,\n        represent: representYamlBinary\n      });\n\n    }, { \"../type\": 13 }], 15: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlBoolean(data) {\n        if (data === null) return false;\n\n        var max = data.length;\n\n        return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n          (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n      }\n\n      function constructYamlBoolean(data) {\n        return data === 'true' ||\n          data === 'True' ||\n          data === 'TRUE';\n      }\n\n      function isBoolean(object) {\n        return Object.prototype.toString.call(object) === '[object Boolean]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:bool', {\n        kind: 'scalar',\n        resolve: resolveYamlBoolean,\n        construct: constructYamlBoolean,\n        predicate: isBoolean,\n        represent: {\n          lowercase: function (object) { return object ? 'true' : 'false'; },\n          uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n          camelcase: function (object) { return object ? 'True' : 'False'; }\n        },\n        defaultStyle: 'lowercase'\n      });\n\n    }, { \"../type\": 13 }], 16: [function (require, module, exports) {\n      'use strict';\n\n      var common = require('../common');\n      var Type = require('../type');\n\n      var YAML_FLOAT_PATTERN = new RegExp(\n        // 2.5e4, 2.5 and integers\n        '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n        // .2e4, .2\n        // special case, seems not from spec\n        '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n        // 20:59\n        '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n        // .inf\n        '|[-+]?\\\\.(?:inf|Inf|INF)' +\n        // .nan\n        '|\\\\.(?:nan|NaN|NAN))$');\n\n      function resolveYamlFloat(data) {\n        if (data === null) return false;\n\n        if (!YAML_FLOAT_PATTERN.test(data) ||\n          // Quick hack to not allow integers end with `_`\n          // Probably should update regexp & check speed\n          data[data.length - 1] === '_') {\n          return false;\n        }\n\n        return true;\n      }\n\n      function constructYamlFloat(data) {\n        var value, sign, base, digits;\n\n        value = data.replace(/_/g, '').toLowerCase();\n        sign = value[0] === '-' ? -1 : 1;\n        digits = [];\n\n        if ('+-'.indexOf(value[0]) >= 0) {\n          value = value.slice(1);\n        }\n\n        if (value === '.inf') {\n          return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n        } else if (value === '.nan') {\n          return NaN;\n\n        } else if (value.indexOf(':') >= 0) {\n          value.split(':').forEach(function (v) {\n            digits.unshift(parseFloat(v));\n          });\n\n          value = 0.0;\n          base = 1;\n\n          digits.forEach(function (d) {\n            value += d * base;\n            base *= 60;\n          });\n\n          return sign * value;\n\n        }\n        return sign * parseFloat(value);\n      }\n\n\n      var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\n      function representYamlFloat(object, style) {\n        var res;\n\n        if (isNaN(object)) {\n          switch (style) {\n            case 'lowercase': return '.nan';\n            case 'uppercase': return '.NAN';\n            case 'camelcase': return '.NaN';\n          }\n        } else if (Number.POSITIVE_INFINITY === object) {\n          switch (style) {\n            case 'lowercase': return '.inf';\n            case 'uppercase': return '.INF';\n            case 'camelcase': return '.Inf';\n          }\n        } else if (Number.NEGATIVE_INFINITY === object) {\n          switch (style) {\n            case 'lowercase': return '-.inf';\n            case 'uppercase': return '-.INF';\n            case 'camelcase': return '-.Inf';\n          }\n        } else if (common.isNegativeZero(object)) {\n          return '-0.0';\n        }\n\n        res = object.toString(10);\n\n        // JS stringifier can build scientific format without dots: 5e-100,\n        // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n        return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n      }\n\n      function isFloat(object) {\n        return (Object.prototype.toString.call(object) === '[object Number]') &&\n          (object % 1 !== 0 || common.isNegativeZero(object));\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:float', {\n        kind: 'scalar',\n        resolve: resolveYamlFloat,\n        construct: constructYamlFloat,\n        predicate: isFloat,\n        represent: representYamlFloat,\n        defaultStyle: 'lowercase'\n      });\n\n    }, { \"../common\": 2, \"../type\": 13 }], 17: [function (require, module, exports) {\n      'use strict';\n\n      var common = require('../common');\n      var Type = require('../type');\n\n      function isHexCode(c) {\n        return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n          ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n          ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n      }\n\n      function isOctCode(c) {\n        return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n      }\n\n      function isDecCode(c) {\n        return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n      }\n\n      function resolveYamlInteger(data) {\n        if (data === null) return false;\n\n        var max = data.length,\n          index = 0,\n          hasDigits = false,\n          ch;\n\n        if (!max) return false;\n\n        ch = data[index];\n\n        // sign\n        if (ch === '-' || ch === '+') {\n          ch = data[++index];\n        }\n\n        if (ch === '0') {\n          // 0\n          if (index + 1 === max) return true;\n          ch = data[++index];\n\n          // base 2, base 8, base 16\n\n          if (ch === 'b') {\n            // base 2\n            index++;\n\n            for (; index < max; index++) {\n              ch = data[index];\n              if (ch === '_') continue;\n              if (ch !== '0' && ch !== '1') return false;\n              hasDigits = true;\n            }\n            return hasDigits && ch !== '_';\n          }\n\n\n          if (ch === 'x') {\n            // base 16\n            index++;\n\n            for (; index < max; index++) {\n              ch = data[index];\n              if (ch === '_') continue;\n              if (!isHexCode(data.charCodeAt(index))) return false;\n              hasDigits = true;\n            }\n            return hasDigits && ch !== '_';\n          }\n\n          // base 8\n          for (; index < max; index++) {\n            ch = data[index];\n            if (ch === '_') continue;\n            if (!isOctCode(data.charCodeAt(index))) return false;\n            hasDigits = true;\n          }\n          return hasDigits && ch !== '_';\n        }\n\n        // base 10 (except 0) or base 60\n\n        // value should not start with `_`;\n        if (ch === '_') return false;\n\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (ch === ':') break;\n          if (!isDecCode(data.charCodeAt(index))) {\n            return false;\n          }\n          hasDigits = true;\n        }\n\n        // Should have digits and should not end with `_`\n        if (!hasDigits || ch === '_') return false;\n\n        // if !base60 - done;\n        if (ch !== ':') return true;\n\n        // base60 almost not used, no needs to optimize\n        return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n      }\n\n      function constructYamlInteger(data) {\n        var value = data, sign = 1, ch, base, digits = [];\n\n        if (value.indexOf('_') !== -1) {\n          value = value.replace(/_/g, '');\n        }\n\n        ch = value[0];\n\n        if (ch === '-' || ch === '+') {\n          if (ch === '-') sign = -1;\n          value = value.slice(1);\n          ch = value[0];\n        }\n\n        if (value === '0') return 0;\n\n        if (ch === '0') {\n          if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n          if (value[1] === 'x') return sign * parseInt(value, 16);\n          return sign * parseInt(value, 8);\n        }\n\n        if (value.indexOf(':') !== -1) {\n          value.split(':').forEach(function (v) {\n            digits.unshift(parseInt(v, 10));\n          });\n\n          value = 0;\n          base = 1;\n\n          digits.forEach(function (d) {\n            value += (d * base);\n            base *= 60;\n          });\n\n          return sign * value;\n\n        }\n\n        return sign * parseInt(value, 10);\n      }\n\n      function isInteger(object) {\n        return (Object.prototype.toString.call(object)) === '[object Number]' &&\n          (object % 1 === 0 && !common.isNegativeZero(object));\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:int', {\n        kind: 'scalar',\n        resolve: resolveYamlInteger,\n        construct: constructYamlInteger,\n        predicate: isInteger,\n        represent: {\n          binary: function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n          octal: function (obj) { return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1); },\n          decimal: function (obj) { return obj.toString(10); },\n          /* eslint-disable max-len */\n          hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1); }\n        },\n        defaultStyle: 'decimal',\n        styleAliases: {\n          binary: [2, 'bin'],\n          octal: [8, 'oct'],\n          decimal: [10, 'dec'],\n          hexadecimal: [16, 'hex']\n        }\n      });\n\n    }, { \"../common\": 2, \"../type\": 13 }], 18: [function (require, module, exports) {\n      'use strict';\n\n      var esprima;\n\n      // Browserified version does not have esprima\n      //\n      // 1. For node.js just require module as deps\n      // 2. For browser try to require mudule via external AMD system.\n      //    If not found - try to fallback to window.esprima. If not\n      //    found too - then fail to parse.\n      //\n      try {\n        // workaround to exclude package from browserify list.\n        var _require = require;\n        esprima = _require('esprima');\n      } catch (_) {\n        /* eslint-disable no-redeclare */\n        /* global window */\n        if (typeof window !== 'undefined') esprima = window.esprima;\n      }\n\n      var Type = require('../../type');\n\n      function resolveJavascriptFunction(data) {\n        if (data === null) return false;\n\n        try {\n          var source = '(' + data + ')',\n            ast = esprima.parse(source, { range: true });\n\n          if (ast.type !== 'Program' ||\n            ast.body.length !== 1 ||\n            ast.body[0].type !== 'ExpressionStatement' ||\n            (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n              ast.body[0].expression.type !== 'FunctionExpression')) {\n            return false;\n          }\n\n          return true;\n        } catch (err) {\n          return false;\n        }\n      }\n\n      function constructJavascriptFunction(data) {\n        /*jslint evil:true*/\n\n        var source = '(' + data + ')',\n          ast = esprima.parse(source, { range: true }),\n          params = [],\n          body;\n\n        if (ast.type !== 'Program' ||\n          ast.body.length !== 1 ||\n          ast.body[0].type !== 'ExpressionStatement' ||\n          (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n            ast.body[0].expression.type !== 'FunctionExpression')) {\n          throw new Error('Failed to resolve function');\n        }\n\n        ast.body[0].expression.params.forEach(function (param) {\n          params.push(param.name);\n        });\n\n        body = ast.body[0].expression.body.range;\n\n        // Esprima's ranges include the first '{' and the last '}' characters on\n        // function expressions. So cut them out.\n        if (ast.body[0].expression.body.type === 'BlockStatement') {\n          /*eslint-disable no-new-func*/\n          return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n        }\n        // ES6 arrow functions can omit the BlockStatement. In that case, just return\n        // the body.\n        /*eslint-disable no-new-func*/\n        return new Function(params, 'return ' + source.slice(body[0], body[1]));\n      }\n\n      function representJavascriptFunction(object /*, style*/) {\n        return object.toString();\n      }\n\n      function isFunction(object) {\n        return Object.prototype.toString.call(object) === '[object Function]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/function', {\n        kind: 'scalar',\n        resolve: resolveJavascriptFunction,\n        construct: constructJavascriptFunction,\n        predicate: isFunction,\n        represent: representJavascriptFunction\n      });\n\n    }, { \"../../type\": 13 }], 19: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../../type');\n\n      function resolveJavascriptRegExp(data) {\n        if (data === null) return false;\n        if (data.length === 0) return false;\n\n        var regexp = data,\n          tail = /\\/([gim]*)$/.exec(data),\n          modifiers = '';\n\n        // if regexp starts with '/' it can have modifiers and must be properly closed\n        // `/foo/gim` - modifiers tail can be maximum 3 chars\n        if (regexp[0] === '/') {\n          if (tail) modifiers = tail[1];\n\n          if (modifiers.length > 3) return false;\n          // if expression starts with /, is should be properly terminated\n          if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n        }\n\n        return true;\n      }\n\n      function constructJavascriptRegExp(data) {\n        var regexp = data,\n          tail = /\\/([gim]*)$/.exec(data),\n          modifiers = '';\n\n        // `/foo/gim` - tail can be maximum 4 chars\n        if (regexp[0] === '/') {\n          if (tail) modifiers = tail[1];\n          regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n        }\n\n        return new RegExp(regexp, modifiers);\n      }\n\n      function representJavascriptRegExp(object /*, style*/) {\n        var result = '/' + object.source + '/';\n\n        if (object.global) result += 'g';\n        if (object.multiline) result += 'm';\n        if (object.ignoreCase) result += 'i';\n\n        return result;\n      }\n\n      function isRegExp(object) {\n        return Object.prototype.toString.call(object) === '[object RegExp]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/regexp', {\n        kind: 'scalar',\n        resolve: resolveJavascriptRegExp,\n        construct: constructJavascriptRegExp,\n        predicate: isRegExp,\n        represent: representJavascriptRegExp\n      });\n\n    }, { \"../../type\": 13 }], 20: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../../type');\n\n      function resolveJavascriptUndefined() {\n        return true;\n      }\n\n      function constructJavascriptUndefined() {\n        /*eslint-disable no-undefined*/\n        return undefined;\n      }\n\n      function representJavascriptUndefined() {\n        return '';\n      }\n\n      function isUndefined(object) {\n        return typeof object === 'undefined';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/undefined', {\n        kind: 'scalar',\n        resolve: resolveJavascriptUndefined,\n        construct: constructJavascriptUndefined,\n        predicate: isUndefined,\n        represent: representJavascriptUndefined\n      });\n\n    }, { \"../../type\": 13 }], 21: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:map', {\n        kind: 'mapping',\n        construct: function (data) { return data !== null ? data : {}; }\n      });\n\n    }, { \"../type\": 13 }], 22: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlMerge(data) {\n        return data === '<<' || data === null;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:merge', {\n        kind: 'scalar',\n        resolve: resolveYamlMerge\n      });\n\n    }, { \"../type\": 13 }], 23: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlNull(data) {\n        if (data === null) return true;\n\n        var max = data.length;\n\n        return (max === 1 && data === '~') ||\n          (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n      }\n\n      function constructYamlNull() {\n        return null;\n      }\n\n      function isNull(object) {\n        return object === null;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:null', {\n        kind: 'scalar',\n        resolve: resolveYamlNull,\n        construct: constructYamlNull,\n        predicate: isNull,\n        represent: {\n          canonical: function () { return '~'; },\n          lowercase: function () { return 'null'; },\n          uppercase: function () { return 'NULL'; },\n          camelcase: function () { return 'Null'; }\n        },\n        defaultStyle: 'lowercase'\n      });\n\n    }, { \"../type\": 13 }], 24: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n      var _toString = Object.prototype.toString;\n\n      function resolveYamlOmap(data) {\n        if (data === null) return true;\n\n        var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n          object = data;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n          pairHasKey = false;\n\n          if (_toString.call(pair) !== '[object Object]') return false;\n\n          for (pairKey in pair) {\n            if (_hasOwnProperty.call(pair, pairKey)) {\n              if (!pairHasKey) pairHasKey = true;\n              else return false;\n            }\n          }\n\n          if (!pairHasKey) return false;\n\n          if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n          else return false;\n        }\n\n        return true;\n      }\n\n      function constructYamlOmap(data) {\n        return data !== null ? data : [];\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:omap', {\n        kind: 'sequence',\n        resolve: resolveYamlOmap,\n        construct: constructYamlOmap\n      });\n\n    }, { \"../type\": 13 }], 25: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _toString = Object.prototype.toString;\n\n      function resolveYamlPairs(data) {\n        if (data === null) return true;\n\n        var index, length, pair, keys, result,\n          object = data;\n\n        result = new Array(object.length);\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n\n          if (_toString.call(pair) !== '[object Object]') return false;\n\n          keys = Object.keys(pair);\n\n          if (keys.length !== 1) return false;\n\n          result[index] = [keys[0], pair[keys[0]]];\n        }\n\n        return true;\n      }\n\n      function constructYamlPairs(data) {\n        if (data === null) return [];\n\n        var index, length, pair, keys, result,\n          object = data;\n\n        result = new Array(object.length);\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n\n          keys = Object.keys(pair);\n\n          result[index] = [keys[0], pair[keys[0]]];\n        }\n\n        return result;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:pairs', {\n        kind: 'sequence',\n        resolve: resolveYamlPairs,\n        construct: constructYamlPairs\n      });\n\n    }, { \"../type\": 13 }], 26: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:seq', {\n        kind: 'sequence',\n        construct: function (data) { return data !== null ? data : []; }\n      });\n\n    }, { \"../type\": 13 }], 27: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n      function resolveYamlSet(data) {\n        if (data === null) return true;\n\n        var key, object = data;\n\n        for (key in object) {\n          if (_hasOwnProperty.call(object, key)) {\n            if (object[key] !== null) return false;\n          }\n        }\n\n        return true;\n      }\n\n      function constructYamlSet(data) {\n        return data !== null ? data : {};\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:set', {\n        kind: 'mapping',\n        resolve: resolveYamlSet,\n        construct: constructYamlSet\n      });\n\n    }, { \"../type\": 13 }], 28: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:str', {\n        kind: 'scalar',\n        construct: function (data) { return data !== null ? data : ''; }\n      });\n\n    }, { \"../type\": 13 }], 29: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var YAML_DATE_REGEXP = new RegExp(\n        '^([0-9][0-9][0-9][0-9])' + // [1] year\n        '-([0-9][0-9])' + // [2] month\n        '-([0-9][0-9])$');                   // [3] day\n\n      var YAML_TIMESTAMP_REGEXP = new RegExp(\n        '^([0-9][0-9][0-9][0-9])' + // [1] year\n        '-([0-9][0-9]?)' + // [2] month\n        '-([0-9][0-9]?)' + // [3] day\n        '(?:[Tt]|[ \\\\t]+)' + // ...\n        '([0-9][0-9]?)' + // [4] hour\n        ':([0-9][0-9])' + // [5] minute\n        ':([0-9][0-9])' + // [6] second\n        '(?:\\\\.([0-9]*))?' + // [7] fraction\n        '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n        '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\n      function resolveYamlTimestamp(data) {\n        if (data === null) return false;\n        if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n        if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n        return false;\n      }\n\n      function constructYamlTimestamp(data) {\n        var match, year, month, day, hour, minute, second, fraction = 0,\n          delta = null, tz_hour, tz_minute, date;\n\n        match = YAML_DATE_REGEXP.exec(data);\n        if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n        if (match === null) throw new Error('Date resolve error');\n\n        // match: [1] year [2] month [3] day\n\n        year = +(match[1]);\n        month = +(match[2]) - 1; // JS month starts with 0\n        day = +(match[3]);\n\n        if (!match[4]) { // no hour\n          return new Date(Date.UTC(year, month, day));\n        }\n\n        // match: [4] hour [5] minute [6] second [7] fraction\n\n        hour = +(match[4]);\n        minute = +(match[5]);\n        second = +(match[6]);\n\n        if (match[7]) {\n          fraction = match[7].slice(0, 3);\n          while (fraction.length < 3) { // milli-seconds\n            fraction += '0';\n          }\n          fraction = +fraction;\n        }\n\n        // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n        if (match[9]) {\n          tz_hour = +(match[10]);\n          tz_minute = +(match[11] || 0);\n          delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n          if (match[9] === '-') delta = -delta;\n        }\n\n        date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n        if (delta) date.setTime(date.getTime() - delta);\n\n        return date;\n      }\n\n      function representYamlTimestamp(object /*, style*/) {\n        return object.toISOString();\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:timestamp', {\n        kind: 'scalar',\n        resolve: resolveYamlTimestamp,\n        construct: constructYamlTimestamp,\n        instanceOf: Date,\n        represent: representYamlTimestamp\n      });\n\n    }, { \"../type\": 13 }], \"/\": [function (require, module, exports) {\n      'use strict';\n\n\n      var yaml = require('./lib/js-yaml.js');\n\n\n      module.exports = yaml;\n\n    }, { \"./lib/js-yaml.js\": 1 }]\n  }, {}, [])(\"/\")\n});\n"],"sourceRoot":""}